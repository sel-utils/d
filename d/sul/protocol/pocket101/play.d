/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket101.xml
 */
/**
 * Packets related to the gameplay. Network-related packets (encapsulation, acks, nacks)
 * are managed by RakNet and every packet in this section is encapsualted in an Encapsualted
 * packet.
 */
module sul.protocol.pocket101.play;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.pocket101.types;

static if(__traits(compiles, { import sul.metadata.pocket101; })) import sul.metadata.pocket101;

alias Packets = TypeTuple!(Login, PlayStatus, ServerToClientHandshake, ClientToServerHandshake, Disconnect, Batch, ResourcePacksInfo, ResourcePacksStackPacket, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, RemoveBlock, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, MobEquipment, MobArmorEquipment, Interact, UseItem, PlayerAction, PlayerFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, DropItem, InventoryAction, ContainerOpen, ContainerClose, ContainerSetSlot, ContainerSetData, ContainerSetContent, CraftingData, CraftingEvent, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCommandsEnabled, SetDifficulty, ChangeDimension, SetPlayerGameType, PlayerList, TelemetryEvent, SpawnExperienceOrb, ClientboundMapItemData, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, ReplaceSelectedItem, GameRulesChanged, Camera, AddItem, BossEvent, ShowCredits, AvailableCommands, CommandStep, ResourcePackDataInfo, ResourcePackChunkData, ResourcePackChunkRequest, Transfer);

/**
 * First MCPE packet sent after the establishment of the connection through raknet.
 * It contains informations about the player.
 */
class Login : Buffer {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public enum string[] FIELDS = ["protocol", "edition", "body_"];

	/**
	 * Version of the protocol used by the player.
	 */
	public uint protocol;

	/**
	 * Edition that the player is using to join the server. The different editions may
	 * have different features and servers may block the access from unaccepted editions
	 * of the game.
	 */
	public ubyte edition;

	/**
	 * Zlib-compressed bytes that contains 2 JWTs with more informations about the player
	 * and its account. Once uncompressed the resulting payload will contain 2 JWTs which
	 * length is indicated by a little-endian unsigned integer each.
	 */
	public ubyte[] body_;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint protocol, ubyte edition=ubyte.init, ubyte[] body_=(ubyte[]).init) {
		this.protocol = protocol;
		this.edition = edition;
		this.body_ = body_;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(protocol);
		writeBigEndianUbyte(edition);
		writeBytes(varuint.encode(cast(uint)body_.length)); writeBytes(body_);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		protocol=readBigEndianUint();
		edition=readBigEndianUbyte();
		body_.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+body_.length){ body_=_buffer[_index.._index+body_.length].dup; _index+=body_.length; }
	}

	public static pure nothrow @safe Login fromBuffer(bool readId=true)(ubyte[] buffer) {
		Login ret = new Login();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Login(protocol: " ~ std.conv.to!string(this.protocol) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", body_: " ~ std.conv.to!string(this.body_) ~ ")";
	}

}

/**
 * Packet sent as response to Login to indicate whether the connection has been accepted
 * and when the player is ready to spawn in the world.
 */
class PlayStatus : Buffer {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum uint OK = 0;
	public enum uint OUTDATED_CLIENT = 1;
	public enum uint OUTDATED_SERVER = 2;
	public enum uint SPAWNED = 3;
	public enum uint INVALID_TENANT = 4;
	public enum uint EDITION_MISMATCH = 5;

	public enum string[] FIELDS = ["status"];

	public uint status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint status) {
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(status);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		status=readBigEndianUint();
	}

	public static pure nothrow @safe PlayStatus fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayStatus ret = new PlayStatus();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayStatus(status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

class ServerToClientHandshake : Buffer {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["serverPublicKey", "token"];

	public string serverPublicKey;
	public ubyte[] token;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string serverPublicKey, ubyte[] token=(ubyte[]).init) {
		this.serverPublicKey = serverPublicKey;
		this.token = token;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)serverPublicKey.length)); writeString(serverPublicKey);
		writeBytes(varuint.encode(cast(uint)token.length)); writeBytes(token);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint cvdvuvbl=varuint.decode(_buffer, &_index); serverPublicKey=readString(cvdvuvbl);
		token.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+token.length){ token=_buffer[_index.._index+token.length].dup; _index+=token.length; }
	}

	public static pure nothrow @safe ServerToClientHandshake fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerToClientHandshake ret = new ServerToClientHandshake();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerToClientHandshake(serverPublicKey: " ~ std.conv.to!string(this.serverPublicKey) ~ ", token: " ~ std.conv.to!string(this.token) ~ ")";
	}

}

class ClientToServerHandshake : Buffer {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
	}

	public static pure nothrow @safe ClientToServerHandshake fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientToServerHandshake ret = new ClientToServerHandshake();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientToServerHandshake()";
	}

}

/**
 * Disconnects the player from the server.
 */
class Disconnect : Buffer {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hideDisconnectionScreen", "message"];

	/**
	 * Indicates whether to display the main menu screen or a disconnection message.
	 */
	public bool hideDisconnectionScreen;

	/**
	 * The message to display in the disconnection screen. If the message is in the game's
	 * language file it will be translated client-side.
	 */
	public string message;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool hideDisconnectionScreen, string message=string.init) {
		this.hideDisconnectionScreen = hideDisconnectionScreen;
		this.message = message;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(hideDisconnectionScreen);
		if(hideDisconnectionScreen==false){ writeBytes(varuint.encode(cast(uint)message.length)); writeString(message); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		hideDisconnectionScreen=readBigEndianBool();
		if(hideDisconnectionScreen==false){ uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz); }
	}

	public static pure nothrow @safe Disconnect fromBuffer(bool readId=true)(ubyte[] buffer) {
		Disconnect ret = new Disconnect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Disconnect(hideDisconnectionScreen: " ~ std.conv.to!string(this.hideDisconnectionScreen) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
	}

}

/**
 * One ore more packet, each prefixed with their varuint-encoded length, compressed
 * with zlib's deflate algorithm.
 */
class Batch : Buffer {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["data"];

	/**
	 * Compressed data.
	 * 
	 * Pseudo-code for decompression:
	 * ---
	 * ubyte[] uncompressed = uncompress(batch.payload);
	 * int index = 0;
	 * while(index < uncompressed.length) {
	 *    int length = varuint.decode(uncompressed, &index);
	 *    if(length < uncompressed.length - index) {}
	 *       ubyte[] packet = uncompressed[0..length];
	 *       index += length;
	 *    }
	 * }
	 * ---
	 * 
	 * Pseudo-code for compression:
	 * ---
	 * ubyte[] payload;
	 * foreach(ubyte[] packet ; packets) {
	 *    payload.concat(varuint.encode(packet.length));
	 *    payload.concat(packet);
	 * }
	 * Batch batch = new Batch(compress(payload, Zlib.DEFLATE));
	 * ---
	 */
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte[] data) {
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe Batch fromBuffer(bool readId=true)(ubyte[] buffer) {
		Batch ret = new Batch();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Batch(data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ResourcePacksInfo : Buffer {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mustAccept", "behaviourPacks", "resourcePacks"];

	public bool mustAccept;
	public sul.protocol.pocket101.types.PackWithSize[] behaviourPacks;
	public sul.protocol.pocket101.types.PackWithSize[] resourcePacks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool mustAccept, sul.protocol.pocket101.types.PackWithSize[] behaviourPacks=(sul.protocol.pocket101.types.PackWithSize[]).init, sul.protocol.pocket101.types.PackWithSize[] resourcePacks=(sul.protocol.pocket101.types.PackWithSize[]).init) {
		this.mustAccept = mustAccept;
		this.behaviourPacks = behaviourPacks;
		this.resourcePacks = resourcePacks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(mustAccept);
		writeLittleEndianUshort(cast(ushort)behaviourPacks.length); foreach(yvyzbvuf;behaviourPacks){ yvyzbvuf.encode(bufferInstance); }
		writeLittleEndianUshort(cast(ushort)resourcePacks.length); foreach(cvbvyvyn;resourcePacks){ cvbvyvyn.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mustAccept=readBigEndianBool();
		behaviourPacks.length=readLittleEndianUshort(); foreach(ref yvyzbvuf;behaviourPacks){ yvyzbvuf.decode(bufferInstance); }
		resourcePacks.length=readLittleEndianUshort(); foreach(ref cvbvyvyn;resourcePacks){ cvbvyvyn.decode(bufferInstance); }
	}

	public static pure nothrow @safe ResourcePacksInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePacksInfo ret = new ResourcePacksInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePacksInfo(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
	}

}

class ResourcePacksStackPacket : Buffer {

	public enum ubyte ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mustAccept", "behaviourPacks", "resourcePacks"];

	public bool mustAccept;
	public sul.protocol.pocket101.types.Pack[] behaviourPacks;
	public sul.protocol.pocket101.types.Pack[] resourcePacks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool mustAccept, sul.protocol.pocket101.types.Pack[] behaviourPacks=(sul.protocol.pocket101.types.Pack[]).init, sul.protocol.pocket101.types.Pack[] resourcePacks=(sul.protocol.pocket101.types.Pack[]).init) {
		this.mustAccept = mustAccept;
		this.behaviourPacks = behaviourPacks;
		this.resourcePacks = resourcePacks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(mustAccept);
		writeLittleEndianUshort(cast(ushort)behaviourPacks.length); foreach(yvyzbvuf;behaviourPacks){ yvyzbvuf.encode(bufferInstance); }
		writeLittleEndianUshort(cast(ushort)resourcePacks.length); foreach(cvbvyvyn;resourcePacks){ cvbvyvyn.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mustAccept=readBigEndianBool();
		behaviourPacks.length=readLittleEndianUshort(); foreach(ref yvyzbvuf;behaviourPacks){ yvyzbvuf.decode(bufferInstance); }
		resourcePacks.length=readLittleEndianUshort(); foreach(ref cvbvyvyn;resourcePacks){ cvbvyvyn.decode(bufferInstance); }
	}

	public static pure nothrow @safe ResourcePacksStackPacket fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePacksStackPacket ret = new ResourcePacksStackPacket();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePacksStackPacket(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
	}

}

class ResourcePackClientResponse : Buffer {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// status
	public enum ubyte REFUSED = 1;
	public enum ubyte SEND_PACKS = 2;
	public enum ubyte HAVE_ALL_PACKS = 3;
	public enum ubyte COMPLETED = 4;

	public enum string[] FIELDS = ["status", "packIds"];

	public ubyte status;
	public string[] packIds;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte status, string[] packIds=(string[]).init) {
		this.status = status;
		this.packIds = packIds;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(status);
		writeLittleEndianUshort(cast(ushort)packIds.length); foreach(cfalc;packIds){ writeBytes(varuint.encode(cast(uint)cfalc.length)); writeString(cfalc); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		status=readBigEndianUbyte();
		packIds.length=readLittleEndianUshort(); foreach(ref cfalc;packIds){ uint yzbm=varuint.decode(_buffer, &_index); cfalc=readString(yzbm); }
	}

	public static pure nothrow @safe ResourcePackClientResponse fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackClientResponse ret = new ResourcePackClientResponse();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackClientResponse(status: " ~ std.conv.to!string(this.status) ~ ", packIds: " ~ std.conv.to!string(this.packIds) ~ ")";
	}

}

/**
 * Sends or receives a message from the player. Every variant's field can contain Minecraft's
 * formatting codes.
 * Every packet sent in the same game tick should be joined together with `\n§r` (line
 * break and reset formatting), otherwise the messages will be displayed multiple times
 * on the client's chat (see [MCPE-17631](https://bugs.mojang.com/browse/MCPE-17631)).
 */
class Text : Buffer {

	public enum ubyte ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["type"];

	public ubyte type;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte type) {
		this.type = type;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(type);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		type=readBigEndianUbyte();
	}

	public static pure nothrow @safe Text fromBuffer(bool readId=true)(ubyte[] buffer) {
		Text ret = new Text();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Text(type: " ~ std.conv.to!string(this.type) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "type";

	alias Variants = TypeTuple!(Raw, Chat, Translation, Popup, Tip, System, Whisper);

	/**
	 * Raw message that will be printed in the chat as it is.
	 */
	public class Raw {

		public enum typeof(type) TYPE = 0;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Raw(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	/**
	 * Chat message sent by the player to the server. If sent from the server it will display
	 * as `&lt;sender&gt; message`.
	 */
	public class Chat {

		public enum typeof(type) TYPE = 1;

		public enum string[] FIELDS = ["sender", "message"];

		/**
		 * Case sensitive name of the player that has sent the message.
		 */
		public string sender;

		/**
		 * Message sent by the player. It should be unformatted (regular expression: `§[a-fA-F0-9k-or]`)
		 * before being processed as chat message by the server.
		 */
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init) {
			this.sender = sender;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint cvzv=varuint.decode(_buffer, &_index); sender=readString(cvzv);
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Chat(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	/**
	 * Sends a message that will be translated client-side using the player's language.
	 */
	public class Translation {

		public enum typeof(type) TYPE = 2;

		public enum string[] FIELDS = ["message", "parameters"];

		/**
		 * A message in the game's language file.
		 */
		public string message;

		/**
		 * Parameters that will be placed instead of the replacement symbols (%1, %2, etc...).
		 */
		public string[] parameters;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message, string[] parameters=(string[]).init) {
			this.message = message;
			this.parameters = parameters;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 2;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)parameters.length)); foreach(cfy1dvc;parameters){ writeBytes(varuint.encode(cast(uint)cfy1dvc.length)); writeString(cfy1dvc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
			parameters.length=varuint.decode(_buffer, &_index); foreach(ref cfy1dvc;parameters){ uint yzmry=varuint.decode(_buffer, &_index); cfy1dvc=readString(yzmry); }
		}

		public override string toString() {
			return "Text.Translation(message: " ~ std.conv.to!string(this.message) ~ ", parameters: " ~ std.conv.to!string(this.parameters) ~ ")";
		}

	}

	/**
	 * Displays popups messages for one tick before fading out. The popup messages are
	 * displayed at the centre of the screen and are not automatically aligned horizontally.
	 */
	public class Popup {

		public enum typeof(type) TYPE = 3;

		public enum string[] FIELDS = ["title", "subtitle"];

		public string title;
		public string subtitle;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title, string subtitle=string.init) {
			this.title = title;
			this.subtitle = subtitle;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			writeBytes(varuint.encode(cast(uint)subtitle.length)); writeString(subtitle);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
			uint cvdlbu=varuint.decode(_buffer, &_index); subtitle=readString(cvdlbu);
		}

		public override string toString() {
			return "Text.Popup(title: " ~ std.conv.to!string(this.title) ~ ", subtitle: " ~ std.conv.to!string(this.subtitle) ~ ")";
		}

	}

	/**
	 * Displays a tip message for one tick before fading out. The tip message is displayed
	 * on top of the inventory bar and can contain multiple lines separated with `\n`.
	 */
	public class Tip {

		public enum typeof(type) TYPE = 4;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Tip(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class System {

		public enum typeof(type) TYPE = 5;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 5;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.System(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	/**
	 * Sends a whisper message to the client that will be displayed in the format `<i>sender
	 * has whispered to you:</i> message`.
	 */
	public class Whisper {

		public enum typeof(type) TYPE = 6;

		public enum string[] FIELDS = ["sender", "message"];

		public string sender;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init) {
			this.sender = sender;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 6;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint cvzv=varuint.decode(_buffer, &_index); sender=readString(cvzv);
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Whisper(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

}

/**
 * Sets the time.
 */
class SetTime : Buffer {

	public enum ubyte ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["time", "daylightCycle"];

	/**
	 * Time of the day in a range from 0 to 24000. If higher or lower it will be moduled
	 * to 24000.
	 */
	public int time;

	/**
	 * Indicates whether the daylight cycle is active. If not, the time will be stopped
	 * at the value given in the previous field.
	 */
	public bool daylightCycle;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int time, bool daylightCycle=bool.init) {
		this.time = time;
		this.daylightCycle = daylightCycle;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(time));
		writeBigEndianBool(daylightCycle);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		time=varint.decode(_buffer, &_index);
		daylightCycle=readBigEndianBool();
	}

	public static pure nothrow @safe SetTime fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetTime ret = new SetTime();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetTime(time: " ~ std.conv.to!string(this.time) ~ ", daylightCycle: " ~ std.conv.to!string(this.daylightCycle) ~ ")";
	}

}

class StartGame : Buffer {

	public enum ubyte ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	// generator
	public enum int OLD = 0;
	public enum int INFINITE = 1;
	public enum int FLAT = 2;

	// world gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	// difficulty
	public enum int PEACEFUL = 0;
	public enum int EASY = 1;
	public enum int NORMAL = 2;
	public enum int HARD = 3;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "yaw", "pitch", "seed", "dimension", "generator", "worldGamemode", "difficulty", "spawnPosition", "loadedInCreative", "time", "edition", "rainLevel", "lightingLevel", "commandsEnabled", "textureRequired", "levelId", "worldName"];

	/**
	 * Player's entity id that uniquely identifies the entity of the server.
	 */
	public long entityId;
	public long runtimeId;

	/**
	 * Position where the player will spawn.
	 */
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float yaw;
	public float pitch;

	/**
	 * World's seed. It's displayed in the game's world settings and in beta's debug informations
	 * on top of the screen.
	 */
	public int seed;

	/**
	 * World's dimension. Different dimensions have different sky colours and render distances.
	 */
	public int dimension = 0;

	/**
	 * World's type. It's displayed in the game's world settings.
	 * In old and infinite world the sky becomes darker at 32 blocks of altitude and in
	 * flat worlds it only becomes darker under 0.
	 */
	public int generator = 1;

	/**
	 * Default's world gamemode. If the player's gamemode is different from the default's
	 * one a SetPlayerGameType should be sent after this.
	 */
	public int worldGamemode;

	/**
	 * World's difficulty. The value is visible in the client's world settings.
	 */
	public int difficulty;

	/**
	 * Position where the client's compass will point to.
	 */
	public Tuple!(int, "x", int, "y", int, "z") spawnPosition;
	public bool loadedInCreative;

	/**
	 * Time of the day that should be in a range from 0 to 24000. If not the absolute value
	 * is moduled per 24000.
	 * If the world's time is stopped a SetTime packet should be sent after this.
	 */
	public int time;

	/**
	 * Game's edition. Some behaviours (some entities for example) may only work in a version
	 * and not in the other.
	 */
	public ubyte edition;

	/**
	 * Intensity of the rain or the snow. Any value lower than or equals to 0 means no
	 * rain.
	 */
	public float rainLevel;
	public float lightingLevel;

	/**
	 * Indicates whether the cheats are enabled. If the cheats are disabled the player
	 * cannot send commands.
	 */
	public bool commandsEnabled;
	public bool textureRequired;
	public string levelId;

	/**
	 * World's name that will be displayed in the game's world settings. It can contain
	 * formatting codes.
	 */
	public string worldName;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float yaw=float.init, float pitch=float.init, int seed=int.init, int dimension=0, int generator=1, int worldGamemode=int.init, int difficulty=int.init, Tuple!(int, "x", int, "y", int, "z") spawnPosition=Tuple!(int, "x", int, "y", int, "z").init, bool loadedInCreative=bool.init, int time=int.init, ubyte edition=ubyte.init, float rainLevel=float.init, float lightingLevel=float.init, bool commandsEnabled=bool.init, bool textureRequired=bool.init, string levelId=string.init, string worldName=string.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.seed = seed;
		this.dimension = dimension;
		this.generator = generator;
		this.worldGamemode = worldGamemode;
		this.difficulty = difficulty;
		this.spawnPosition = spawnPosition;
		this.loadedInCreative = loadedInCreative;
		this.time = time;
		this.edition = edition;
		this.rainLevel = rainLevel;
		this.lightingLevel = lightingLevel;
		this.commandsEnabled = commandsEnabled;
		this.textureRequired = textureRequired;
		this.levelId = levelId;
		this.worldName = worldName;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(yaw);
		writeLittleEndianFloat(pitch);
		writeBytes(varint.encode(seed));
		writeBytes(varint.encode(dimension));
		writeBytes(varint.encode(generator));
		writeBytes(varint.encode(worldGamemode));
		writeBytes(varint.encode(difficulty));
		writeBytes(varint.encode(spawnPosition.x)); writeBytes(varint.encode(spawnPosition.y)); writeBytes(varint.encode(spawnPosition.z));
		writeBigEndianBool(loadedInCreative);
		writeBytes(varint.encode(time));
		writeBigEndianUbyte(edition);
		writeLittleEndianFloat(rainLevel);
		writeLittleEndianFloat(lightingLevel);
		writeBigEndianBool(commandsEnabled);
		writeBigEndianBool(textureRequired);
		writeBytes(varuint.encode(cast(uint)levelId.length)); writeString(levelId);
		writeBytes(varuint.encode(cast(uint)worldName.length)); writeString(worldName);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		seed=varint.decode(_buffer, &_index);
		dimension=varint.decode(_buffer, &_index);
		generator=varint.decode(_buffer, &_index);
		worldGamemode=varint.decode(_buffer, &_index);
		difficulty=varint.decode(_buffer, &_index);
		spawnPosition.x=varint.decode(_buffer, &_index); spawnPosition.y=varint.decode(_buffer, &_index); spawnPosition.z=varint.decode(_buffer, &_index);
		loadedInCreative=readBigEndianBool();
		time=varint.decode(_buffer, &_index);
		edition=readBigEndianUbyte();
		rainLevel=readLittleEndianFloat();
		lightingLevel=readLittleEndianFloat();
		commandsEnabled=readBigEndianBool();
		textureRequired=readBigEndianBool();
		uint bvzxz=varuint.decode(_buffer, &_index); levelId=readString(bvzxz);
		uint d9bry1=varuint.decode(_buffer, &_index); worldName=readString(d9bry1);
	}

	public static pure nothrow @safe StartGame fromBuffer(bool readId=true)(ubyte[] buffer) {
		StartGame ret = new StartGame();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "StartGame(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", seed: " ~ std.conv.to!string(this.seed) ~ ", dimension: " ~ std.conv.to!string(this.dimension) ~ ", generator: " ~ std.conv.to!string(this.generator) ~ ", worldGamemode: " ~ std.conv.to!string(this.worldGamemode) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", spawnPosition: " ~ std.conv.to!string(this.spawnPosition) ~ ", loadedInCreative: " ~ std.conv.to!string(this.loadedInCreative) ~ ", time: " ~ std.conv.to!string(this.time) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", rainLevel: " ~ std.conv.to!string(this.rainLevel) ~ ", lightingLevel: " ~ std.conv.to!string(this.lightingLevel) ~ ", commandsEnabled: " ~ std.conv.to!string(this.commandsEnabled) ~ ", textureRequired: " ~ std.conv.to!string(this.textureRequired) ~ ", levelId: " ~ std.conv.to!string(this.levelId) ~ ", worldName: " ~ std.conv.to!string(this.worldName) ~ ")";
	}

}

/**
 * Spawns a player after adding it to the player's list using PlayerList. If PlayerList
 * is sent after this packet the player will appear to have the same skin as the player
 * who receives this packet.
 * Spawning a player to itself (using the same entity id given in the StartGame packet)
 * will crash the client's game.
 */
class AddPlayer : Buffer {

	public enum ubyte ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["uuid", "username", "entityId", "runtimeId", "position", "motion", "pitch", "headYaw", "yaw", "heldItem", "metadata"];

	/**
	 * Player's UUID, should match an UUID of a player in the list added through PlayerList.
	 */
	public UUID uuid;

	/**
	 * Player's username and text displayed on the nametag if something else is not specified
	 * in the metadata.
	 */
	public string username;
	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float headYaw;
	public float yaw;
	public sul.protocol.pocket101.types.Slot heldItem;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(UUID uuid, string username=string.init, long entityId=long.init, long runtimeId=long.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, sul.protocol.pocket101.types.Slot heldItem=sul.protocol.pocket101.types.Slot.init, Metadata metadata=Metadata.init) {
		this.uuid = uuid;
		this.username = username;
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.heldItem = heldItem;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(uuid.data);
		writeBytes(varuint.encode(cast(uint)username.length)); writeString(username);
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		heldItem.encode(bufferInstance);
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		uint dnc5bu=varuint.decode(_buffer, &_index); username=readString(dnc5bu);
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		heldItem.decode(bufferInstance);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe AddPlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPlayer ret = new AddPlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPlayer(uuid: " ~ std.conv.to!string(this.uuid) ~ ", username: " ~ std.conv.to!string(this.username) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", heldItem: " ~ std.conv.to!string(this.heldItem) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class AddEntity : Buffer {

	public enum ubyte ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "type", "position", "motion", "pitch", "yaw", "attributes", "metadata", "links"];

	public long entityId;
	public long runtimeId;
	public uint type;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float yaw;
	public sul.protocol.pocket101.types.Attribute[] attributes;
	public Metadata metadata;
	public sul.protocol.pocket101.types.Link[] links;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, uint type=uint.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float yaw=float.init, sul.protocol.pocket101.types.Attribute[] attributes=(sul.protocol.pocket101.types.Attribute[]).init, Metadata metadata=Metadata.init, sul.protocol.pocket101.types.Link[] links=(sul.protocol.pocket101.types.Link[]).init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.type = type;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.yaw = yaw;
		this.attributes = attributes;
		this.metadata = metadata;
		this.links = links;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeBytes(varuint.encode(type));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(yaw);
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yrcldrc;attributes){ yrcldrc.encode(bufferInstance); }
		metadata.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)links.length)); foreach(blam;links){ blam.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		type=varuint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yrcldrc;attributes){ yrcldrc.decode(bufferInstance); }
		metadata=Metadata.decode(bufferInstance);
		links.length=varuint.decode(_buffer, &_index); foreach(ref blam;links){ blam.decode(bufferInstance); }
	}

	public static pure nothrow @safe AddEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddEntity ret = new AddEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ", links: " ~ std.conv.to!string(this.links) ~ ")";
	}

}

/**
 * Despawns an entity or a player.
 */
class RemoveEntity : Buffer {

	public enum ubyte ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId"];

	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId) {
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RemoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveEntity ret = new RemoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

/**
 * Spawns a dropped item.
 */
class AddItemEntity : Buffer {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "item", "position", "motion"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket101.types.Slot item;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.item = item;
		this.position = position;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		item.encode(bufferInstance);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe AddItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddItemEntity ret = new AddItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddItemEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class AddHangingEntity : Buffer {

	public enum ubyte ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "unknown3"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket101.types.BlockPosition position;
	public int unknown3;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket101.types.BlockPosition position=sul.protocol.pocket101.types.BlockPosition.init, int unknown3=int.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.unknown3 = unknown3;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(unknown3));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		unknown3=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe AddHangingEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddHangingEntity ret = new AddHangingEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddHangingEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ")";
	}

}

/**
 * Plays the collection animation and despawns the entity that has been collected.
 */
class TakeItemEntity : Buffer {

	public enum ubyte ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["collected", "collector"];

	/**
	 * Collected entity, usually an item entity or an arrow, that will float toward the
	 * collector and despawn.
	 */
	public long collected;

	/**
	 * Entity that collects, usually a player or another entity with an inventory.
	 */
	public long collector;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long collected, long collector=long.init) {
		this.collected = collected;
		this.collector = collector;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(collected));
		writeBytes(varlong.encode(collector));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		collected=varlong.decode(_buffer, &_index);
		collector=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TakeItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		TakeItemEntity ret = new TakeItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TakeItemEntity(collected: " ~ std.conv.to!string(this.collected) ~ ", collector: " ~ std.conv.to!string(this.collector) ~ ")";
	}

}

class MoveEntity : Buffer {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public ubyte pitch;
	public ubyte headYaw;
	public ubyte yaw;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, ubyte pitch=ubyte.init, ubyte headYaw=ubyte.init, ubyte yaw=ubyte.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBigEndianUbyte(pitch);
		writeBigEndianUbyte(headYaw);
		writeBigEndianUbyte(yaw);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readBigEndianUbyte();
		headYaw=readBigEndianUbyte();
		yaw=readBigEndianUbyte();
	}

	public static pure nothrow @safe MoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		MoveEntity ret = new MoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ")";
	}

}

class MovePlayer : Buffer {

	public enum ubyte ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// animation
	public enum ubyte FULL = 0;
	public enum ubyte NONE = 1;
	public enum ubyte ROTATION = 2;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw", "animation", "onGround"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;
	public ubyte animation;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, ubyte animation=ubyte.init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.animation = animation;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		writeBigEndianUbyte(animation);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		animation=readBigEndianUbyte();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe MovePlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		MovePlayer ret = new MovePlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MovePlayer(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", animation: " ~ std.conv.to!string(this.animation) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class RiderJump : Buffer {

	public enum ubyte ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["rider"];

	public long rider;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long rider) {
		this.rider = rider;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(rider));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		rider=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RiderJump fromBuffer(bool readId=true)(ubyte[] buffer) {
		RiderJump ret = new RiderJump();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RiderJump(rider: " ~ std.conv.to!string(this.rider) ~ ")";
	}

}

/**
 * Instantly removes a block, either because the player is in creative mode or because
 * the target block's hardness is 0 or lower (after all enchantments are applied).
 */
class RemoveBlock : Buffer {

	public enum ubyte ID = 22;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["position"];

	public sul.protocol.pocket101.types.BlockPosition position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
	}

	public static pure nothrow @safe RemoveBlock fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveBlock ret = new RemoveBlock();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveBlock(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class UpdateBlock : Buffer {

	public enum ubyte ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags and meta
	public enum uint NEIGHBORS = 1;
	public enum uint NETWORK = 2;
	public enum uint NO_GRAPHIC = 4;
	public enum uint PRIORITY = 8;

	public enum string[] FIELDS = ["position", "block", "flagsAndMeta"];

	public sul.protocol.pocket101.types.BlockPosition position;
	public uint block;
	public uint flagsAndMeta;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition position, uint block=uint.init, uint flagsAndMeta=uint.init) {
		this.position = position;
		this.block = block;
		this.flagsAndMeta = flagsAndMeta;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		writeBytes(varuint.encode(block));
		writeBytes(varuint.encode(flagsAndMeta));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		block=varuint.decode(_buffer, &_index);
		flagsAndMeta=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe UpdateBlock fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateBlock ret = new UpdateBlock();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateBlock(position: " ~ std.conv.to!string(this.position) ~ ", block: " ~ std.conv.to!string(this.block) ~ ", flagsAndMeta: " ~ std.conv.to!string(this.flagsAndMeta) ~ ")";
	}

}

/**
 * Spawns a painting entity in the world.
 */
class AddPainting : Buffer {

	public enum ubyte ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "direction", "title"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket101.types.BlockPosition position;
	public int direction;
	public string title;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket101.types.BlockPosition position=sul.protocol.pocket101.types.BlockPosition.init, int direction=int.init, string title=string.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.direction = direction;
		this.title = title;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(direction));
		writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		direction=varint.decode(_buffer, &_index);
		uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
	}

	public static pure nothrow @safe AddPainting fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPainting ret = new AddPainting();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPainting(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ", title: " ~ std.conv.to!string(this.title) ~ ")";
	}

}

class Explode : Buffer {

	public enum ubyte ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "radius", "destroyedBlocks"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public sul.protocol.pocket101.types.BlockPosition[] destroyedBlocks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, float radius=float.init, sul.protocol.pocket101.types.BlockPosition[] destroyedBlocks=(sul.protocol.pocket101.types.BlockPosition[]).init) {
		this.position = position;
		this.radius = radius;
		this.destroyedBlocks = destroyedBlocks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(radius);
		writeBytes(varuint.encode(cast(uint)destroyedBlocks.length)); foreach(zvdjevqx;destroyedBlocks){ zvdjevqx.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		radius=readLittleEndianFloat();
		destroyedBlocks.length=varuint.decode(_buffer, &_index); foreach(ref zvdjevqx;destroyedBlocks){ zvdjevqx.decode(bufferInstance); }
	}

	public static pure nothrow @safe Explode fromBuffer(bool readId=true)(ubyte[] buffer) {
		Explode ret = new Explode();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Explode(position: " ~ std.conv.to!string(this.position) ~ ", radius: " ~ std.conv.to!string(this.radius) ~ ", destroyedBlocks: " ~ std.conv.to!string(this.destroyedBlocks) ~ ")";
	}

}

/**
 * Plays a sound at a certain position.
 */
class LevelSoundEvent : Buffer {

	public enum ubyte ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// sound
	public enum ubyte ITEM_USE_ON = 0;
	public enum ubyte HIT = 1;
	public enum ubyte STEP = 2;
	public enum ubyte JUMP = 3;
	public enum ubyte BREAK = 4;
	public enum ubyte PLACE = 5;
	public enum ubyte HEAVY_STEP = 6;
	public enum ubyte GALLOP = 7;
	public enum ubyte FALL = 8;
	public enum ubyte AMBIENT = 9;
	public enum ubyte AMBIENT_BABY = 10;
	public enum ubyte AMBIENT_IN_WATER = 11;
	public enum ubyte BREATHE = 12;
	public enum ubyte DEATH = 13;
	public enum ubyte DEATH_IN_WATER = 14;
	public enum ubyte DEATH_TO_ZOMBIE = 15;
	public enum ubyte HURT = 16;
	public enum ubyte HURT_IN_WATER = 17;
	public enum ubyte MAD = 18;
	public enum ubyte BOOST = 19;
	public enum ubyte BOW = 20;
	public enum ubyte SQUISH_BIG = 21;
	public enum ubyte SQUISH_SMALL = 22;
	public enum ubyte FALL_BIG = 23;
	public enum ubyte FALL_SMALL = 24;
	public enum ubyte SPLASH = 25;
	public enum ubyte FIZZ = 26;
	public enum ubyte FLAP = 27;
	public enum ubyte SWIM = 28;
	public enum ubyte DRINK = 29;
	public enum ubyte EAT = 30;
	public enum ubyte TAKEOFF = 31;
	public enum ubyte SHAKE = 32;
	public enum ubyte PLOP = 33;
	public enum ubyte LAND = 34;
	public enum ubyte SADDLE = 35;
	public enum ubyte ARMOR = 36;
	public enum ubyte ADD_CHEST = 37;
	public enum ubyte THROW = 38;
	public enum ubyte ATTACK = 39;
	public enum ubyte ATTACK_NODAMAGE = 40;
	public enum ubyte WARN = 41;
	public enum ubyte SHEAR = 42;
	public enum ubyte MILK = 43;
	public enum ubyte THUNDER = 44;
	public enum ubyte EXPLODE = 45;
	public enum ubyte FIRE = 46;
	public enum ubyte IGNITE = 47;
	public enum ubyte FUSE = 48;
	public enum ubyte STARE = 49;
	public enum ubyte SPAWN = 50;
	public enum ubyte SHOOT = 51;
	public enum ubyte BREAK_BLOCK = 52;
	public enum ubyte REMEDY = 53;
	public enum ubyte UNFECT = 54;
	public enum ubyte LEVELUP = 55;
	public enum ubyte BOW_HIT = 56;
	public enum ubyte BULLET_HIT = 57;
	public enum ubyte EXTINGUISH_FIRE = 58;
	public enum ubyte ITEM_FIZZ = 59;
	public enum ubyte CHEST_OPEN = 60;
	public enum ubyte CHEST_CLOSED = 61;
	public enum ubyte POWER_ON = 62;
	public enum ubyte POWER_OFF = 63;
	public enum ubyte ATTACH = 64;
	public enum ubyte DETACH = 65;
	public enum ubyte DENY = 66;
	public enum ubyte TRIPOD = 67;
	public enum ubyte POP = 68;
	public enum ubyte DROP_SLOT = 69;
	public enum ubyte NOTE = 70;
	public enum ubyte THORNS = 71;
	public enum ubyte PISTON_IN = 72;
	public enum ubyte PISTON_OUT = 73;
	public enum ubyte PORTAL = 74;
	public enum ubyte WATER = 75;
	public enum ubyte LAVA_POP = 76;
	public enum ubyte LAVA = 77;
	public enum ubyte BURP = 78;
	public enum ubyte BUCKET_FILL_WATER = 79;
	public enum ubyte BUCKET_FILL_LAVA = 80;
	public enum ubyte BUCKET_EMPTY_WATER = 81;
	public enum ubyte BUCKET_EMPTY_LAVA = 82;
	public enum ubyte GUARDIAN_FLOP = 83;
	public enum ubyte ELDERGUARDIAN_CURSE = 84;
	public enum ubyte MOB_WARNING = 85;
	public enum ubyte MOB_WARNING_BABY = 86;
	public enum ubyte TELEPORT = 87;
	public enum ubyte SHULKER_OPEN = 88;
	public enum ubyte SHULKER_CLOSE = 89;
	public enum ubyte DEFAULT = 90;
	public enum ubyte UNDEFINED = 91;

	public enum string[] FIELDS = ["sound", "position", "volume", "pitch", "unknown4"];

	public ubyte sound;

	/**
	 * Position where the sound was generated. The closer to the player the more intense
	 * will be on the client.
	 */
	public Tuple!(float, "x", float, "y", float, "z") position;
	public uint volume;
	public int pitch;
	public bool unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte sound, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, uint volume=uint.init, int pitch=int.init, bool unknown4=bool.init) {
		this.sound = sound;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(sound);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varuint.encode(volume));
		writeBytes(varint.encode(pitch));
		writeBigEndianBool(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		sound=readBigEndianUbyte();
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		volume=varuint.decode(_buffer, &_index);
		pitch=varint.decode(_buffer, &_index);
		unknown4=readBigEndianBool();
	}

	public static pure nothrow @safe LevelSoundEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelSoundEvent ret = new LevelSoundEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelSoundEvent(sound: " ~ std.conv.to!string(this.sound) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class LevelEvent : Buffer {

	public enum ubyte ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum int START_RAIN = 3001;
	public enum int START_THUNDER = 3002;
	public enum int STOP_RAIN = 3003;
	public enum int STOP_THUNDER = 3004;
	public enum int SET_DATA = 4000;
	public enum int PLAYERS_SLEEPING = 9800;
	public enum int BUBBLE = 16385;
	public enum int CRITICAL = 16386;
	public enum int BLOCK_FORCE_FIELD = 16387;
	public enum int SMOKE = 16388;
	public enum int EXPLODE = 16389;
	public enum int EVAPORATION = 16390;
	public enum int FLAME = 16391;
	public enum int LAVA = 16392;
	public enum int LARGE_SMOKE = 16393;
	public enum int REDSTONE = 16394;
	public enum int RISING_RED_DUST = 16395;
	public enum int ITEM_BREAK = 16396;
	public enum int SNOWBALL_POOF = 16397;
	public enum int HUGE_EXPLODE = 16398;
	public enum int HUGE_EXPLODE_SEED = 16399;
	public enum int MOB_FLAME = 16400;
	public enum int HEART = 16401;
	public enum int TERRAIN = 16402;
	public enum int TOWN_AURA = 16403;
	public enum int PORTAL = 16404;
	public enum int WATER_SPLASH = 16405;
	public enum int WATER_WAKE = 16406;
	public enum int DRIP_WATER = 16407;
	public enum int DRIP_LAVA = 16408;
	public enum int FALLING_DUST = 16409;
	public enum int MOB_SPELL = 16410;
	public enum int MOB_SPELL_AMBIENT = 16411;
	public enum int MOB_SPELL_INSTANTANEOUS = 16412;
	public enum int INK = 16413;
	public enum int SLIME = 16414;
	public enum int RAIN_SPLASH = 16415;
	public enum int VILLAGER_ANGRY = 16416;
	public enum int VILLAGER_HAPPY = 16417;
	public enum int ENCHANTMENT_TABLE = 16418;
	public enum int TRACKING_EMITTER = 16419;
	public enum int NOTE = 16420;
	public enum int WITCH_SPELL = 16421;
	public enum int CARROT = 16422;
	public enum int END_ROD = 16424;
	public enum int DRAGON_BREATH = 16425;
	public enum int SHOOT = 2000;
	public enum int DESTROY = 2001;

	public enum string[] FIELDS = ["eventId", "position", "data"];

	public int eventId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int eventId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, int data=int.init) {
		this.eventId = eventId;
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(eventId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(data));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		eventId=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		data=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe LevelEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelEvent ret = new LevelEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelEvent(eventId: " ~ std.conv.to!string(this.eventId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class BlockEvent : Buffer {

	public enum ubyte ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data"];

	public sul.protocol.pocket101.types.BlockPosition position;
	public int[2] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition position, int[2] data=(int[2]).init) {
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		foreach(zfy;data){ writeBytes(varint.encode(zfy)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		foreach(ref zfy;data){ zfy=varint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe BlockEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEvent ret = new BlockEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEvent(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class EntityEvent : Buffer {

	public enum ubyte ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// event id
	public enum ubyte HURT_ANIMATION = 2;
	public enum ubyte DEATH_ANIMATION = 3;
	public enum ubyte TAME_FAIL = 6;
	public enum ubyte TAME_SUCCESS = 7;
	public enum ubyte SHAKE_WET = 8;
	public enum ubyte USE_ITEM = 9;
	public enum ubyte EAT_GRASS_ANIMATION = 10;
	public enum ubyte FISH_HOOK_BUBBLES = 11;
	public enum ubyte FISH_HOOK_POSITION = 12;
	public enum ubyte FISH_HOOK_HOOK = 13;
	public enum ubyte FISH_HOOK_TEASE = 14;
	public enum ubyte SQUID_INK_CLOUD = 15;
	public enum ubyte AMBIENT_SOUND = 16;
	public enum ubyte RESPAWN = 17;

	public enum string[] FIELDS = ["entityId", "eventId", "unknown2"];

	public long entityId;
	public ubyte eventId;
	public int unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int unknown2=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBigEndianUbyte(eventId);
		writeBytes(varint.encode(unknown2));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readBigEndianUbyte();
		unknown2=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe EntityEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityEvent ret = new EntityEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class MobEffect : Buffer {

	public enum ubyte ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum ubyte ADD = 1;
	public enum ubyte MODIFY = 2;
	public enum ubyte REMOVE = 3;

	public enum string[] FIELDS = ["entityId", "eventId", "effect", "amplifier", "particles", "duration"];

	public long entityId;
	public ubyte eventId;
	public int effect;
	public int amplifier;
	public bool particles;
	public int duration;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int effect=int.init, int amplifier=int.init, bool particles=bool.init, int duration=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.effect = effect;
		this.amplifier = amplifier;
		this.particles = particles;
		this.duration = duration;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBigEndianUbyte(eventId);
		writeBytes(varint.encode(effect));
		writeBytes(varint.encode(amplifier));
		writeBigEndianBool(particles);
		writeBytes(varint.encode(duration));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readBigEndianUbyte();
		effect=varint.decode(_buffer, &_index);
		amplifier=varint.decode(_buffer, &_index);
		particles=readBigEndianBool();
		duration=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MobEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEffect ret = new MobEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", effect: " ~ std.conv.to!string(this.effect) ~ ", amplifier: " ~ std.conv.to!string(this.amplifier) ~ ", particles: " ~ std.conv.to!string(this.particles) ~ ", duration: " ~ std.conv.to!string(this.duration) ~ ")";
	}

}

/**
 * Updates an entity's attributes. This packet should be used when a value must be
 * modified but it cannot be done using another packet (for example controlling the
 * player's experience and level).
 */
class UpdateAttributes : Buffer {

	public enum ubyte ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "attributes"];

	public long entityId;
	public sul.protocol.pocket101.types.Attribute[] attributes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket101.types.Attribute[] attributes=(sul.protocol.pocket101.types.Attribute[]).init) {
		this.entityId = entityId;
		this.attributes = attributes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yrcldrc;attributes){ yrcldrc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yrcldrc;attributes){ yrcldrc.decode(bufferInstance); }
	}

	public static pure nothrow @safe UpdateAttributes fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateAttributes ret = new UpdateAttributes();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateAttributes(entityId: " ~ std.conv.to!string(this.entityId) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ")";
	}

}

/**
 * Sent when the client puts an item in its hotbar or selects a new hotbar slot.
 */
class MobEquipment : Buffer {

	public enum ubyte ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "item", "inventorySlot", "hotbarSlot", "unknown4"];

	public long entityId;
	public sul.protocol.pocket101.types.Slot item;

	/**
	 * Slot of the inventory where the item is. The hotbat slots (0-8) are not counted.
	 * 255 means that a generic empty slot has been selected.
	 */
	public ubyte inventorySlot;

	/**
	 * Slot of the hotbar where the item is being moved.
	 */
	public ubyte hotbarSlot;
	public ubyte unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init, ubyte inventorySlot=ubyte.init, ubyte hotbarSlot=ubyte.init, ubyte unknown4=ubyte.init) {
		this.entityId = entityId;
		this.item = item;
		this.inventorySlot = inventorySlot;
		this.hotbarSlot = hotbarSlot;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		item.encode(bufferInstance);
		writeBigEndianUbyte(inventorySlot);
		writeBigEndianUbyte(hotbarSlot);
		writeBigEndianUbyte(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		inventorySlot=readBigEndianUbyte();
		hotbarSlot=readBigEndianUbyte();
		unknown4=readBigEndianUbyte();
	}

	public static pure nothrow @safe MobEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEquipment ret = new MobEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", inventorySlot: " ~ std.conv.to!string(this.inventorySlot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class MobArmorEquipment : Buffer {

	public enum ubyte ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "armor"];

	public long entityId;
	public sul.protocol.pocket101.types.Slot[4] armor;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket101.types.Slot[4] armor=(sul.protocol.pocket101.types.Slot[4]).init) {
		this.entityId = entityId;
		this.armor = armor;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		foreach(yjbi;armor){ yjbi.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		foreach(ref yjbi;armor){ yjbi.decode(bufferInstance); }
	}

	public static pure nothrow @safe MobArmorEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobArmorEquipment ret = new MobArmorEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobArmorEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", armor: " ~ std.conv.to!string(this.armor) ~ ")";
	}

}

class Interact : Buffer {

	public enum ubyte ID = 34;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte ATTACK = 1;
	public enum ubyte INTERACT = 2;
	public enum ubyte LEAVE_VEHICLE = 3;
	public enum ubyte HOVER = 4;

	public enum string[] FIELDS = ["action", "target"];

	public ubyte action;
	public long target;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, long target=long.init) {
		this.action = action;
		this.target = target;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		writeBytes(varlong.encode(target));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		target=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Interact fromBuffer(bool readId=true)(ubyte[] buffer) {
		Interact ret = new Interact();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Interact(action: " ~ std.conv.to!string(this.action) ~ ", target: " ~ std.conv.to!string(this.target) ~ ")";
	}

}

class UseItem : Buffer {

	public enum ubyte ID = 35;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["blockPosition", "hotbarSlot", "face", "facePosition", "position", "slot", "item"];

	public sul.protocol.pocket101.types.BlockPosition blockPosition;
	public uint hotbarSlot;
	public int face;
	public Tuple!(float, "x", float, "y", float, "z") facePosition;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int slot;
	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition blockPosition, uint hotbarSlot=uint.init, int face=int.init, Tuple!(float, "x", float, "y", float, "z") facePosition=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, int slot=int.init, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init) {
		this.blockPosition = blockPosition;
		this.hotbarSlot = hotbarSlot;
		this.face = face;
		this.facePosition = facePosition;
		this.position = position;
		this.slot = slot;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		blockPosition.encode(bufferInstance);
		writeBytes(varuint.encode(hotbarSlot));
		writeBytes(varint.encode(face));
		writeLittleEndianFloat(facePosition.x); writeLittleEndianFloat(facePosition.y); writeLittleEndianFloat(facePosition.z);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(slot));
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		blockPosition.decode(bufferInstance);
		hotbarSlot=varuint.decode(_buffer, &_index);
		face=varint.decode(_buffer, &_index);
		facePosition.x=readLittleEndianFloat(); facePosition.y=readLittleEndianFloat(); facePosition.z=readLittleEndianFloat();
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		slot=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe UseItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		UseItem ret = new UseItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UseItem(blockPosition: " ~ std.conv.to!string(this.blockPosition) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", face: " ~ std.conv.to!string(this.face) ~ ", facePosition: " ~ std.conv.to!string(this.facePosition) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class PlayerAction : Buffer {

	public enum ubyte ID = 36;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum int START_BREAK = 0;
	public enum int ABORT_BREAK = 1;
	public enum int STOP_BREAK = 2;
	public enum int RELEASE_ITEM = 5;
	public enum int STOP_SLEEPING = 6;
	public enum int RESPAWN = 7;
	public enum int JUMP = 8;
	public enum int START_SPRINT = 9;
	public enum int STOP_SPRINT = 10;
	public enum int START_SNEAK = 11;
	public enum int STOP_SNEAK = 12;
	public enum int START_GLIDING = 15;
	public enum int STOP_GLIDING = 16;

	public enum string[] FIELDS = ["entityId", "action", "position", "face"];

	public long entityId;
	public int action;
	public sul.protocol.pocket101.types.BlockPosition position;
	public int face;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int action=int.init, sul.protocol.pocket101.types.BlockPosition position=sul.protocol.pocket101.types.BlockPosition.init, int face=int.init) {
		this.entityId = entityId;
		this.action = action;
		this.position = position;
		this.face = face;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(action));
		position.encode(bufferInstance);
		writeBytes(varint.encode(face));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		action=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		face=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe PlayerAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerAction ret = new PlayerAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerAction(entityId: " ~ std.conv.to!string(this.entityId) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", face: " ~ std.conv.to!string(this.face) ~ ")";
	}

}

/**
 * Sent by the player when it falls from a distance that causes damage, that can be
 * influenced by its armour and its effects.
 */
class PlayerFall : Buffer {

	public enum ubyte ID = 37;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["distance"];

	/**
	 * Number of blocks the player has been in free falling before hitting the ground.
	 */
	public float distance;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float distance) {
		this.distance = distance;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(distance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		distance=readLittleEndianFloat();
	}

	public static pure nothrow @safe PlayerFall fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerFall ret = new PlayerFall();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerFall(distance: " ~ std.conv.to!string(this.distance) ~ ")";
	}

}

class HurtArmor : Buffer {

	public enum ubyte ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0"];

	public int unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(unknown0));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		unknown0=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe HurtArmor fromBuffer(bool readId=true)(ubyte[] buffer) {
		HurtArmor ret = new HurtArmor();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "HurtArmor(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

/**
 * Updates an entity's metadata.
 */
class SetEntityData : Buffer {

	public enum ubyte ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "metadata"];

	public long entityId;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe SetEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityData ret = new SetEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityData(entityId: " ~ std.conv.to!string(this.entityId) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

/**
 * Updates an entity's motion.
 */
class SetEntityMotion : Buffer {

	public enum ubyte ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "motion"];

	/**
	 * Entity which motion is updated. If the entity id is the player's, its motion is
	 * updated client-side and the player will send movement packets to the server (meaning
	 * that the server has no physical calculations to do). If not an animation will be
	 * done client-side but the server will have to calculate the new position applying
	 * the item's movement rules.
	 */
	public long entityId;

	/**
	 * New motion for the entity that will influence its movement.
	 */
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.entityId = entityId;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe SetEntityMotion fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityMotion ret = new SetEntityMotion();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityMotion(entityId: " ~ std.conv.to!string(this.entityId) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class SetEntityLink : Buffer {

	public enum ubyte ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte RIDE = 1;
	public enum ubyte REMOVE = 2;

	public enum string[] FIELDS = ["from", "to", "action"];

	public long from;
	public long to;
	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long from, long to=long.init, ubyte action=ubyte.init) {
		this.from = from;
		this.to = to;
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(from));
		writeBytes(varlong.encode(to));
		writeBigEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		from=varlong.decode(_buffer, &_index);
		to=varlong.decode(_buffer, &_index);
		action=readBigEndianUbyte();
	}

	public static pure nothrow @safe SetEntityLink fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityLink ret = new SetEntityLink();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityLink(from: " ~ std.conv.to!string(this.from) ~ ", to: " ~ std.conv.to!string(this.to) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
	}

}

class SetHealth : Buffer {

	public enum ubyte ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["health"];

	public int health;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int health) {
		this.health = health;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(health));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		health=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetHealth fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetHealth ret = new SetHealth();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetHealth(health: " ~ std.conv.to!string(this.health) ~ ")";
	}

}

class SetSpawnPosition : Buffer {

	public enum ubyte ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "position", "unknown2"];

	public int unknown0;
	public sul.protocol.pocket101.types.BlockPosition position;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int unknown0, sul.protocol.pocket101.types.BlockPosition position=sul.protocol.pocket101.types.BlockPosition.init, bool unknown2=bool.init) {
		this.unknown0 = unknown0;
		this.position = position;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(unknown0));
		position.encode(bufferInstance);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		unknown0=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe SetSpawnPosition fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetSpawnPosition ret = new SetSpawnPosition();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetSpawnPosition(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class Animate : Buffer {

	public enum ubyte ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// action
	public enum int BREAKING = 1;
	public enum int WAKE_UP = 3;

	public enum string[] FIELDS = ["action", "entityId"];

	public int action;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, long entityId=long.init) {
		this.action = action;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(action));
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=varint.decode(_buffer, &_index);
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Animate fromBuffer(bool readId=true)(ubyte[] buffer) {
		Animate ret = new Animate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Animate(action: " ~ std.conv.to!string(this.action) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class Respawn : Buffer {

	public enum ubyte ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public Tuple!(float, "x", float, "y", float, "z") position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe Respawn fromBuffer(bool readId=true)(ubyte[] buffer) {
		Respawn ret = new Respawn();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Respawn(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class DropItem : Buffer {

	public enum ubyte ID = 46;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte DROP = 0;

	public enum string[] FIELDS = ["action", "item"];

	public ubyte action;
	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init) {
		this.action = action;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe DropItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		DropItem ret = new DropItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "DropItem(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class InventoryAction : Buffer {

	public enum ubyte ID = 47;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["action", "item"];

	public int action;
	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init) {
		this.action = action;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(action));
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe InventoryAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		InventoryAction ret = new InventoryAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InventoryAction(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class ContainerOpen : Buffer {

	public enum ubyte ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "type", "slotCount", "position", "entityId"];

	public ubyte window;
	public ubyte type;
	public int slotCount;
	public sul.protocol.pocket101.types.BlockPosition position;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ubyte type=ubyte.init, int slotCount=int.init, sul.protocol.pocket101.types.BlockPosition position=sul.protocol.pocket101.types.BlockPosition.init, long entityId=long.init) {
		this.window = window;
		this.type = type;
		this.slotCount = slotCount;
		this.position = position;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBigEndianUbyte(type);
		writeBytes(varint.encode(slotCount));
		position.encode(bufferInstance);
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		type=readBigEndianUbyte();
		slotCount=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerOpen fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerOpen ret = new ContainerOpen();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerOpen(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", slotCount: " ~ std.conv.to!string(this.slotCount) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class ContainerClose : Buffer {

	public enum ubyte ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window"];

	public ubyte window;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window) {
		this.window = window;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
	}

	public static pure nothrow @safe ContainerClose fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerClose ret = new ContainerClose();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerClose(window: " ~ std.conv.to!string(this.window) ~ ")";
	}

}

class ContainerSetSlot : Buffer {

	public enum ubyte ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window", "slot", "hotbarSlot", "item", "unknown4"];

	public ubyte window;
	public int slot;
	public int hotbarSlot;
	public sul.protocol.pocket101.types.Slot item;
	public ubyte unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int slot=int.init, int hotbarSlot=int.init, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init, ubyte unknown4=ubyte.init) {
		this.window = window;
		this.slot = slot;
		this.hotbarSlot = hotbarSlot;
		this.item = item;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(slot));
		writeBytes(varint.encode(hotbarSlot));
		item.encode(bufferInstance);
		writeBigEndianUbyte(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		slot=varint.decode(_buffer, &_index);
		hotbarSlot=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
		unknown4=readBigEndianUbyte();
	}

	public static pure nothrow @safe ContainerSetSlot fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetSlot ret = new ContainerSetSlot();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetSlot(window: " ~ std.conv.to!string(this.window) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class ContainerSetData : Buffer {

	public enum ubyte ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "property", "value"];

	public ubyte window;
	public int property;
	public int value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int property=int.init, int value=int.init) {
		this.window = window;
		this.property = property;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(property));
		writeBytes(varint.encode(value));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		property=varint.decode(_buffer, &_index);
		value=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerSetData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetData ret = new ContainerSetData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetData(window: " ~ std.conv.to!string(this.window) ~ ", property: " ~ std.conv.to!string(this.property) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class ContainerSetContent : Buffer {

	public enum ubyte ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "slots", "hotbar"];

	public ubyte window;
	public sul.protocol.pocket101.types.Slot[] slots;
	public int[] hotbar;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, sul.protocol.pocket101.types.Slot[] slots=(sul.protocol.pocket101.types.Slot[]).init, int[] hotbar=(int[]).init) {
		this.window = window;
		this.slots = slots;
		this.hotbar = hotbar;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varuint.encode(cast(uint)slots.length)); foreach(cxdm;slots){ cxdm.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)hotbar.length)); foreach(a9yf;hotbar){ writeBytes(varint.encode(a9yf)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		slots.length=varuint.decode(_buffer, &_index); foreach(ref cxdm;slots){ cxdm.decode(bufferInstance); }
		hotbar.length=varuint.decode(_buffer, &_index); foreach(ref a9yf;hotbar){ a9yf=varint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe ContainerSetContent fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetContent ret = new ContainerSetContent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetContent(window: " ~ std.conv.to!string(this.window) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ", hotbar: " ~ std.conv.to!string(this.hotbar) ~ ")";
	}

}

class CraftingData : Buffer {

	public enum ubyte ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["recipes"];

	public sul.protocol.pocket101.types.Recipe[] recipes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.Recipe[] recipes) {
		this.recipes = recipes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)recipes.length)); foreach(cvabc;recipes){ cvabc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		recipes.length=varuint.decode(_buffer, &_index); foreach(ref cvabc;recipes){ cvabc.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingData fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingData ret = new CraftingData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingData(recipes: " ~ std.conv.to!string(this.recipes) ~ ")";
	}

}

class CraftingEvent : Buffer {

	public enum ubyte ID = 54;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window", "type", "uuid", "input", "output"];

	public ubyte window;
	public int type;
	public UUID uuid;
	public sul.protocol.pocket101.types.Slot[] input;
	public sul.protocol.pocket101.types.Slot[] output;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int type=int.init, UUID uuid=UUID.init, sul.protocol.pocket101.types.Slot[] input=(sul.protocol.pocket101.types.Slot[]).init, sul.protocol.pocket101.types.Slot[] output=(sul.protocol.pocket101.types.Slot[]).init) {
		this.window = window;
		this.type = type;
		this.uuid = uuid;
		this.input = input;
		this.output = output;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(type));
		writeBytes(uuid.data);
		writeBytes(varuint.encode(cast(uint)input.length)); foreach(a5dq;input){ a5dq.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)output.length)); foreach(bvcv;output){ bvcv.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		type=varint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		input.length=varuint.decode(_buffer, &_index); foreach(ref a5dq;input){ a5dq.decode(bufferInstance); }
		output.length=varuint.decode(_buffer, &_index); foreach(ref bvcv;output){ bvcv.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingEvent ret = new CraftingEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingEvent(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
	}

}

/**
 * Updates the world's settings and client's permissions.
 */
class AdventureSettings : Buffer {

	public enum ubyte ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// flags
	public enum uint IMMUTABLE_WORLD = 1;
	public enum uint PVP_DISABLED = 2;
	public enum uint PVM_DISABLED = 4;
	public enum uint MVP_DISBALED = 8;
	public enum uint EVP_DISABLED = 16;
	public enum uint AUTO_JUMP = 32;
	public enum uint ALLOW_FLIGHT = 64;
	public enum uint NO_CLIP = 128;
	public enum uint FLYING = 512;

	// permissions
	public enum uint USER = 0;
	public enum uint OPERATOR = 1;
	public enum uint HOST = 2;
	public enum uint AUTOMATION = 3;
	public enum uint ADMIN = 4;

	public enum string[] FIELDS = ["flags", "permissions"];

	public uint flags;
	public uint permissions;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint flags, uint permissions=uint.init) {
		this.flags = flags;
		this.permissions = permissions;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(flags));
		writeBytes(varuint.encode(permissions));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		flags=varuint.decode(_buffer, &_index);
		permissions=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe AdventureSettings fromBuffer(bool readId=true)(ubyte[] buffer) {
		AdventureSettings ret = new AdventureSettings();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AdventureSettings(flags: " ~ std.conv.to!string(this.flags) ~ ", permissions: " ~ std.conv.to!string(this.permissions) ~ ")";
	}

}

/**
 * Sets a block entity's nbt tag, block's additional data that cannot be indicated
 * in the block's meta. More informations about block entities and their tag format
 * can be found on Minecraft Wiki.
 */
class BlockEntityData : Buffer {

	public enum ubyte ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "nbt"];

	/**
	 * Position of the block that will be associated with tag.
	 */
	public sul.protocol.pocket101.types.BlockPosition position;

	/**
	 * Named binary tag of the block. The format varies from the classic format of Minecraft:
	 * Pocket Edition (which is like Minecraft's but little endian) introducing the use
	 * of varints for some types:
	 * + The tag `Int` is encoded as a signed varint instead of a simple signed 32-bits
	 * integer
	 * + The length of the `ByteArray` and the `IntArray` is encoded as an unsigned varint
	 * instead of a 32-bits integer
	 * + The length of the `String` tag and the named tag's name length are encoded as
	 * an unisgned varint instead of a 16-bits integer
	 */
	public ubyte[] nbt;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition position, ubyte[] nbt=(ubyte[]).init) {
		this.position = position;
		this.nbt = nbt;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		writeBytes(nbt);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		nbt=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe BlockEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEntityData ret = new BlockEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEntityData(position: " ~ std.conv.to!string(this.position) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
	}

}

class PlayerInput : Buffer {

	public enum ubyte ID = 57;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["motion", "flags", "unknown2"];

	public Tuple!(float, "x", float, "y", float, "z") motion;
	public ubyte flags;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") motion, ubyte flags=ubyte.init, bool unknown2=bool.init) {
		this.motion = motion;
		this.flags = flags;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeBigEndianUbyte(flags);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		flags=readBigEndianUbyte();
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe PlayerInput fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerInput ret = new PlayerInput();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerInput(motion: " ~ std.conv.to!string(this.motion) ~ ", flags: " ~ std.conv.to!string(this.flags) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

/**
 * Sends a 16x16 chunk to the client with its blocks, lights and block entities (tiles).
 */
class FullChunkData : Buffer {

	public enum ubyte ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data"];

	/**
	 * Coordinates of the chunk.
	 */
	public Tuple!(int, "x", int, "z") position;
	public sul.protocol.pocket101.types.ChunkData data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") position, sul.protocol.pocket101.types.ChunkData data=sul.protocol.pocket101.types.ChunkData.init) {
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(position.x)); writeBytes(varint.encode(position.z));
		data.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=varint.decode(_buffer, &_index); position.z=varint.decode(_buffer, &_index);
		data.decode(bufferInstance);
	}

	public static pure nothrow @safe FullChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		FullChunkData ret = new FullChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "FullChunkData(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

/**
 * Indicates whether the cheats are enabled. If not the client cannot send commands.
 */
class SetCommandsEnabled : Buffer {

	public enum ubyte ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["enabled"];

	public bool enabled;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool enabled) {
		this.enabled = enabled;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(enabled);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		enabled=readBigEndianBool();
	}

	public static pure nothrow @safe SetCommandsEnabled fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetCommandsEnabled ret = new SetCommandsEnabled();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetCommandsEnabled(enabled: " ~ std.conv.to!string(this.enabled) ~ ")";
	}

}

/**
 * Sets the world's difficulty.
 */
class SetDifficulty : Buffer {

	public enum ubyte ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum uint PEACEFUL = 0;
	public enum uint EASY = 1;
	public enum uint NORMAL = 2;
	public enum uint HARD = 3;

	public enum string[] FIELDS = ["difficulty"];

	public uint difficulty;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint difficulty) {
		this.difficulty = difficulty;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(difficulty));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		difficulty=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetDifficulty fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetDifficulty ret = new SetDifficulty();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetDifficulty(difficulty: " ~ std.conv.to!string(this.difficulty) ~ ")";
	}

}

class ChangeDimension : Buffer {

	public enum ubyte ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	public enum string[] FIELDS = ["dimension", "position", "unknown2"];

	public int dimension;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int dimension, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, bool unknown2=bool.init) {
		this.dimension = dimension;
		this.position = position;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(dimension));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		dimension=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe ChangeDimension fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChangeDimension ret = new ChangeDimension();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChangeDimension(dimension: " ~ std.conv.to!string(this.dimension) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

/**
 * Sets the player's gamemode. This packet is sent by the player when it has the operator
 * status (set in AdventureSettings.permissions) and it changes the gamemode in the
 * settings screen.
 */
class SetPlayerGameType : Buffer {

	public enum ubyte ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	public enum string[] FIELDS = ["gamemode"];

	public int gamemode;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int gamemode) {
		this.gamemode = gamemode;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(gamemode));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		gamemode=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetPlayerGameType fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetPlayerGameType ret = new SetPlayerGameType();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetPlayerGameType(gamemode: " ~ std.conv.to!string(this.gamemode) ~ ")";
	}

}

/**
 * Adds or removes a player from the player's list displayed in the pause menu. This
 * packet should be sent before spawning a player with AddPlayer, otherwise the skin
 * is not applied.
 */
class PlayerList : Buffer {

	public enum ubyte ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
	}

	public static pure nothrow @safe PlayerList fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerList ret = new PlayerList();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerList(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(Add, Remove);

	public class Add {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.pocket101.types.PlayerList[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.PlayerList[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerList.Add(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class Remove {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["players"];

		public UUID[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(UUID[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ writeBytes(cxevc.data); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ if(_buffer.length>=_index+16){ ubyte[16] yhdm=_buffer[_index.._index+16].dup; _index+=16; cxevc=UUID(yhdm); } }
		}

		public override string toString() {
			return "PlayerList.Remove(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

}

class TelemetryEvent : Buffer {

	public enum ubyte ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public int eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int eventId=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TelemetryEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		TelemetryEvent ret = new TelemetryEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TelemetryEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class SpawnExperienceOrb : Buffer {

	public enum ubyte ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "count"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public int count;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, int count=int.init) {
		this.position = position;
		this.count = count;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(count));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		count=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SpawnExperienceOrb fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnExperienceOrb ret = new SpawnExperienceOrb();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnExperienceOrb(position: " ~ std.conv.to!string(this.position) ~ ", count: " ~ std.conv.to!string(this.count) ~ ")";
	}

}

class ClientboundMapItemData : Buffer {

	public enum ubyte ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// update
	public enum uint TEXTURE = 2;
	public enum uint DECORATIONS = 4;
	public enum uint ENTITIES = 8;

	public enum string[] FIELDS = ["mapId", "update", "scale", "size", "offset", "data", "decorations"];

	public long mapId;
	public uint update;
	public ubyte scale;

	/**
	 * Colums and rows.
	 */
	public Tuple!(int, "x", int, "z") size;
	public Tuple!(int, "x", int, "z") offset;

	/**
	 * ARGB colours encoded as unsigned varints.
	 */
	public ubyte[] data;
	public sul.protocol.pocket101.types.Decoration[] decorations;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId, uint update=uint.init, ubyte scale=ubyte.init, Tuple!(int, "x", int, "z") size=Tuple!(int, "x", int, "z").init, Tuple!(int, "x", int, "z") offset=Tuple!(int, "x", int, "z").init, ubyte[] data=(ubyte[]).init, sul.protocol.pocket101.types.Decoration[] decorations=(sul.protocol.pocket101.types.Decoration[]).init) {
		this.mapId = mapId;
		this.update = update;
		this.scale = scale;
		this.size = size;
		this.offset = offset;
		this.data = data;
		this.decorations = decorations;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(mapId));
		writeBytes(varuint.encode(update));
		if(update==2||update==4){ writeBigEndianUbyte(scale); }
		if(update==2){ writeBytes(varint.encode(size.x)); writeBytes(varint.encode(size.z)); }
		if(update==2){ writeBytes(varint.encode(offset.x)); writeBytes(varint.encode(offset.z)); }
		if(update==2){ writeBytes(data); }
		if(update==4){ writeBytes(varuint.encode(cast(uint)decorations.length)); foreach(zvbjdlbm;decorations){ zvbjdlbm.encode(bufferInstance); } }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mapId=varlong.decode(_buffer, &_index);
		update=varuint.decode(_buffer, &_index);
		if(update==2||update==4){ scale=readBigEndianUbyte(); }
		if(update==2){ size.x=varint.decode(_buffer, &_index); size.z=varint.decode(_buffer, &_index); }
		if(update==2){ offset.x=varint.decode(_buffer, &_index); offset.z=varint.decode(_buffer, &_index); }
		if(update==2){ data=_buffer[_index..$].dup; _index=_buffer.length; }
		if(update==4){ decorations.length=varuint.decode(_buffer, &_index); foreach(ref zvbjdlbm;decorations){ zvbjdlbm.decode(bufferInstance); } }
	}

	public static pure nothrow @safe ClientboundMapItemData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientboundMapItemData ret = new ClientboundMapItemData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientboundMapItemData(mapId: " ~ std.conv.to!string(this.mapId) ~ ", update: " ~ std.conv.to!string(this.update) ~ ", scale: " ~ std.conv.to!string(this.scale) ~ ", size: " ~ std.conv.to!string(this.size) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", decorations: " ~ std.conv.to!string(this.decorations) ~ ")";
	}

}

class MapInfoRequest : Buffer {

	public enum ubyte ID = 67;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["mapId"];

	public long mapId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId) {
		this.mapId = mapId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(mapId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mapId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MapInfoRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		MapInfoRequest ret = new MapInfoRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MapInfoRequest(mapId: " ~ std.conv.to!string(this.mapId) ~ ")";
	}

}

/**
 * Packet sent by the client when its view-distance is updated and when it spawns for
 * the first time a world. A ChunkRadiusUpdate should always be sent in response, otherwise
 * the player will not update its view distance.
 */
class RequestChunkRadius : Buffer {

	public enum ubyte ID = 68;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["radius"];

	/**
	 * Number of chunks before the fog starts to appear in the client's view. The value
	 * of this field is usually between 8 and 14.
	 */
	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RequestChunkRadius fromBuffer(bool readId=true)(ubyte[] buffer) {
		RequestChunkRadius ret = new RequestChunkRadius();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RequestChunkRadius(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

/**
 * Packet sent always and only in response to RequestChunkRadius to change the client's
 * view distance.
 */
class ChunkRadiusUpdated : Buffer {

	public enum ubyte ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["radius"];

	/**
	 * View distance that may be different from the client's one if the server sets a limit
	 * on the view distance.
	 */
	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ChunkRadiusUpdated fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChunkRadiusUpdated ret = new ChunkRadiusUpdated();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChunkRadiusUpdated(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

class ItemFrameDropItem : Buffer {

	public enum ubyte ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "item"];

	public sul.protocol.pocket101.types.BlockPosition position;
	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.BlockPosition position, sul.protocol.pocket101.types.Slot item=sul.protocol.pocket101.types.Slot.init) {
		this.position = position;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe ItemFrameDropItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		ItemFrameDropItem ret = new ItemFrameDropItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ItemFrameDropItem(position: " ~ std.conv.to!string(this.position) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class ReplaceSelectedItem : Buffer {

	public enum ubyte ID = 71;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["item"];

	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.Slot item) {
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe ReplaceSelectedItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		ReplaceSelectedItem ret = new ReplaceSelectedItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ReplaceSelectedItem(item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

/**
 * Updates client's game rules. This packet is ignored if the game is not launched
 * as Education Edition and should be avoid in favour of AdventureSettings, with which
 * the same result can be obtained with less data.
 */
class GameRulesChanged : Buffer {

	public enum ubyte ID = 72;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["rules"];

	public sul.protocol.pocket101.types.Rule[] rules;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.Rule[] rules) {
		this.rules = rules;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(cast(uint)rules.length); foreach(cvzm;rules){ cvzm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		rules.length=readBigEndianUint(); foreach(ref cvzm;rules){ cvzm.decode(bufferInstance); }
	}

	public static pure nothrow @safe GameRulesChanged fromBuffer(bool readId=true)(ubyte[] buffer) {
		GameRulesChanged ret = new GameRulesChanged();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "GameRulesChanged(rules: " ~ std.conv.to!string(this.rules) ~ ")";
	}

}

class Camera : Buffer {

	public enum ubyte ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "unknown1"];

	public long unknown0;
	public long unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long unknown0, long unknown1=long.init) {
		this.unknown0 = unknown0;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(unknown0));
		writeBytes(varlong.encode(unknown1));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		unknown0=varlong.decode(_buffer, &_index);
		unknown1=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Camera fromBuffer(bool readId=true)(ubyte[] buffer) {
		Camera ret = new Camera();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Camera(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

}

class AddItem : Buffer {

	public enum ubyte ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["item"];

	public sul.protocol.pocket101.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket101.types.Slot item) {
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe AddItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddItem ret = new AddItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddItem(item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

/**
 * Adds, removes or modifies an entity's boss bar. The percentage of the bar is calculated
 * using the entity's attributes for the health and the max health, updated with UpdateAttributes.
 */
class BossEvent : Buffer {

	public enum ubyte ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum uint ADD = 0;
	public enum uint UPDATE = 1;
	public enum uint REMOVE = 2;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public uint eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, uint eventId=uint.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BossEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BossEvent ret = new BossEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BossEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class ShowCredits : Buffer {

	public enum ubyte ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// status
	public enum int START = 0;
	public enum int END = 1;

	public enum string[] FIELDS = ["entityId", "status"];

	public long entityId;
	public int status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int status=int.init) {
		this.entityId = entityId;
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(status));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		status=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ShowCredits fromBuffer(bool readId=true)(ubyte[] buffer) {
		ShowCredits ret = new ShowCredits();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ShowCredits(entityId: " ~ std.conv.to!string(this.entityId) ~ ", status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

/**
 * Sends a list of the commands that the player can use through the CommandStep packet.
 */
class AvailableCommands : Buffer {

	public enum ubyte ID = 77;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["commands", "unknown1"];

	/**
	 * JSON object with the commands.
	 */
	public string commands;
	public string unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string commands, string unknown1=string.init) {
		this.commands = commands;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)commands.length)); writeString(commands);
		writeBytes(varuint.encode(cast(uint)unknown1.length)); writeString(unknown1);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint y9bfzm=varuint.decode(_buffer, &_index); commands=readString(y9bfzm);
		uint d5b9be=varuint.decode(_buffer, &_index); unknown1=readString(d5b9be);
	}

	public static pure nothrow @safe AvailableCommands fromBuffer(bool readId=true)(ubyte[] buffer) {
		AvailableCommands ret = new AvailableCommands();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AvailableCommands(commands: " ~ std.conv.to!string(this.commands) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

}

class CommandStep : Buffer {

	public enum ubyte ID = 78;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["command", "overload", "unknown2", "unknown3", "isOutput", "unknown5", "input", "output"];

	public string command;
	public string overload;
	public uint unknown2;
	public uint unknown3;
	public bool isOutput;
	public ulong unknown5;
	public string input;
	public string output;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string command, string overload=string.init, uint unknown2=uint.init, uint unknown3=uint.init, bool isOutput=bool.init, ulong unknown5=ulong.init, string input=string.init, string output=string.init) {
		this.command = command;
		this.overload = overload;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
		this.isOutput = isOutput;
		this.unknown5 = unknown5;
		this.input = input;
		this.output = output;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)command.length)); writeString(command);
		writeBytes(varuint.encode(cast(uint)overload.length)); writeString(overload);
		writeBytes(varuint.encode(unknown2));
		writeBytes(varuint.encode(unknown3));
		writeBigEndianBool(isOutput);
		writeBytes(varulong.encode(unknown5));
		writeBytes(varuint.encode(cast(uint)input.length)); writeString(input);
		writeBytes(varuint.encode(cast(uint)output.length)); writeString(output);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint y9bfz=varuint.decode(_buffer, &_index); command=readString(y9bfz);
		uint bzcxyq=varuint.decode(_buffer, &_index); overload=readString(bzcxyq);
		unknown2=varuint.decode(_buffer, &_index);
		unknown3=varuint.decode(_buffer, &_index);
		isOutput=readBigEndianBool();
		unknown5=varulong.decode(_buffer, &_index);
		uint a5dq=varuint.decode(_buffer, &_index); input=readString(a5dq);
		uint bvcv=varuint.decode(_buffer, &_index); output=readString(bvcv);
	}

	public static pure nothrow @safe CommandStep fromBuffer(bool readId=true)(ubyte[] buffer) {
		CommandStep ret = new CommandStep();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CommandStep(command: " ~ std.conv.to!string(this.command) ~ ", overload: " ~ std.conv.to!string(this.overload) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", isOutput: " ~ std.conv.to!string(this.isOutput) ~ ", unknown5: " ~ std.conv.to!string(this.unknown5) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
	}

}

class ResourcePackDataInfo : Buffer {

	public enum ubyte ID = 79;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "maxChunkSize", "chunkCount", "compressedPackSize", "sha256"];

	public string id;
	public uint maxChunkSize;
	public uint chunkCount;
	public ulong compressedPackSize;
	public string sha256;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint maxChunkSize=uint.init, uint chunkCount=uint.init, ulong compressedPackSize=ulong.init, string sha256=string.init) {
		this.id = id;
		this.maxChunkSize = maxChunkSize;
		this.chunkCount = chunkCount;
		this.compressedPackSize = compressedPackSize;
		this.sha256 = sha256;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(maxChunkSize);
		writeLittleEndianUint(chunkCount);
		writeLittleEndianUlong(compressedPackSize);
		writeBytes(varuint.encode(cast(uint)sha256.length)); writeString(sha256);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		maxChunkSize=readLittleEndianUint();
		chunkCount=readLittleEndianUint();
		compressedPackSize=readLittleEndianUlong();
		uint chmu=varuint.decode(_buffer, &_index); sha256=readString(chmu);
	}

	public static pure nothrow @safe ResourcePackDataInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackDataInfo ret = new ResourcePackDataInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackDataInfo(id: " ~ std.conv.to!string(this.id) ~ ", maxChunkSize: " ~ std.conv.to!string(this.maxChunkSize) ~ ", chunkCount: " ~ std.conv.to!string(this.chunkCount) ~ ", compressedPackSize: " ~ std.conv.to!string(this.compressedPackSize) ~ ", sha256: " ~ std.conv.to!string(this.sha256) ~ ")";
	}

}

class ResourcePackChunkData : Buffer {

	public enum ubyte ID = 80;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "chunkIndex", "progress", "data"];

	public string id;
	public uint chunkIndex;
	public ulong progress;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint chunkIndex=uint.init, ulong progress=ulong.init, ubyte[] data=(ubyte[]).init) {
		this.id = id;
		this.chunkIndex = chunkIndex;
		this.progress = progress;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(chunkIndex);
		writeLittleEndianUlong(progress);
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		chunkIndex=readLittleEndianUint();
		progress=readLittleEndianUlong();
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe ResourcePackChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkData ret = new ResourcePackChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkData(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ", progress: " ~ std.conv.to!string(this.progress) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ResourcePackChunkRequest : Buffer {

	public enum ubyte ID = 81;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["id", "chunkIndex"];

	public string id;
	public uint chunkIndex;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint chunkIndex=uint.init) {
		this.id = id;
		this.chunkIndex = chunkIndex;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(chunkIndex);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		chunkIndex=readLittleEndianUint();
	}

	public static pure nothrow @safe ResourcePackChunkRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkRequest ret = new ResourcePackChunkRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkRequest(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ")";
	}

}

/**
 * Transfers the player to another server. Once transferred the player will immediately
 * close the connection with the transferring server, try to resolve the ip and join
 * the new server starting a new raknet session.
 */
class Transfer : Buffer {

	public enum ubyte ID = 82;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["ip", "port"];

	/**
	 * Address of the new server. It can be an dotted ip (for example `127.0.0.1`) or an
	 * URI (for example `localhost` or `play.example.com`). Only IP of version 4 are currently
	 * allowed.
	 */
	public string ip;

	/**
	 * Port of the new server. If 0 the server will try to connect to the default port.
	 */
	public ushort port = 19132;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string ip, ushort port=19132) {
		this.ip = ip;
		this.port = port;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)ip.length)); writeString(ip);
		writeLittleEndianUshort(port);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint aa=varuint.decode(_buffer, &_index); ip=readString(aa);
		port=readLittleEndianUshort();
	}

	public static pure nothrow @safe Transfer fromBuffer(bool readId=true)(ubyte[] buffer) {
		Transfer ret = new Transfer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Transfer(ip: " ~ std.conv.to!string(this.ip) ~ ", port: " ~ std.conv.to!string(this.port) ~ ")";
	}

}
