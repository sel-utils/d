/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom2.xml
 */
module sul.protocol.hncom2.panel;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.hncom2.types;

static if(__traits(compiles, { import sul.metadata.hncom2; })) import sul.metadata.hncom2;

alias Packets = TypeTuple!(Connection);

class Connection : Buffer {

	public enum ubyte ID = 36;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hash", "address", "worldId"];

	public ubyte[64] hash;
	public ubyte[] address;
	public uint worldId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte[64] hash, ubyte[] address=(ubyte[]).init, uint worldId=uint.init) {
		this.hash = hash;
		this.address = address;
		this.worldId = worldId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(hash);
		writeBytes(varuint.encode(cast(uint)address.length)); writeBytes(address);
		writeBytes(varuint.encode(worldId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		if(_buffer.length>=_index+hash.length){ hash=_buffer[_index.._index+hash.length].dup; _index+=hash.length; }
		address.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+address.length){ address=_buffer[_index.._index+address.length].dup; _index+=address.length; }
		worldId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Connection fromBuffer(bool readId=true)(ubyte[] buffer) {
		Connection ret = new Connection();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Connection(hash: " ~ std.conv.to!string(this.hash) ~ ", address: " ~ std.conv.to!string(this.address) ~ ", worldId: " ~ std.conv.to!string(this.worldId) ~ ")";
	}

}
