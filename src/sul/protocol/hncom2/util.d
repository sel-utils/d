/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom2.xml
 */
/**
 * Packets used for sending more than one packet at once.
 */
module sul.protocol.hncom2.util;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.hncom2.types;

static if(__traits(compiles, { import sul.metadata.hncom2; })) import sul.metadata.hncom2;

alias Packets = TypeTuple!(Uncompressed, Compressed);

class Uncompressed : Buffer {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["packets"];

	public ubyte[][] packets;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte[][] packets) {
		this.packets = packets;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)packets.length)); foreach(cfavc;packets){ writeBytes(varuint.encode(cast(uint)cfavc.length)); writeBytes(cfavc); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		packets.length=varuint.decode(_buffer, &_index); foreach(ref cfavc;packets){ cfavc.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+cfavc.length){ cfavc=_buffer[_index.._index+cfavc.length].dup; _index+=cfavc.length; } }
	}

	public static pure nothrow @safe Uncompressed fromBuffer(bool readId=true)(ubyte[] buffer) {
		Uncompressed ret = new Uncompressed();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Uncompressed(packets: " ~ std.conv.to!string(this.packets) ~ ")";
	}

}

class Compressed : Buffer {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["size", "payload"];

	public uint size;
	public ubyte[] payload;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint size, ubyte[] payload=(ubyte[]).init) {
		this.size = size;
		this.payload = payload;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(size));
		writeBytes(payload);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		size=varuint.decode(_buffer, &_index);
		payload=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe Compressed fromBuffer(bool readId=true)(ubyte[] buffer) {
		Compressed ret = new Compressed();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Compressed(size: " ~ std.conv.to!string(this.size) ~ ", payload: " ~ std.conv.to!string(this.payload) ~ ")";
	}

}
