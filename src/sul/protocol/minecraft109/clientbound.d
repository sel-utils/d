/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/minecraft109.xml
 */
module sul.protocol.minecraft109.clientbound;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.minecraft109.types;

static if(__traits(compiles, { import sul.metadata.minecraft109; })) import sul.metadata.minecraft109;

alias Packets = TypeTuple!(SpawnObject, SpawnExperienceOrb, SpawnGlobalEntity, SpawnMob, SpawnPainting, SpawnPlayer, Animation, Statistics, BlockBreakAnimation, UpdateBlockEntity, BlockAction, BlockChange, BossBar, ServerDifficulty, TabComplete, ChatMessage, MultiBlockChange, ConfirmTransaction, CloseWindow, OpenWindow, WindowItems, WindowProperty, SetSlot, SetCooldown, PluginMessage, NamedSoundEffect, Disconnect, EntityStatus, Explosion, UnloadChunk, ChangeGameState, KeepAlive, ChunkData, Effect, Particle, JoinGame, Map, EntityRelativeMove, EntityLookAndRelativeMove, EntityLook, Entity, VehicleMove, OpenSignEditor, PlayerAbilities, CombatEvent, PlayerListItem, PlayerPositionAndLook, UseBed, DestroyEntities, RemoveEntityEffect, ResourcePackSend, Respawn, EntityHeadLook, WorldBorder, Camera, HeldItemChange, DisplayScoreboard, EntityMetadata, AttachEntity, EntityVelocity, EntityEquipment, SetExperience, UpdateHealth, ScoreboardObjective, SetPassengers, Teams, UpdateScore, SpawnPosition, TimeUpdate, Title, UpdateSign, SoundEffect, PlayerListHeaderAndFooter, CollectItem, EntityTeleport, EntityProperties, EntityEffect);

class SpawnObject : Buffer {

	public enum uint ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "uuid", "type", "position", "pitch", "yaw", "data", "velocity"];

	public uint entityId;
	public UUID uuid;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte pitch;
	public ubyte yaw;
	public int data;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, UUID uuid=UUID.init, ubyte type=ubyte.init, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init, ubyte pitch=ubyte.init, ubyte yaw=ubyte.init, int data=int.init, Tuple!(short, "x", short, "y", short, "z") velocity=Tuple!(short, "x", short, "y", short, "z").init) {
		this.entityId = entityId;
		this.uuid = uuid;
		this.type = type;
		this.position = position;
		this.pitch = pitch;
		this.yaw = yaw;
		this.data = data;
		this.velocity = velocity;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(uuid.data);
		writeBigEndianUbyte(type);
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianUbyte(pitch);
		writeBigEndianUbyte(yaw);
		writeBigEndianInt(data);
		writeBigEndianShort(velocity.x); writeBigEndianShort(velocity.y); writeBigEndianShort(velocity.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		type=readBigEndianUbyte();
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		pitch=readBigEndianUbyte();
		yaw=readBigEndianUbyte();
		data=readBigEndianInt();
		velocity.x=readBigEndianShort(); velocity.y=readBigEndianShort(); velocity.z=readBigEndianShort();
	}

	public static pure nothrow @safe SpawnObject fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnObject ret = new SpawnObject();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnObject(entityId: " ~ std.conv.to!string(this.entityId) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", velocity: " ~ std.conv.to!string(this.velocity) ~ ")";
	}

}

class SpawnExperienceOrb : Buffer {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "count"];

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ushort count;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init, ushort count=ushort.init) {
		this.entityId = entityId;
		this.position = position;
		this.count = count;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianUshort(count);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		count=readBigEndianUshort();
	}

	public static pure nothrow @safe SpawnExperienceOrb fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnExperienceOrb ret = new SpawnExperienceOrb();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnExperienceOrb(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", count: " ~ std.conv.to!string(this.count) ~ ")";
	}

}

class SpawnGlobalEntity : Buffer {

	public enum uint ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// type
	public enum ubyte THUNDERBOLT = 1;

	public enum string[] FIELDS = ["entityId", "type", "position"];

	public uint entityId;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte type=ubyte.init, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init) {
		this.entityId = entityId;
		this.type = type;
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(type);
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		type=readBigEndianUbyte();
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
	}

	public static pure nothrow @safe SpawnGlobalEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnGlobalEntity ret = new SpawnGlobalEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnGlobalEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class SpawnMob : Buffer {

	public enum uint ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "uuid", "type", "position", "yaw", "pitch", "headPitch", "velocity", "metadata"];

	public uint entityId;
	public UUID uuid;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public ubyte headPitch;
	public Tuple!(short, "x", short, "y", short, "z") velocity;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, UUID uuid=UUID.init, ubyte type=ubyte.init, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init, ubyte yaw=ubyte.init, ubyte pitch=ubyte.init, ubyte headPitch=ubyte.init, Tuple!(short, "x", short, "y", short, "z") velocity=Tuple!(short, "x", short, "y", short, "z").init, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.uuid = uuid;
		this.type = type;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.headPitch = headPitch;
		this.velocity = velocity;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(uuid.data);
		writeBigEndianUbyte(type);
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianUbyte(yaw);
		writeBigEndianUbyte(pitch);
		writeBigEndianUbyte(headPitch);
		writeBigEndianShort(velocity.x); writeBigEndianShort(velocity.y); writeBigEndianShort(velocity.z);
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		type=readBigEndianUbyte();
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		yaw=readBigEndianUbyte();
		pitch=readBigEndianUbyte();
		headPitch=readBigEndianUbyte();
		velocity.x=readBigEndianShort(); velocity.y=readBigEndianShort(); velocity.z=readBigEndianShort();
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe SpawnMob fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnMob ret = new SpawnMob();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnMob(entityId: " ~ std.conv.to!string(this.entityId) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headPitch: " ~ std.conv.to!string(this.headPitch) ~ ", velocity: " ~ std.conv.to!string(this.velocity) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class SpawnPainting : Buffer {

	public enum uint ID = 4;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// direction
	public enum ubyte SOUTH = 0;
	public enum ubyte WEST = 1;
	public enum ubyte NORTH = 2;
	public enum ubyte EAST = 3;

	public enum string[] FIELDS = ["entityId", "uuid", "title", "position", "direction"];

	public uint entityId;
	public UUID uuid;
	public string title;
	public ulong position;
	public ubyte direction;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, UUID uuid=UUID.init, string title=string.init, ulong position=ulong.init, ubyte direction=ubyte.init) {
		this.entityId = entityId;
		this.uuid = uuid;
		this.title = title;
		this.position = position;
		this.direction = direction;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(uuid.data);
		writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
		writeBigEndianUlong(position);
		writeBigEndianUbyte(direction);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
		position=readBigEndianUlong();
		direction=readBigEndianUbyte();
	}

	public static pure nothrow @safe SpawnPainting fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnPainting ret = new SpawnPainting();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnPainting(entityId: " ~ std.conv.to!string(this.entityId) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", title: " ~ std.conv.to!string(this.title) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ")";
	}

}

class SpawnPlayer : Buffer {

	public enum uint ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "uuid", "position", "yaw", "pitch", "metadata"];

	public uint entityId;
	public UUID uuid;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, UUID uuid=UUID.init, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init, ubyte yaw=ubyte.init, ubyte pitch=ubyte.init, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.uuid = uuid;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(uuid.data);
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianUbyte(yaw);
		writeBigEndianUbyte(pitch);
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		yaw=readBigEndianUbyte();
		pitch=readBigEndianUbyte();
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe SpawnPlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnPlayer ret = new SpawnPlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnPlayer(entityId: " ~ std.conv.to!string(this.entityId) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class Animation : Buffer {

	public enum uint ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// animation
	public enum ubyte SWING_MAIN_ARM = 0;
	public enum ubyte TAKE_DAMAGE = 1;
	public enum ubyte LEAVE_BED = 2;
	public enum ubyte SWING_OFFHAND = 3;
	public enum ubyte CRITICAL_EFFECT = 4;
	public enum ubyte MAGICAL_CRITICAL_EFFECT = 5;

	public enum string[] FIELDS = ["entityId", "animation"];

	public uint entityId;
	public ubyte animation;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte animation=ubyte.init) {
		this.entityId = entityId;
		this.animation = animation;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(animation);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		animation=readBigEndianUbyte();
	}

	public static pure nothrow @safe Animation fromBuffer(bool readId=true)(ubyte[] buffer) {
		Animation ret = new Animation();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Animation(entityId: " ~ std.conv.to!string(this.entityId) ~ ", animation: " ~ std.conv.to!string(this.animation) ~ ")";
	}

}

class Statistics : Buffer {

	public enum uint ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["statistics"];

	public sul.protocol.minecraft109.types.Statistic[] statistics;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.minecraft109.types.Statistic[] statistics) {
		this.statistics = statistics;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)statistics.length)); foreach(crdldlc;statistics){ crdldlc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		statistics.length=varuint.decode(_buffer, &_index); foreach(ref crdldlc;statistics){ crdldlc.decode(bufferInstance); }
	}

	public static pure nothrow @safe Statistics fromBuffer(bool readId=true)(ubyte[] buffer) {
		Statistics ret = new Statistics();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Statistics(statistics: " ~ std.conv.to!string(this.statistics) ~ ")";
	}

}

class BlockBreakAnimation : Buffer {

	public enum uint ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "stage"];

	public uint entityId;
	public ulong position;
	public ubyte stage;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ulong position=ulong.init, ubyte stage=ubyte.init) {
		this.entityId = entityId;
		this.position = position;
		this.stage = stage;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUlong(position);
		writeBigEndianUbyte(stage);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		position=readBigEndianUlong();
		stage=readBigEndianUbyte();
	}

	public static pure nothrow @safe BlockBreakAnimation fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockBreakAnimation ret = new BlockBreakAnimation();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockBreakAnimation(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", stage: " ~ std.conv.to!string(this.stage) ~ ")";
	}

}

class UpdateBlockEntity : Buffer {

	public enum uint ID = 9;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte MOB_SPAWNER_DATA = 1;
	public enum ubyte COMMAND_BLOCK_TEXT = 2;
	public enum ubyte BEACON_POWERS = 3;
	public enum ubyte MOB_HEAD_DATA = 4;
	public enum ubyte FLOWER_POT_FLOWER = 5;
	public enum ubyte BANNER_DATA = 6;
	public enum ubyte STRUCTURE_DATA = 7;
	public enum ubyte END_GATEWAY_DESTINATION = 8;

	public enum string[] FIELDS = ["position", "action", "nbt"];

	public ulong position;
	public ubyte action;
	public ubyte[] nbt;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position, ubyte action=ubyte.init, ubyte[] nbt=(ubyte[]).init) {
		this.position = position;
		this.action = action;
		this.nbt = nbt;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		writeBigEndianUbyte(action);
		writeBytes(nbt);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
		action=readBigEndianUbyte();
		nbt=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe UpdateBlockEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateBlockEntity ret = new UpdateBlockEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateBlockEntity(position: " ~ std.conv.to!string(this.position) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
	}

}

class BlockAction : Buffer {

	public enum uint ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte NOTE_BLOCK_HARP = 0;
	public enum ubyte NOTE_BLOCK_BASS_DRUM = 1;
	public enum ubyte NOTE_BLOCK_SNARE_DRUM = 2;
	public enum ubyte NOTE_BLOCK_CLICKS = 3;
	public enum ubyte NOTE_BLOCK_STICKS = 3;
	public enum ubyte NOTE_BLOCK_BASS_GUITAR = 4;
	public enum ubyte PISTON_EXTEND = 0;
	public enum ubyte PISTON_RETRACT = 1;
	public enum ubyte CHEST_WATCHERS = 1;
	public enum ubyte BEACON_RECALCULATE = 1;
	public enum ubyte MOB_SPAWNER_RESET_DELAY = 1;
	public enum ubyte END_GATEWAY_YELLOW_BEAM = 1;

	// parameter
	public enum ubyte PISTON_DOWN = 0;
	public enum ubyte PISTON_UP = 1;
	public enum ubyte PISTON_SOUTH = 2;
	public enum ubyte PISTON_WEST = 3;
	public enum ubyte PISTON_NORTH = 4;
	public enum ubyte PISTON_EAST = 5;

	public enum string[] FIELDS = ["position", "action", "parameter", "blockType"];

	public ulong position;
	public ubyte action;
	public ubyte parameter;
	public uint blockType;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position, ubyte action=ubyte.init, ubyte parameter=ubyte.init, uint blockType=uint.init) {
		this.position = position;
		this.action = action;
		this.parameter = parameter;
		this.blockType = blockType;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		writeBigEndianUbyte(action);
		writeBigEndianUbyte(parameter);
		writeBytes(varuint.encode(blockType));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
		action=readBigEndianUbyte();
		parameter=readBigEndianUbyte();
		blockType=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BlockAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockAction ret = new BlockAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockAction(position: " ~ std.conv.to!string(this.position) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", parameter: " ~ std.conv.to!string(this.parameter) ~ ", blockType: " ~ std.conv.to!string(this.blockType) ~ ")";
	}

}

class BlockChange : Buffer {

	public enum uint ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "block"];

	public ulong position;
	public uint block;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position, uint block=uint.init) {
		this.position = position;
		this.block = block;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		writeBytes(varuint.encode(block));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
		block=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BlockChange fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockChange ret = new BlockChange();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockChange(position: " ~ std.conv.to!string(this.position) ~ ", block: " ~ std.conv.to!string(this.block) ~ ")";
	}

}

class BossBar : Buffer {

	public enum uint ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["uuid", "action"];

	public UUID uuid;
	public uint action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(UUID uuid, uint action=uint.init) {
		this.uuid = uuid;
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(uuid.data);
		writeBytes(varuint.encode(action));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		if(_buffer.length>=_index+16){ ubyte[16] dvz=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dvz); }
		action=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BossBar fromBuffer(bool readId=true)(ubyte[] buffer) {
		BossBar ret = new BossBar();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BossBar(uuid: " ~ std.conv.to!string(this.uuid) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(Add, Remove, UpdateHealth, UpdateTitle, UpdateStyle, UpdateFlags);

	public class Add {

		public enum typeof(action) ACTION = 0;

		// color
		public enum uint PINK = 0;
		public enum uint BLUE = 1;
		public enum uint RED = 2;
		public enum uint GREEN = 3;
		public enum uint YELLOW = 4;
		public enum uint PURPLE = 5;
		public enum uint WHITE = 6;

		// division
		public enum uint NO_DIVISION = 0;
		public enum uint SIX_NOTCHES = 1;
		public enum uint TEN_NOTCHES = 2;
		public enum uint TWELVE_NOTCHES = 3;
		public enum uint TWENTY_NOTCHES = 4;

		// flags
		public enum ubyte DARK_SKY = 1;
		public enum ubyte IS_DRAGON_BAR = 2;

		public enum string[] FIELDS = ["title", "health", "color", "division", "flags"];

		public string title;
		public float health;
		public uint color;
		public uint division;
		public ubyte flags;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title, float health=float.init, uint color=uint.init, uint division=uint.init, ubyte flags=ubyte.init) {
			this.title = title;
			this.health = health;
			this.color = color;
			this.division = division;
			this.flags = flags;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			writeBigEndianFloat(health);
			writeBytes(varuint.encode(color));
			writeBytes(varuint.encode(division));
			writeBigEndianUbyte(flags);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
			health=readBigEndianFloat();
			color=varuint.decode(_buffer, &_index);
			division=varuint.decode(_buffer, &_index);
			flags=readBigEndianUbyte();
		}

		public override string toString() {
			return "BossBar.Add(title: " ~ std.conv.to!string(this.title) ~ ", health: " ~ std.conv.to!string(this.health) ~ ", color: " ~ std.conv.to!string(this.color) ~ ", division: " ~ std.conv.to!string(this.division) ~ ", flags: " ~ std.conv.to!string(this.flags) ~ ")";
		}

	}

	public class Remove {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "BossBar.Remove()";
		}

	}

	public class UpdateHealth {

		public enum typeof(action) ACTION = 2;

		public enum string[] FIELDS = ["health"];

		public float health;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(float health) {
			this.health = health;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 2;
			_encode!writeId();
			writeBigEndianFloat(health);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			health=readBigEndianFloat();
		}

		public override string toString() {
			return "BossBar.UpdateHealth(health: " ~ std.conv.to!string(this.health) ~ ")";
		}

	}

	public class UpdateTitle {

		public enum typeof(action) ACTION = 3;

		public enum string[] FIELDS = ["title"];

		public string title;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title) {
			this.title = title;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
		}

		public override string toString() {
			return "BossBar.UpdateTitle(title: " ~ std.conv.to!string(this.title) ~ ")";
		}

	}

	public class UpdateStyle {

		public enum typeof(action) ACTION = 4;

		// color
		public enum uint PINK = 0;
		public enum uint BLUE = 1;
		public enum uint RED = 2;
		public enum uint GREEN = 3;
		public enum uint YELLOW = 4;
		public enum uint PURPLE = 5;
		public enum uint WHITE = 6;

		// division
		public enum uint NO_DIVISION = 0;
		public enum uint SIX_NOTCHES = 1;
		public enum uint TEN_NOTCHES = 2;
		public enum uint TWELVE_NOTCHES = 3;
		public enum uint TWENTY_NOTCHES = 4;

		public enum string[] FIELDS = ["color", "division"];

		public uint color;
		public uint division;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint color, uint division=uint.init) {
			this.color = color;
			this.division = division;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 4;
			_encode!writeId();
			writeBytes(varuint.encode(color));
			writeBytes(varuint.encode(division));
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			color=varuint.decode(_buffer, &_index);
			division=varuint.decode(_buffer, &_index);
		}

		public override string toString() {
			return "BossBar.UpdateStyle(color: " ~ std.conv.to!string(this.color) ~ ", division: " ~ std.conv.to!string(this.division) ~ ")";
		}

	}

	public class UpdateFlags {

		public enum typeof(action) ACTION = 5;

		// flags
		public enum ubyte DARK_SKY = 1;
		public enum ubyte IS_DRAGON_BAR = 2;

		public enum string[] FIELDS = ["flags"];

		public ubyte flags;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(ubyte flags) {
			this.flags = flags;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 5;
			_encode!writeId();
			writeBigEndianUbyte(flags);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			flags=readBigEndianUbyte();
		}

		public override string toString() {
			return "BossBar.UpdateFlags(flags: " ~ std.conv.to!string(this.flags) ~ ")";
		}

	}

}

class ServerDifficulty : Buffer {

	public enum uint ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	public enum string[] FIELDS = ["difficulty"];

	public ubyte difficulty;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte difficulty) {
		this.difficulty = difficulty;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(difficulty);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		difficulty=readBigEndianUbyte();
	}

	public static pure nothrow @safe ServerDifficulty fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerDifficulty ret = new ServerDifficulty();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerDifficulty(difficulty: " ~ std.conv.to!string(this.difficulty) ~ ")";
	}

}

class TabComplete : Buffer {

	public enum uint ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["matches"];

	public string[] matches;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string[] matches) {
		this.matches = matches;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)matches.length)); foreach(bfyhc;matches){ writeBytes(varuint.encode(cast(uint)bfyhc.length)); writeString(bfyhc); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		matches.length=varuint.decode(_buffer, &_index); foreach(ref bfyhc;matches){ uint yzam=varuint.decode(_buffer, &_index); bfyhc=readString(yzam); }
	}

	public static pure nothrow @safe TabComplete fromBuffer(bool readId=true)(ubyte[] buffer) {
		TabComplete ret = new TabComplete();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TabComplete(matches: " ~ std.conv.to!string(this.matches) ~ ")";
	}

}

class ChatMessage : Buffer {

	public enum uint ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte CHAT = 0;
	public enum ubyte SYSTEM_MESSAGE = 1;
	public enum ubyte ABOVE_HOTBAR = 2;

	public enum string[] FIELDS = ["message", "position"];

	public string message;
	public ubyte position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string message, ubyte position=ubyte.init) {
		this.message = message;
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
		writeBigEndianUbyte(position);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		position=readBigEndianUbyte();
	}

	public static pure nothrow @safe ChatMessage fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChatMessage ret = new ChatMessage();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChatMessage(message: " ~ std.conv.to!string(this.message) ~ ", position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class MultiBlockChange : Buffer {

	public enum uint ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["chunk", "changes"];

	public Tuple!(int, "x", int, "z") chunk;
	public sul.protocol.minecraft109.types.BlockChange[] changes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") chunk, sul.protocol.minecraft109.types.BlockChange[] changes=(sul.protocol.minecraft109.types.BlockChange[]).init) {
		this.chunk = chunk;
		this.changes = changes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianInt(chunk.x); writeBigEndianInt(chunk.z);
		writeBytes(varuint.encode(cast(uint)changes.length)); foreach(yhbdc;changes){ yhbdc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		chunk.x=readBigEndianInt(); chunk.z=readBigEndianInt();
		changes.length=varuint.decode(_buffer, &_index); foreach(ref yhbdc;changes){ yhbdc.decode(bufferInstance); }
	}

	public static pure nothrow @safe MultiBlockChange fromBuffer(bool readId=true)(ubyte[] buffer) {
		MultiBlockChange ret = new MultiBlockChange();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MultiBlockChange(chunk: " ~ std.conv.to!string(this.chunk) ~ ", changes: " ~ std.conv.to!string(this.changes) ~ ")";
	}

}

class ConfirmTransaction : Buffer {

	public enum uint ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "action", "accepted"];

	public ubyte window;
	public ushort action;
	public bool accepted;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ushort action=ushort.init, bool accepted=bool.init) {
		this.window = window;
		this.action = action;
		this.accepted = accepted;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		writeBigEndianUshort(action);
		writeBigEndianBool(accepted);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
		action=readBigEndianUshort();
		accepted=readBigEndianBool();
	}

	public static pure nothrow @safe ConfirmTransaction fromBuffer(bool readId=true)(ubyte[] buffer) {
		ConfirmTransaction ret = new ConfirmTransaction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ConfirmTransaction(window: " ~ std.conv.to!string(this.window) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", accepted: " ~ std.conv.to!string(this.accepted) ~ ")";
	}

}

class CloseWindow : Buffer {

	public enum uint ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window"];

	public ubyte window;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window) {
		this.window = window;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
	}

	public static pure nothrow @safe CloseWindow fromBuffer(bool readId=true)(ubyte[] buffer) {
		CloseWindow ret = new CloseWindow();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CloseWindow(window: " ~ std.conv.to!string(this.window) ~ ")";
	}

}

class OpenWindow : Buffer {

	public enum uint ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "type", "title", "slots"];

	public ubyte window;
	public string type;
	public string title;
	public ubyte slots;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, string type=string.init, string title=string.init, ubyte slots=ubyte.init) {
		this.window = window;
		this.type = type;
		this.title = title;
		this.slots = slots;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		writeBytes(varuint.encode(cast(uint)type.length)); writeString(type);
		writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
		writeBigEndianUbyte(slots);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
		uint dlz=varuint.decode(_buffer, &_index); type=readString(dlz);
		uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
		slots=readBigEndianUbyte();
	}

	public static pure nothrow @safe OpenWindow fromBuffer(bool readId=true)(ubyte[] buffer) {
		OpenWindow ret = new OpenWindow();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "OpenWindow(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", title: " ~ std.conv.to!string(this.title) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ")";
	}

}

class WindowItems : Buffer {

	public enum uint ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "slots"];

	public ubyte window;
	public sul.protocol.minecraft109.types.Slot[] slots;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, sul.protocol.minecraft109.types.Slot[] slots=(sul.protocol.minecraft109.types.Slot[]).init) {
		this.window = window;
		this.slots = slots;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		writeBigEndianUshort(cast(ushort)slots.length); foreach(cxdm;slots){ cxdm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
		slots.length=readBigEndianUshort(); foreach(ref cxdm;slots){ cxdm.decode(bufferInstance); }
	}

	public static pure nothrow @safe WindowItems fromBuffer(bool readId=true)(ubyte[] buffer) {
		WindowItems ret = new WindowItems();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "WindowItems(window: " ~ std.conv.to!string(this.window) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ")";
	}

}

class WindowProperty : Buffer {

	public enum uint ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// property
	public enum ushort FURNANCE_FIRE_ICON = 0;
	public enum ushort FURNACE_MAX_FUEL_BURN_TIME = 1;
	public enum ushort FURNACE_PROGRESS_ARROW = 2;
	public enum ushort FURNCE_MAX_PROGRESS = 3;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_TOP = 0;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_MIDDLE = 1;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_BOTTOM = 2;
	public enum ushort ENCHANTMENT_SEED = 3;
	public enum ushort ENCHANTMENT_ID_TOP = 4;
	public enum ushort ENCHANTMENT_ID_MIDDLE = 5;
	public enum ushort ENCHANTMENT_ID_BOTTOM = 6;
	public enum ushort ENCHANTMENT_LEVEL_TOP = 7;
	public enum ushort ENCHANTMENT_LEVEL_MIDDLE = 8;
	public enum ushort ENCHANTMENT_LEVEL_BOTTOM = 9;
	public enum ushort BEACON_POWER_LEVEL = 0;
	public enum ushort BEACON_FIRST_EFFECT = 1;
	public enum ushort BEACON_SECOND_EFFECT = 2;
	public enum ushort ANVIL_REPAIR_COST = 0;
	public enum ushort BREWING_STAND_BREW_TIME = 0;

	public enum string[] FIELDS = ["window", "property", "value"];

	public ubyte window;
	public ushort property;
	public short value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ushort property=ushort.init, short value=short.init) {
		this.window = window;
		this.property = property;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		writeBigEndianUshort(property);
		writeBigEndianShort(value);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
		property=readBigEndianUshort();
		value=readBigEndianShort();
	}

	public static pure nothrow @safe WindowProperty fromBuffer(bool readId=true)(ubyte[] buffer) {
		WindowProperty ret = new WindowProperty();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "WindowProperty(window: " ~ std.conv.to!string(this.window) ~ ", property: " ~ std.conv.to!string(this.property) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class SetSlot : Buffer {

	public enum uint ID = 22;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "slot", "item"];

	public ubyte window;
	public ushort slot;
	public sul.protocol.minecraft109.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ushort slot=ushort.init, sul.protocol.minecraft109.types.Slot item=sul.protocol.minecraft109.types.Slot.init) {
		this.window = window;
		this.slot = slot;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(window);
		writeBigEndianUshort(slot);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readBigEndianUbyte();
		slot=readBigEndianUshort();
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe SetSlot fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetSlot ret = new SetSlot();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetSlot(window: " ~ std.conv.to!string(this.window) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class SetCooldown : Buffer {

	public enum uint ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["item", "cooldown"];

	public uint item;
	public uint cooldown;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint item, uint cooldown=uint.init) {
		this.item = item;
		this.cooldown = cooldown;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(item));
		writeBytes(varuint.encode(cooldown));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		item=varuint.decode(_buffer, &_index);
		cooldown=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetCooldown fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetCooldown ret = new SetCooldown();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetCooldown(item: " ~ std.conv.to!string(this.item) ~ ", cooldown: " ~ std.conv.to!string(this.cooldown) ~ ")";
	}

}

class PluginMessage : Buffer {

	public enum uint ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["channel", "data"];

	public string channel;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string channel, ubyte[] data=(ubyte[]).init) {
		this.channel = channel;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)channel.length)); writeString(channel);
		writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint yhb5b=varuint.decode(_buffer, &_index); channel=readString(yhb5b);
		data=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe PluginMessage fromBuffer(bool readId=true)(ubyte[] buffer) {
		PluginMessage ret = new PluginMessage();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PluginMessage(channel: " ~ std.conv.to!string(this.channel) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class NamedSoundEffect : Buffer {

	public enum uint ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["name", "category", "position", "volume", "pitch"];

	public string name;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public ubyte pitch;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string name, uint category=uint.init, Tuple!(int, "x", int, "y", int, "z") position=Tuple!(int, "x", int, "y", int, "z").init, float volume=float.init, ubyte pitch=ubyte.init) {
		this.name = name;
		this.category = category;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		writeBytes(varuint.encode(category));
		writeBigEndianInt(position.x); writeBigEndianInt(position.y); writeBigEndianInt(position.z);
		writeBigEndianFloat(volume);
		writeBigEndianUbyte(pitch);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bfz=varuint.decode(_buffer, &_index); name=readString(bfz);
		category=varuint.decode(_buffer, &_index);
		position.x=readBigEndianInt(); position.y=readBigEndianInt(); position.z=readBigEndianInt();
		volume=readBigEndianFloat();
		pitch=readBigEndianUbyte();
	}

	public static pure nothrow @safe NamedSoundEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		NamedSoundEffect ret = new NamedSoundEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "NamedSoundEffect(name: " ~ std.conv.to!string(this.name) ~ ", category: " ~ std.conv.to!string(this.category) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ")";
	}

}

class Disconnect : Buffer {

	public enum uint ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["reason"];

	public string reason;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string reason) {
		this.reason = reason;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)reason.length)); writeString(reason);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint cvc9=varuint.decode(_buffer, &_index); reason=readString(cvc9);
	}

	public static pure nothrow @safe Disconnect fromBuffer(bool readId=true)(ubyte[] buffer) {
		Disconnect ret = new Disconnect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Disconnect(reason: " ~ std.conv.to!string(this.reason) ~ ")";
	}

}

class EntityStatus : Buffer {

	public enum uint ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum ubyte SPAWN_TIPPED_ARROW_PARTICLE_EFFECTS = 0;
	public enum ubyte PLAY_JUMPING_ANIMATION_AND_PARTICLES = 1;
	public enum ubyte RESET_SPAWNER_DELAY = 1;
	public enum ubyte PLAY_HURT_ANIMATION_AND_SOUND = 2;
	public enum ubyte PLAY_DEATH_ANIMATION_AND_SOUND = 3;
	public enum ubyte PLAY_ATTACK_ANIMATION_AND_SOUND = 4;
	public enum ubyte SPAWN_SMOKE_PARTICLES = 6;
	public enum ubyte SPAWN_HEART_PARTICLES = 7;
	public enum ubyte PLAY_SHAKING_WATER_ANIMATION = 8;
	public enum ubyte FINISHED_CONSUMING = 9;
	public enum ubyte PLAY_EATING_GRASS_ANIMATION = 10;
	public enum ubyte IGNITE_MINECART_TNT = 10;
	public enum ubyte HOLD_POPPY = 11;
	public enum ubyte SPAWN_VILLAGER_MATING_HEART_PARTICLES = 12;
	public enum ubyte SPAWN_VILLAGER_ANGRY_PARTICLES = 13;
	public enum ubyte SPAWN_VILLAGER_HAPPY_PARTICLES = 14;
	public enum ubyte SPAWN_WITCH_MAGIC_PARTICLES = 15;
	public enum ubyte PLAY_ZOMBIE_CURE_FINISHED_SOUND = 16;
	public enum ubyte SPAWN_FIREWORK_EXPLOSION_EFFECT = 17;
	public enum ubyte SPAWN_LOVE_PARTICLES = 18;
	public enum ubyte RESET_SQUID_ROTATION = 19;
	public enum ubyte SPAWN_EXPLOSION_PARTICLES = 20;
	public enum ubyte PLAY_GUARDIAN_SOUND_EFFECT = 21;
	public enum ubyte ENABLE_REDUCED_DEBUG_SCREEN = 22;
	public enum ubyte DISABLE_REDUCED_DEBUG_SCREEN = 23;
	public enum ubyte SET_OP_PERMISSION_LEVEL_0 = 24;
	public enum ubyte SET_OP_PERMISSION_LEVEL_1 = 25;
	public enum ubyte SET_OP_PERMISSION_LEVEL_2 = 26;
	public enum ubyte SET_OP_PERMISSION_LEVEL_3 = 27;
	public enum ubyte SET_OP_PERMISSION_LEVEL_4 = 28;
	public enum ubyte PLAY_SHIELD_BLOCK_SOUND = 29;
	public enum ubyte PLAY_SHIELD_BREAK_SOUND = 30;
	public enum ubyte HOOK_KNOCKBACK = 31;
	public enum ubyte PLAY_HIT_SOUND = 32;
	public enum ubyte PLAY_THORNS_HURT_ANIMATION_AND_SOUND = 33;

	public enum string[] FIELDS = ["entityId", "status"];

	public uint entityId;
	public ubyte status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte status=ubyte.init) {
		this.entityId = entityId;
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(entityId);
		writeBigEndianUbyte(status);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=readBigEndianUint();
		status=readBigEndianUbyte();
	}

	public static pure nothrow @safe EntityStatus fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityStatus ret = new EntityStatus();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityStatus(entityId: " ~ std.conv.to!string(this.entityId) ~ ", status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

class Explosion : Buffer {

	public enum uint ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "radius", "records", "motion"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public Tuple!(byte, "x", byte, "y", byte, "z")[] records;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, float radius=float.init, Tuple!(byte, "x", byte, "y", byte, "z")[] records=(Tuple!(byte, "x", byte, "y", byte, "z")[]).init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.position = position;
		this.radius = radius;
		this.records = records;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianFloat(position.x); writeBigEndianFloat(position.y); writeBigEndianFloat(position.z);
		writeBigEndianFloat(radius);
		writeBigEndianUint(cast(uint)records.length); foreach(cvbjc;records){ writeBigEndianByte(cvbjc.x); writeBigEndianByte(cvbjc.y); writeBigEndianByte(cvbjc.z); }
		writeBigEndianFloat(motion.x); writeBigEndianFloat(motion.y); writeBigEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readBigEndianFloat(); position.y=readBigEndianFloat(); position.z=readBigEndianFloat();
		radius=readBigEndianFloat();
		records.length=readBigEndianUint(); foreach(ref cvbjc;records){ cvbjc.x=readBigEndianByte(); cvbjc.y=readBigEndianByte(); cvbjc.z=readBigEndianByte(); }
		motion.x=readBigEndianFloat(); motion.y=readBigEndianFloat(); motion.z=readBigEndianFloat();
	}

	public static pure nothrow @safe Explosion fromBuffer(bool readId=true)(ubyte[] buffer) {
		Explosion ret = new Explosion();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Explosion(position: " ~ std.conv.to!string(this.position) ~ ", radius: " ~ std.conv.to!string(this.radius) ~ ", records: " ~ std.conv.to!string(this.records) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class UnloadChunk : Buffer {

	public enum uint ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public Tuple!(int, "x", int, "z") position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianInt(position.x); writeBigEndianInt(position.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readBigEndianInt(); position.z=readBigEndianInt();
	}

	public static pure nothrow @safe UnloadChunk fromBuffer(bool readId=true)(ubyte[] buffer) {
		UnloadChunk ret = new UnloadChunk();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UnloadChunk(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class ChangeGameState : Buffer {

	public enum uint ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// reason
	public enum ubyte INVALID_BED = 0;
	public enum ubyte END_RAINING = 1;
	public enum ubyte BEGIN_RAINING = 2;
	public enum ubyte CHANGE_GAMEMODE = 3;
	public enum ubyte EXIT_END = 4;
	public enum ubyte DEMO_MESSAGE = 5;
	public enum ubyte ARROW_HITTING_PLAYER = 6;
	public enum ubyte FADE_VALUE = 7;
	public enum ubyte FADE_TIME = 8;
	public enum ubyte PLAY_ELDER_GUARDIAN_MOB_APPEARANCE = 10;

	// value
	public enum float SURVIVAL = 0;
	public enum float CREATIVE = 1;
	public enum float ADVENTURE = 2;
	public enum float SPECTATOR = 3;
	public enum float RESPAWN_IMMEDIATELY = 0;
	public enum float RESPAWN_AFTER_CREDITS = 1;
	public enum float SHOW_DEMO_SCREEN = 0;
	public enum float TELL_MOVEMENT_CONTROLS = 101;
	public enum float TELL_JUMP_CONTROLS = 102;
	public enum float TELL_INVENTORY_CONTROLS = 103;
	public enum float BRIGHT = 0;
	public enum float DARK = 1;

	public enum string[] FIELDS = ["reason", "value"];

	public ubyte reason;
	public float value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte reason, float value=float.init) {
		this.reason = reason;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(reason);
		writeBigEndianFloat(value);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		reason=readBigEndianUbyte();
		value=readBigEndianFloat();
	}

	public static pure nothrow @safe ChangeGameState fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChangeGameState ret = new ChangeGameState();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChangeGameState(reason: " ~ std.conv.to!string(this.reason) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class KeepAlive : Buffer {

	public enum uint ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id"];

	public uint id;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint id) {
		this.id = id;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(id));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		id=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe KeepAlive fromBuffer(bool readId=true)(ubyte[] buffer) {
		KeepAlive ret = new KeepAlive();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "KeepAlive(id: " ~ std.conv.to!string(this.id) ~ ")";
	}

}

class ChunkData : Buffer {

	public enum uint ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "full", "sections", "data"];

	public Tuple!(int, "x", int, "z") position;
	public bool full;
	public uint sections;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") position, bool full=bool.init, uint sections=uint.init, ubyte[] data=(ubyte[]).init) {
		this.position = position;
		this.full = full;
		this.sections = sections;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianInt(position.x); writeBigEndianInt(position.z);
		writeBigEndianBool(full);
		writeBytes(varuint.encode(sections));
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readBigEndianInt(); position.z=readBigEndianInt();
		full=readBigEndianBool();
		sections=varuint.decode(_buffer, &_index);
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe ChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChunkData ret = new ChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChunkData(position: " ~ std.conv.to!string(this.position) ~ ", full: " ~ std.conv.to!string(this.full) ~ ", sections: " ~ std.conv.to!string(this.sections) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class Effect : Buffer {

	public enum uint ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// effect id
	public enum uint DISPENSER_DISPENSE = 1000;
	public enum uint DISPENSER_FAIL_DISPENSE = 1001;
	public enum uint DISPENSER_SHOOT = 1002;
	public enum uint ENDER_EYE_LAUNCH = 1003;
	public enum uint FIREWORK_SHOT = 1004;
	public enum uint IRON_DOOR_OPEN = 1005;
	public enum uint WOODEN_DOOR_OPEN = 1006;
	public enum uint WOODEN_TRAPDOOR_OPEN = 1007;
	public enum uint FENCE_GATE_OPEN = 1008;
	public enum uint FIRE_EXTINGUISH = 1009;
	public enum uint PLAY_RECORD = 1010;
	public enum uint IRON_DOOR_CLOSE = 1011;
	public enum uint WOODEN_DOOR_CLOSE = 1012;
	public enum uint WOODEN_TRAPDOOR_CLOSE = 1013;
	public enum uint FENCE_GATE_CLOSE = 1014;
	public enum uint GHAST_WARN = 1015;
	public enum uint GHAST_SHOOT = 1016;
	public enum uint ENDERDRAGON_SHOOT = 1017;
	public enum uint BLAZE_SHOOT = 1018;
	public enum uint ZOMBIE_ATTACK_WOOD_DOOR = 1019;
	public enum uint ZOMBIE_ATTACK_IRON_DOOR = 1020;
	public enum uint ZOMBIE_BREAK_WOOD_DOOR = 1021;
	public enum uint WITHER_BREAK_BLOCK = 1022;
	public enum uint WITHER_SPAWN = 1023;
	public enum uint WITHER_SHOOT = 1024;
	public enum uint BAT_TAKE_OFF = 1025;
	public enum uint ZOMBIE_INFECT_VILLAGER = 1026;
	public enum uint ZOMBIE_VILLAGER_CONVERT = 1027;
	public enum uint ENDER_DRAGON_BREATH = 1028;
	public enum uint ANVIL_BREAK = 1029;
	public enum uint ANVIL_USE = 1030;
	public enum uint ANVIL_LAND = 1031;
	public enum uint PORTAL_TRAVEL = 1032;
	public enum uint CHORUS_FLOWER_GROW = 1033;
	public enum uint CHORUS_FLOWER_DIE = 1034;
	public enum uint BREWING_STAND_BREW = 1035;
	public enum uint IRON_TRAPDOOR_OPEN = 1036;
	public enum uint IRON_TRAPDOOR_CLOSE = 1037;
	public enum uint SPAWN_10_SMOKE_PARTICLES = 2000;
	public enum uint BREAK_BREAK_PARTICLES_AND_SOUND = 2001;
	public enum uint SPLASH_POTION_PARTICLES_AND_SOUND = 2002;
	public enum uint ENDER_EYE_BREAK_PARTICLES_AND_SOUND = 2003;
	public enum uint MOB_SPAWN_PARTICLES = 2004;
	public enum uint BONEMEAL_PARTICLES = 2005;
	public enum uint DRAGON_BREATH = 2006;
	public enum uint END_GATEWAY_SPAWN = 3000;
	public enum uint ENDERDRAGON_GROWL = 3001;

	public enum string[] FIELDS = ["effectId", "position", "data", "disableVolume"];

	public uint effectId;
	public ulong position;
	public uint data;
	public bool disableVolume;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint effectId, ulong position=ulong.init, uint data=uint.init, bool disableVolume=bool.init) {
		this.effectId = effectId;
		this.position = position;
		this.data = data;
		this.disableVolume = disableVolume;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(effectId);
		writeBigEndianUlong(position);
		writeBigEndianUint(data);
		writeBigEndianBool(disableVolume);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		effectId=readBigEndianUint();
		position=readBigEndianUlong();
		data=readBigEndianUint();
		disableVolume=readBigEndianBool();
	}

	public static pure nothrow @safe Effect fromBuffer(bool readId=true)(ubyte[] buffer) {
		Effect ret = new Effect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Effect(effectId: " ~ std.conv.to!string(this.effectId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", disableVolume: " ~ std.conv.to!string(this.disableVolume) ~ ")";
	}

}

class Particle : Buffer {

	public enum uint ID = 34;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// particle id
	public enum uint EXPLODE = 0;
	public enum uint LARGE_EXPLOSION = 1;
	public enum uint HUGE_EXPLOSION = 2;
	public enum uint FIREWORK_SPARK = 3;
	public enum uint BUBBLE = 4;
	public enum uint SPLASH = 5;
	public enum uint WAKE = 6;
	public enum uint SUSPENDED = 7;
	public enum uint DEPTH_SUSPEND = 8;
	public enum uint CRIT = 9;
	public enum uint MAGIC_CRIT = 10;
	public enum uint SMOKE = 11;
	public enum uint LARGE_SMOKE = 12;
	public enum uint SPELL = 13;
	public enum uint INSTANT_SPELL = 14;
	public enum uint MOB_SPELL = 15;
	public enum uint MOB_SPELL_AMBIENT = 16;
	public enum uint WITCH_MAGIC = 17;
	public enum uint DRIP_WATER = 18;
	public enum uint DRIP_LAVA = 19;
	public enum uint ANGRY_VILLAGER = 20;
	public enum uint HAPPY_VILLAGER = 21;
	public enum uint TOWN_AURA = 22;
	public enum uint NOTE = 23;
	public enum uint PORTAL = 24;
	public enum uint ENCHANTMENT_TABLE = 25;
	public enum uint FLAME = 26;
	public enum uint LAVA = 27;
	public enum uint FOOTSTEP = 28;
	public enum uint CLOUD = 29;
	public enum uint RED_DUST = 30;
	public enum uint SNOWBALL_POOF = 31;
	public enum uint SNOW_SHOVEL = 32;
	public enum uint SLIME = 33;
	public enum uint HEART = 34;
	public enum uint BARRIER = 35;
	public enum uint ITEM_CRACK = 36;
	public enum uint BLOCK_CRACK = 37;
	public enum uint BLOCK_DUST = 38;
	public enum uint DROPLET = 39;
	public enum uint TAKE = 40;
	public enum uint MOB_APPEARANCE = 41;
	public enum uint DRAGON_BREATH = 42;
	public enum uint ENDROD = 43;
	public enum uint DAMAGE_INDICATOR = 44;
	public enum uint SWEEP_ATTACK = 45;

	public enum string[] FIELDS = ["particleId", "longDistance", "position", "offset", "data", "count", "additionalData"];

	public uint particleId;
	public bool longDistance;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") offset;
	public float data;
	public uint count;
	public uint[2] additionalData;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint particleId, bool longDistance=bool.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") offset=Tuple!(float, "x", float, "y", float, "z").init, float data=float.init, uint count=uint.init, uint[2] additionalData=(uint[2]).init) {
		this.particleId = particleId;
		this.longDistance = longDistance;
		this.position = position;
		this.offset = offset;
		this.data = data;
		this.count = count;
		this.additionalData = additionalData;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(particleId);
		writeBigEndianBool(longDistance);
		writeBigEndianFloat(position.x); writeBigEndianFloat(position.y); writeBigEndianFloat(position.z);
		writeBigEndianFloat(offset.x); writeBigEndianFloat(offset.y); writeBigEndianFloat(offset.z);
		writeBigEndianFloat(data);
		writeBigEndianUint(count);
		foreach(yrarb5br;additionalData){ writeBytes(varuint.encode(yrarb5br)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		particleId=readBigEndianUint();
		longDistance=readBigEndianBool();
		position.x=readBigEndianFloat(); position.y=readBigEndianFloat(); position.z=readBigEndianFloat();
		offset.x=readBigEndianFloat(); offset.y=readBigEndianFloat(); offset.z=readBigEndianFloat();
		data=readBigEndianFloat();
		count=readBigEndianUint();
		foreach(ref yrarb5br;additionalData){ yrarb5br=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe Particle fromBuffer(bool readId=true)(ubyte[] buffer) {
		Particle ret = new Particle();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Particle(particleId: " ~ std.conv.to!string(this.particleId) ~ ", longDistance: " ~ std.conv.to!string(this.longDistance) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", count: " ~ std.conv.to!string(this.count) ~ ", additionalData: " ~ std.conv.to!string(this.additionalData) ~ ")";
	}

}

class JoinGame : Buffer {

	public enum uint ID = 35;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	// dimension
	public enum int NETHER = -1;
	public enum int OVERWORLD = 0;
	public enum int END = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	// level type
	public enum string INFINITY = "default";
	public enum string FLAT = "flat";
	public enum string AMPLIFIED = "amplified";
	public enum string LARGE_BIOMES = "largeBiomes";

	public enum string[] FIELDS = ["entityId", "gamemode", "dimension", "difficulty", "maxPlayers", "levelType", "reducedDebug"];

	public uint entityId;
	public ubyte gamemode;
	public int dimension;
	public ubyte difficulty;
	public ubyte maxPlayers;
	public string levelType;
	public bool reducedDebug;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte gamemode=ubyte.init, int dimension=int.init, ubyte difficulty=ubyte.init, ubyte maxPlayers=ubyte.init, string levelType=string.init, bool reducedDebug=bool.init) {
		this.entityId = entityId;
		this.gamemode = gamemode;
		this.dimension = dimension;
		this.difficulty = difficulty;
		this.maxPlayers = maxPlayers;
		this.levelType = levelType;
		this.reducedDebug = reducedDebug;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(entityId);
		writeBigEndianUbyte(gamemode);
		writeBigEndianInt(dimension);
		writeBigEndianUbyte(difficulty);
		writeBigEndianUbyte(maxPlayers);
		writeBytes(varuint.encode(cast(uint)levelType.length)); writeString(levelType);
		writeBigEndianBool(reducedDebug);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=readBigEndianUint();
		gamemode=readBigEndianUbyte();
		dimension=readBigEndianInt();
		difficulty=readBigEndianUbyte();
		maxPlayers=readBigEndianUbyte();
		uint bvzxeb=varuint.decode(_buffer, &_index); levelType=readString(bvzxeb);
		reducedDebug=readBigEndianBool();
	}

	public static pure nothrow @safe JoinGame fromBuffer(bool readId=true)(ubyte[] buffer) {
		JoinGame ret = new JoinGame();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "JoinGame(entityId: " ~ std.conv.to!string(this.entityId) ~ ", gamemode: " ~ std.conv.to!string(this.gamemode) ~ ", dimension: " ~ std.conv.to!string(this.dimension) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", maxPlayers: " ~ std.conv.to!string(this.maxPlayers) ~ ", levelType: " ~ std.conv.to!string(this.levelType) ~ ", reducedDebug: " ~ std.conv.to!string(this.reducedDebug) ~ ")";
	}

}

class Map : Buffer {

	public enum uint ID = 36;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mapId", "scale", "showIcons", "icons", "colums", "rows", "offset", "data"];

	public uint mapId;
	public ubyte scale;
	public bool showIcons;
	public sul.protocol.minecraft109.types.Icon[] icons;
	public ubyte colums;
	public ubyte rows;
	public Tuple!(ubyte, "x", ubyte, "z") offset;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint mapId, ubyte scale=ubyte.init, bool showIcons=bool.init, sul.protocol.minecraft109.types.Icon[] icons=(sul.protocol.minecraft109.types.Icon[]).init, ubyte colums=ubyte.init, ubyte rows=ubyte.init, Tuple!(ubyte, "x", ubyte, "z") offset=Tuple!(ubyte, "x", ubyte, "z").init, ubyte[] data=(ubyte[]).init) {
		this.mapId = mapId;
		this.scale = scale;
		this.showIcons = showIcons;
		this.icons = icons;
		this.colums = colums;
		this.rows = rows;
		this.offset = offset;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(mapId));
		writeBigEndianUbyte(scale);
		writeBigEndianBool(showIcons);
		writeBytes(varuint.encode(cast(uint)icons.length)); foreach(anbm;icons){ anbm.encode(bufferInstance); }
		writeBigEndianUbyte(colums);
		writeBigEndianUbyte(rows);
		writeBigEndianUbyte(offset.x); writeBigEndianUbyte(offset.z);
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		mapId=varuint.decode(_buffer, &_index);
		scale=readBigEndianUbyte();
		showIcons=readBigEndianBool();
		icons.length=varuint.decode(_buffer, &_index); foreach(ref anbm;icons){ anbm.decode(bufferInstance); }
		colums=readBigEndianUbyte();
		rows=readBigEndianUbyte();
		offset.x=readBigEndianUbyte(); offset.z=readBigEndianUbyte();
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe Map fromBuffer(bool readId=true)(ubyte[] buffer) {
		Map ret = new Map();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Map(mapId: " ~ std.conv.to!string(this.mapId) ~ ", scale: " ~ std.conv.to!string(this.scale) ~ ", showIcons: " ~ std.conv.to!string(this.showIcons) ~ ", icons: " ~ std.conv.to!string(this.icons) ~ ", colums: " ~ std.conv.to!string(this.colums) ~ ", rows: " ~ std.conv.to!string(this.rows) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class EntityRelativeMove : Buffer {

	public enum uint ID = 37;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "delta", "onGround"];

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Tuple!(short, "x", short, "y", short, "z") delta=Tuple!(short, "x", short, "y", short, "z").init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.delta = delta;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianShort(delta.x); writeBigEndianShort(delta.y); writeBigEndianShort(delta.z);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		delta.x=readBigEndianShort(); delta.y=readBigEndianShort(); delta.z=readBigEndianShort();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe EntityRelativeMove fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityRelativeMove ret = new EntityRelativeMove();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityRelativeMove(entityId: " ~ std.conv.to!string(this.entityId) ~ ", delta: " ~ std.conv.to!string(this.delta) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class EntityLookAndRelativeMove : Buffer {

	public enum uint ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "delta", "yaw", "pitch", "onGround"];

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Tuple!(short, "x", short, "y", short, "z") delta=Tuple!(short, "x", short, "y", short, "z").init, ubyte yaw=ubyte.init, ubyte pitch=ubyte.init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.delta = delta;
		this.yaw = yaw;
		this.pitch = pitch;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianShort(delta.x); writeBigEndianShort(delta.y); writeBigEndianShort(delta.z);
		writeBigEndianUbyte(yaw);
		writeBigEndianUbyte(pitch);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		delta.x=readBigEndianShort(); delta.y=readBigEndianShort(); delta.z=readBigEndianShort();
		yaw=readBigEndianUbyte();
		pitch=readBigEndianUbyte();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe EntityLookAndRelativeMove fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityLookAndRelativeMove ret = new EntityLookAndRelativeMove();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityLookAndRelativeMove(entityId: " ~ std.conv.to!string(this.entityId) ~ ", delta: " ~ std.conv.to!string(this.delta) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class EntityLook : Buffer {

	public enum uint ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "yaw", "pitch", "onGround"];

	public uint entityId;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte yaw=ubyte.init, ubyte pitch=ubyte.init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.yaw = yaw;
		this.pitch = pitch;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(yaw);
		writeBigEndianUbyte(pitch);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		yaw=readBigEndianUbyte();
		pitch=readBigEndianUbyte();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe EntityLook fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityLook ret = new EntityLook();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityLook(entityId: " ~ std.conv.to!string(this.entityId) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class Entity : Buffer {

	public enum uint ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId"];

	public uint entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId) {
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Entity fromBuffer(bool readId=true)(ubyte[] buffer) {
		Entity ret = new Entity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Entity(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class VehicleMove : Buffer {

	public enum uint ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "yaw", "pitch"];

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(double, "x", double, "y", double, "z") position, float yaw=float.init, float pitch=float.init) {
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianFloat(yaw);
		writeBigEndianFloat(pitch);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		yaw=readBigEndianFloat();
		pitch=readBigEndianFloat();
	}

	public static pure nothrow @safe VehicleMove fromBuffer(bool readId=true)(ubyte[] buffer) {
		VehicleMove ret = new VehicleMove();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "VehicleMove(position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ")";
	}

}

class OpenSignEditor : Buffer {

	public enum uint ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public ulong position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
	}

	public static pure nothrow @safe OpenSignEditor fromBuffer(bool readId=true)(ubyte[] buffer) {
		OpenSignEditor ret = new OpenSignEditor();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "OpenSignEditor(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class PlayerAbilities : Buffer {

	public enum uint ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte INVULNERABLE = 1;
	public enum ubyte FLYING = 2;
	public enum ubyte ALLOW_FLYING = 4;
	public enum ubyte CREATIVE_MODE = 8;

	public enum string[] FIELDS = ["flags", "flyingSpeed", "fovModifier"];

	public ubyte flags;
	public float flyingSpeed;
	public float fovModifier;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte flags, float flyingSpeed=float.init, float fovModifier=float.init) {
		this.flags = flags;
		this.flyingSpeed = flyingSpeed;
		this.fovModifier = fovModifier;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(flags);
		writeBigEndianFloat(flyingSpeed);
		writeBigEndianFloat(fovModifier);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		flags=readBigEndianUbyte();
		flyingSpeed=readBigEndianFloat();
		fovModifier=readBigEndianFloat();
	}

	public static pure nothrow @safe PlayerAbilities fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerAbilities ret = new PlayerAbilities();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerAbilities(flags: " ~ std.conv.to!string(this.flags) ~ ", flyingSpeed: " ~ std.conv.to!string(this.flyingSpeed) ~ ", fovModifier: " ~ std.conv.to!string(this.fovModifier) ~ ")";
	}

}

class CombatEvent : Buffer {

	public enum uint ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["eventId"];

	public ubyte eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte eventId) {
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(eventId);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		eventId=readBigEndianUbyte();
	}

	public static pure nothrow @safe CombatEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		CombatEvent ret = new CombatEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CombatEvent(eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "eventId";

	alias Variants = TypeTuple!(EnterCombat, EndCombat, EntityDead);

	public class EnterCombat {

		public enum typeof(eventId) EVENT_ID = 0;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			eventId = 0;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "CombatEvent.EnterCombat()";
		}

	}

	public class EndCombat {

		public enum typeof(eventId) EVENT_ID = 1;

		public enum string[] FIELDS = ["duration", "entityId"];

		public uint duration;
		public uint entityId;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint duration, uint entityId=uint.init) {
			this.duration = duration;
			this.entityId = entityId;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			eventId = 1;
			_encode!writeId();
			writeBytes(varuint.encode(duration));
			writeBigEndianUint(entityId);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			duration=varuint.decode(_buffer, &_index);
			entityId=readBigEndianUint();
		}

		public override string toString() {
			return "CombatEvent.EndCombat(duration: " ~ std.conv.to!string(this.duration) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
		}

	}

	public class EntityDead {

		public enum typeof(eventId) EVENT_ID = 2;

		public enum string[] FIELDS = ["playerId", "entityId", "message"];

		public uint playerId;
		public uint entityId;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint playerId, uint entityId=uint.init, string message=string.init) {
			this.playerId = playerId;
			this.entityId = entityId;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			eventId = 2;
			_encode!writeId();
			writeBytes(varuint.encode(playerId));
			writeBigEndianUint(entityId);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			playerId=varuint.decode(_buffer, &_index);
			entityId=readBigEndianUint();
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "CombatEvent.EntityDead(playerId: " ~ std.conv.to!string(this.playerId) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

}

class PlayerListItem : Buffer {

	public enum uint ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public uint action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(action));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe PlayerListItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerListItem ret = new PlayerListItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerListItem(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(AddPlayer, UpdateGamemode, UpdateLatency, UpdateDisplayName, RemovePlayer);

	public class AddPlayer {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.minecraft109.types.ListAddPlayer[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.minecraft109.types.ListAddPlayer[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerListItem.AddPlayer(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class UpdateGamemode {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.minecraft109.types.ListUpdateGamemode[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.minecraft109.types.ListUpdateGamemode[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerListItem.UpdateGamemode(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class UpdateLatency {

		public enum typeof(action) ACTION = 2;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.minecraft109.types.ListUpdateLatency[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.minecraft109.types.ListUpdateLatency[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 2;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerListItem.UpdateLatency(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class UpdateDisplayName {

		public enum typeof(action) ACTION = 3;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.minecraft109.types.ListUpdateDisplayName[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.minecraft109.types.ListUpdateDisplayName[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerListItem.UpdateDisplayName(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class RemovePlayer {

		public enum typeof(action) ACTION = 4;

		public enum string[] FIELDS = ["players"];

		public UUID[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(UUID[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ writeBytes(cxevc.data); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ if(_buffer.length>=_index+16){ ubyte[16] yhdm=_buffer[_index.._index+16].dup; _index+=16; cxevc=UUID(yhdm); } }
		}

		public override string toString() {
			return "PlayerListItem.RemovePlayer(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

}

class PlayerPositionAndLook : Buffer {

	public enum uint ID = 46;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte X = 1;
	public enum ubyte Y = 2;
	public enum ubyte Z = 4;
	public enum ubyte Y_ROTATION = 8;
	public enum ubyte X_ROTATION = 16;

	public enum string[] FIELDS = ["position", "yaw", "pitch", "flags", "teleportId"];

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;
	public ubyte flags;
	public uint teleportId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(double, "x", double, "y", double, "z") position, float yaw=float.init, float pitch=float.init, ubyte flags=ubyte.init, uint teleportId=uint.init) {
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.flags = flags;
		this.teleportId = teleportId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianFloat(yaw);
		writeBigEndianFloat(pitch);
		writeBigEndianUbyte(flags);
		writeBytes(varuint.encode(teleportId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		yaw=readBigEndianFloat();
		pitch=readBigEndianFloat();
		flags=readBigEndianUbyte();
		teleportId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe PlayerPositionAndLook fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerPositionAndLook ret = new PlayerPositionAndLook();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerPositionAndLook(position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", flags: " ~ std.conv.to!string(this.flags) ~ ", teleportId: " ~ std.conv.to!string(this.teleportId) ~ ")";
	}

}

class UseBed : Buffer {

	public enum uint ID = 47;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position"];

	public uint entityId;
	public ulong position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ulong position=ulong.init) {
		this.entityId = entityId;
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUlong(position);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		position=readBigEndianUlong();
	}

	public static pure nothrow @safe UseBed fromBuffer(bool readId=true)(ubyte[] buffer) {
		UseBed ret = new UseBed();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UseBed(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class DestroyEntities : Buffer {

	public enum uint ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityIds"];

	public uint[] entityIds;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint[] entityIds) {
		this.entityIds = entityIds;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)entityIds.length)); foreach(z5arsr;entityIds){ writeBytes(varuint.encode(z5arsr)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityIds.length=varuint.decode(_buffer, &_index); foreach(ref z5arsr;entityIds){ z5arsr=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe DestroyEntities fromBuffer(bool readId=true)(ubyte[] buffer) {
		DestroyEntities ret = new DestroyEntities();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "DestroyEntities(entityIds: " ~ std.conv.to!string(this.entityIds) ~ ")";
	}

}

class RemoveEntityEffect : Buffer {

	public enum uint ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "effectId"];

	public uint entityId;
	public ubyte effectId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte effectId=ubyte.init) {
		this.entityId = entityId;
		this.effectId = effectId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(effectId);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		effectId=readBigEndianUbyte();
	}

	public static pure nothrow @safe RemoveEntityEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveEntityEffect ret = new RemoveEntityEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveEntityEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", effectId: " ~ std.conv.to!string(this.effectId) ~ ")";
	}

}

class ResourcePackSend : Buffer {

	public enum uint ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["url", "hash"];

	public string url;
	public string hash;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string url, string hash=string.init) {
		this.url = url;
		this.hash = hash;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)url.length)); writeString(url);
		writeBytes(varuint.encode(cast(uint)hash.length)); writeString(hash);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint dj=varuint.decode(_buffer, &_index); url=readString(dj);
		uint afa=varuint.decode(_buffer, &_index); hash=readString(afa);
	}

	public static pure nothrow @safe ResourcePackSend fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackSend ret = new ResourcePackSend();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackSend(url: " ~ std.conv.to!string(this.url) ~ ", hash: " ~ std.conv.to!string(this.hash) ~ ")";
	}

}

class Respawn : Buffer {

	public enum uint ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int NETHER = -1;
	public enum int OVERWORLD = 0;
	public enum int END = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	// level type
	public enum string INFINITY = "default";
	public enum string FLAT = "flat";
	public enum string AMPLIFIED = "amplified";
	public enum string LARGE_BIOMES = "largeBiomes";

	public enum string[] FIELDS = ["dimension", "difficulty", "gamemode", "levelType"];

	public int dimension;
	public ubyte difficulty;
	public ubyte gamemode;
	public string levelType;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int dimension, ubyte difficulty=ubyte.init, ubyte gamemode=ubyte.init, string levelType=string.init) {
		this.dimension = dimension;
		this.difficulty = difficulty;
		this.gamemode = gamemode;
		this.levelType = levelType;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianInt(dimension);
		writeBigEndianUbyte(difficulty);
		writeBigEndianUbyte(gamemode);
		writeBytes(varuint.encode(cast(uint)levelType.length)); writeString(levelType);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		dimension=readBigEndianInt();
		difficulty=readBigEndianUbyte();
		gamemode=readBigEndianUbyte();
		uint bvzxeb=varuint.decode(_buffer, &_index); levelType=readString(bvzxeb);
	}

	public static pure nothrow @safe Respawn fromBuffer(bool readId=true)(ubyte[] buffer) {
		Respawn ret = new Respawn();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Respawn(dimension: " ~ std.conv.to!string(this.dimension) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", gamemode: " ~ std.conv.to!string(this.gamemode) ~ ", levelType: " ~ std.conv.to!string(this.levelType) ~ ")";
	}

}

class EntityHeadLook : Buffer {

	public enum uint ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "headYaw"];

	public uint entityId;
	public ubyte headYaw;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte headYaw=ubyte.init) {
		this.entityId = entityId;
		this.headYaw = headYaw;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(headYaw);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		headYaw=readBigEndianUbyte();
	}

	public static pure nothrow @safe EntityHeadLook fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityHeadLook ret = new EntityHeadLook();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityHeadLook(entityId: " ~ std.conv.to!string(this.entityId) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ")";
	}

}

class WorldBorder : Buffer {

	public enum uint ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public uint action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(action));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe WorldBorder fromBuffer(bool readId=true)(ubyte[] buffer) {
		WorldBorder ret = new WorldBorder();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "WorldBorder(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(SetSize, LerpSize, SetCenter, Initialize, SetWarningTime, SetWarningBlocks);

	public class SetSize {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["diameter"];

		public double diameter;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(double diameter) {
			this.diameter = diameter;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBigEndianDouble(diameter);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			diameter=readBigEndianDouble();
		}

		public override string toString() {
			return "WorldBorder.SetSize(diameter: " ~ std.conv.to!string(this.diameter) ~ ")";
		}

	}

	public class LerpSize {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["oldDiameter", "newDiameter", "speed"];

		public double oldDiameter;
		public double newDiameter;
		public ulong speed;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(double oldDiameter, double newDiameter=double.init, ulong speed=ulong.init) {
			this.oldDiameter = oldDiameter;
			this.newDiameter = newDiameter;
			this.speed = speed;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBigEndianDouble(oldDiameter);
			writeBigEndianDouble(newDiameter);
			writeBytes(varulong.encode(speed));
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			oldDiameter=readBigEndianDouble();
			newDiameter=readBigEndianDouble();
			speed=varulong.decode(_buffer, &_index);
		}

		public override string toString() {
			return "WorldBorder.LerpSize(oldDiameter: " ~ std.conv.to!string(this.oldDiameter) ~ ", newDiameter: " ~ std.conv.to!string(this.newDiameter) ~ ", speed: " ~ std.conv.to!string(this.speed) ~ ")";
		}

	}

	public class SetCenter {

		public enum typeof(action) ACTION = 2;

		public enum string[] FIELDS = ["center"];

		public Tuple!(double, "x", double, "y", double, "z") center;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(Tuple!(double, "x", double, "y", double, "z") center) {
			this.center = center;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 2;
			_encode!writeId();
			writeBigEndianDouble(center.x); writeBigEndianDouble(center.y); writeBigEndianDouble(center.z);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			center.x=readBigEndianDouble(); center.y=readBigEndianDouble(); center.z=readBigEndianDouble();
		}

		public override string toString() {
			return "WorldBorder.SetCenter(center: " ~ std.conv.to!string(this.center) ~ ")";
		}

	}

	public class Initialize {

		public enum typeof(action) ACTION = 3;

		public enum string[] FIELDS = ["center", "oldDiameter", "newDiameter", "speed", "portalTeleportBoundary", "warningTime", "warningBlocks"];

		public Tuple!(double, "x", double, "y", double, "z") center;
		public double oldDiameter;
		public double newDiameter;
		public ulong speed;
		public uint portalTeleportBoundary;
		public uint warningTime;
		public uint warningBlocks;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(Tuple!(double, "x", double, "y", double, "z") center, double oldDiameter=double.init, double newDiameter=double.init, ulong speed=ulong.init, uint portalTeleportBoundary=uint.init, uint warningTime=uint.init, uint warningBlocks=uint.init) {
			this.center = center;
			this.oldDiameter = oldDiameter;
			this.newDiameter = newDiameter;
			this.speed = speed;
			this.portalTeleportBoundary = portalTeleportBoundary;
			this.warningTime = warningTime;
			this.warningBlocks = warningBlocks;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 3;
			_encode!writeId();
			writeBigEndianDouble(center.x); writeBigEndianDouble(center.y); writeBigEndianDouble(center.z);
			writeBigEndianDouble(oldDiameter);
			writeBigEndianDouble(newDiameter);
			writeBytes(varulong.encode(speed));
			writeBytes(varuint.encode(portalTeleportBoundary));
			writeBytes(varuint.encode(warningTime));
			writeBytes(varuint.encode(warningBlocks));
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			center.x=readBigEndianDouble(); center.y=readBigEndianDouble(); center.z=readBigEndianDouble();
			oldDiameter=readBigEndianDouble();
			newDiameter=readBigEndianDouble();
			speed=varulong.decode(_buffer, &_index);
			portalTeleportBoundary=varuint.decode(_buffer, &_index);
			warningTime=varuint.decode(_buffer, &_index);
			warningBlocks=varuint.decode(_buffer, &_index);
		}

		public override string toString() {
			return "WorldBorder.Initialize(center: " ~ std.conv.to!string(this.center) ~ ", oldDiameter: " ~ std.conv.to!string(this.oldDiameter) ~ ", newDiameter: " ~ std.conv.to!string(this.newDiameter) ~ ", speed: " ~ std.conv.to!string(this.speed) ~ ", portalTeleportBoundary: " ~ std.conv.to!string(this.portalTeleportBoundary) ~ ", warningTime: " ~ std.conv.to!string(this.warningTime) ~ ", warningBlocks: " ~ std.conv.to!string(this.warningBlocks) ~ ")";
		}

	}

	public class SetWarningTime {

		public enum typeof(action) ACTION = 4;

		public enum string[] FIELDS = ["warningTime"];

		public uint warningTime;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint warningTime) {
			this.warningTime = warningTime;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 4;
			_encode!writeId();
			writeBytes(varuint.encode(warningTime));
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			warningTime=varuint.decode(_buffer, &_index);
		}

		public override string toString() {
			return "WorldBorder.SetWarningTime(warningTime: " ~ std.conv.to!string(this.warningTime) ~ ")";
		}

	}

	public class SetWarningBlocks {

		public enum typeof(action) ACTION = 5;

		public enum string[] FIELDS = ["warningBlocks"];

		public uint warningBlocks;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint warningBlocks) {
			this.warningBlocks = warningBlocks;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 5;
			_encode!writeId();
			writeBytes(varuint.encode(warningBlocks));
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			warningBlocks=varuint.decode(_buffer, &_index);
		}

		public override string toString() {
			return "WorldBorder.SetWarningBlocks(warningBlocks: " ~ std.conv.to!string(this.warningBlocks) ~ ")";
		}

	}

}

class Camera : Buffer {

	public enum uint ID = 54;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId"];

	public uint entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId) {
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Camera fromBuffer(bool readId=true)(ubyte[] buffer) {
		Camera ret = new Camera();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Camera(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class HeldItemChange : Buffer {

	public enum uint ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["slot"];

	public ubyte slot;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte slot) {
		this.slot = slot;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(slot);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		slot=readBigEndianUbyte();
	}

	public static pure nothrow @safe HeldItemChange fromBuffer(bool readId=true)(ubyte[] buffer) {
		HeldItemChange ret = new HeldItemChange();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "HeldItemChange(slot: " ~ std.conv.to!string(this.slot) ~ ")";
	}

}

class DisplayScoreboard : Buffer {

	public enum uint ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte LIST = 0;
	public enum ubyte SIDEBAR = 1;
	public enum ubyte BELOW_NAME = 2;

	public enum string[] FIELDS = ["position", "scoreName"];

	public ubyte position;
	public string scoreName;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte position, string scoreName=string.init) {
		this.position = position;
		this.scoreName = scoreName;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUbyte(position);
		writeBytes(varuint.encode(cast(uint)scoreName.length)); writeString(scoreName);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUbyte();
		uint cncvy1=varuint.decode(_buffer, &_index); scoreName=readString(cncvy1);
	}

	public static pure nothrow @safe DisplayScoreboard fromBuffer(bool readId=true)(ubyte[] buffer) {
		DisplayScoreboard ret = new DisplayScoreboard();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "DisplayScoreboard(position: " ~ std.conv.to!string(this.position) ~ ", scoreName: " ~ std.conv.to!string(this.scoreName) ~ ")";
	}

}

class EntityMetadata : Buffer {

	public enum uint ID = 57;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "metadata"];

	public uint entityId;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe EntityMetadata fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityMetadata ret = new EntityMetadata();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityMetadata(entityId: " ~ std.conv.to!string(this.entityId) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class AttachEntity : Buffer {

	public enum uint ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["target", "holder"];

	public uint target;
	public uint holder;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint target, uint holder=uint.init) {
		this.target = target;
		this.holder = holder;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(target);
		writeBigEndianUint(holder);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		target=readBigEndianUint();
		holder=readBigEndianUint();
	}

	public static pure nothrow @safe AttachEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AttachEntity ret = new AttachEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AttachEntity(target: " ~ std.conv.to!string(this.target) ~ ", holder: " ~ std.conv.to!string(this.holder) ~ ")";
	}

}

class EntityVelocity : Buffer {

	public enum uint ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "velocity"];

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Tuple!(short, "x", short, "y", short, "z") velocity=Tuple!(short, "x", short, "y", short, "z").init) {
		this.entityId = entityId;
		this.velocity = velocity;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianShort(velocity.x); writeBigEndianShort(velocity.y); writeBigEndianShort(velocity.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		velocity.x=readBigEndianShort(); velocity.y=readBigEndianShort(); velocity.z=readBigEndianShort();
	}

	public static pure nothrow @safe EntityVelocity fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityVelocity ret = new EntityVelocity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityVelocity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", velocity: " ~ std.conv.to!string(this.velocity) ~ ")";
	}

}

class EntityEquipment : Buffer {

	public enum uint ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "slot", "item"];

	public uint entityId;
	public uint slot;
	public sul.protocol.minecraft109.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, uint slot=uint.init, sul.protocol.minecraft109.types.Slot item=sul.protocol.minecraft109.types.Slot.init) {
		this.entityId = entityId;
		this.slot = slot;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(varuint.encode(slot));
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		slot=varuint.decode(_buffer, &_index);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe EntityEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityEquipment ret = new EntityEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class SetExperience : Buffer {

	public enum uint ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["experience", "level", "totalExperience"];

	public float experience;
	public uint level;
	public uint totalExperience;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float experience, uint level=uint.init, uint totalExperience=uint.init) {
		this.experience = experience;
		this.level = level;
		this.totalExperience = totalExperience;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianFloat(experience);
		writeBytes(varuint.encode(level));
		writeBytes(varuint.encode(totalExperience));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		experience=readBigEndianFloat();
		level=varuint.decode(_buffer, &_index);
		totalExperience=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetExperience fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetExperience ret = new SetExperience();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetExperience(experience: " ~ std.conv.to!string(this.experience) ~ ", level: " ~ std.conv.to!string(this.level) ~ ", totalExperience: " ~ std.conv.to!string(this.totalExperience) ~ ")";
	}

}

class UpdateHealth : Buffer {

	public enum uint ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["health", "hunger", "saturation"];

	public float health;
	public uint hunger;
	public float saturation;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float health, uint hunger=uint.init, float saturation=float.init) {
		this.health = health;
		this.hunger = hunger;
		this.saturation = saturation;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianFloat(health);
		writeBytes(varuint.encode(hunger));
		writeBigEndianFloat(saturation);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		health=readBigEndianFloat();
		hunger=varuint.decode(_buffer, &_index);
		saturation=readBigEndianFloat();
	}

	public static pure nothrow @safe UpdateHealth fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateHealth ret = new UpdateHealth();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateHealth(health: " ~ std.conv.to!string(this.health) ~ ", hunger: " ~ std.conv.to!string(this.hunger) ~ ", saturation: " ~ std.conv.to!string(this.saturation) ~ ")";
	}

}

class ScoreboardObjective : Buffer {

	public enum uint ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// mode
	public enum ubyte CREATE = 0;
	public enum ubyte REMOVE = 1;
	public enum ubyte UPDATE = 2;

	// type
	public enum string NUMERIC = "integer";
	public enum string GRAPHIC = "hearts";

	public enum string[] FIELDS = ["name", "mode", "value", "type"];

	public string name;
	public ubyte mode;
	public string value;
	public string type;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string name, ubyte mode=ubyte.init, string value=string.init, string type=string.init) {
		this.name = name;
		this.mode = mode;
		this.value = value;
		this.type = type;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		writeBigEndianUbyte(mode);
		if(mode!=1){ writeBytes(varuint.encode(cast(uint)value.length)); writeString(value); }
		if(mode!=1){ writeBytes(varuint.encode(cast(uint)type.length)); writeString(type); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bfz=varuint.decode(_buffer, &_index); name=readString(bfz);
		mode=readBigEndianUbyte();
		if(mode!=1){ uint dfdu=varuint.decode(_buffer, &_index); value=readString(dfdu); }
		if(mode!=1){ uint dlz=varuint.decode(_buffer, &_index); type=readString(dlz); }
	}

	public static pure nothrow @safe ScoreboardObjective fromBuffer(bool readId=true)(ubyte[] buffer) {
		ScoreboardObjective ret = new ScoreboardObjective();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ScoreboardObjective(name: " ~ std.conv.to!string(this.name) ~ ", mode: " ~ std.conv.to!string(this.mode) ~ ", value: " ~ std.conv.to!string(this.value) ~ ", type: " ~ std.conv.to!string(this.type) ~ ")";
	}

}

class SetPassengers : Buffer {

	public enum uint ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "passengers"];

	public uint entityId;
	public uint[] passengers;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, uint[] passengers=(uint[]).init) {
		this.entityId = entityId;
		this.passengers = passengers;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBytes(varuint.encode(cast(uint)passengers.length)); foreach(cfcvzvc;passengers){ writeBytes(varuint.encode(cfcvzvc)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		passengers.length=varuint.decode(_buffer, &_index); foreach(ref cfcvzvc;passengers){ cfcvzvc=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe SetPassengers fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetPassengers ret = new SetPassengers();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetPassengers(entityId: " ~ std.conv.to!string(this.entityId) ~ ", passengers: " ~ std.conv.to!string(this.passengers) ~ ")";
	}

}

class Teams : Buffer {

	public enum uint ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["name", "mode"];

	public string name;
	public ubyte mode;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string name, ubyte mode=ubyte.init) {
		this.name = name;
		this.mode = mode;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		writeBigEndianUbyte(mode);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bfz=varuint.decode(_buffer, &_index); name=readString(bfz);
		mode=readBigEndianUbyte();
	}

	public static pure nothrow @safe Teams fromBuffer(bool readId=true)(ubyte[] buffer) {
		Teams ret = new Teams();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Teams(name: " ~ std.conv.to!string(this.name) ~ ", mode: " ~ std.conv.to!string(this.mode) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "mode";

	alias Variants = TypeTuple!(CreateTeam, RemoveTeam, UpdateTeamInfo, AddPlayers, RemovePlayers);

	public class CreateTeam {

		public enum typeof(mode) MODE = 0;

		// friendly flags
		public enum ubyte FRIENDLY_FIRE = 1;
		public enum ubyte SEE_TEAM_INVISIBLE_PLAYERS = 2;

		// nametag visibility
		public enum string ALWAYS_HIDE = "always";
		public enum string HIDE_OTHER_TEAMS = "hideOtherTeams";
		public enum string HIDE_OWN_TEAM = "hideOwnTeam";
		public enum string NEVER_HIDE = "never";

		// collision rule
		public enum string ALWAYS_PUSH = "always";
		public enum string PUSH_OTHER_TEAMS = "pushOtherTeams";
		public enum string PUSH_OWN_TEAM = "pushOwnTeam";
		public enum string NEVER_PUSH = "never";

		public enum string[] FIELDS = ["displayName", "prefix", "suffix", "friendlyFlags", "nametagVisibility", "collisionRule", "color", "players"];

		public string displayName;
		public string prefix;
		public string suffix;
		public ubyte friendlyFlags;
		public string nametagVisibility;
		public string collisionRule;
		public ubyte color;
		public string[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string displayName, string prefix=string.init, string suffix=string.init, ubyte friendlyFlags=ubyte.init, string nametagVisibility=string.init, string collisionRule=string.init, ubyte color=ubyte.init, string[] players=(string[]).init) {
			this.displayName = displayName;
			this.prefix = prefix;
			this.suffix = suffix;
			this.friendlyFlags = friendlyFlags;
			this.nametagVisibility = nametagVisibility;
			this.collisionRule = collisionRule;
			this.color = color;
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			mode = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)displayName.length)); writeString(displayName);
			writeBytes(varuint.encode(cast(uint)prefix.length)); writeString(prefix);
			writeBytes(varuint.encode(cast(uint)suffix.length)); writeString(suffix);
			writeBigEndianUbyte(friendlyFlags);
			writeBytes(varuint.encode(cast(uint)nametagVisibility.length)); writeString(nametagVisibility);
			writeBytes(varuint.encode(cast(uint)collisionRule.length)); writeString(collisionRule);
			writeBigEndianUbyte(color);
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ writeBytes(varuint.encode(cast(uint)cxevc.length)); writeString(cxevc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint zlcxe5bu=varuint.decode(_buffer, &_index); displayName=readString(zlcxe5bu);
			uint cjzl=varuint.decode(_buffer, &_index); prefix=readString(cjzl);
			uint cvzl=varuint.decode(_buffer, &_index); suffix=readString(cvzl);
			friendlyFlags=readBigEndianUbyte();
			uint bfzrzzcl=varuint.decode(_buffer, &_index); nametagVisibility=readString(bfzrzzcl);
			uint y9bla9uv=varuint.decode(_buffer, &_index); collisionRule=readString(y9bla9uv);
			color=readBigEndianUbyte();
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ uint yhdm=varuint.decode(_buffer, &_index); cxevc=readString(yhdm); }
		}

		public override string toString() {
			return "Teams.CreateTeam(displayName: " ~ std.conv.to!string(this.displayName) ~ ", prefix: " ~ std.conv.to!string(this.prefix) ~ ", suffix: " ~ std.conv.to!string(this.suffix) ~ ", friendlyFlags: " ~ std.conv.to!string(this.friendlyFlags) ~ ", nametagVisibility: " ~ std.conv.to!string(this.nametagVisibility) ~ ", collisionRule: " ~ std.conv.to!string(this.collisionRule) ~ ", color: " ~ std.conv.to!string(this.color) ~ ", players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class RemoveTeam {

		public enum typeof(mode) MODE = 1;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			mode = 1;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "Teams.RemoveTeam()";
		}

	}

	public class UpdateTeamInfo {

		public enum typeof(mode) MODE = 2;

		// friendly flags
		public enum ubyte FRIENDLY_FIRE = 1;
		public enum ubyte SEE_TEAM_INVISIBLE_PLAYERS = 2;

		// nametag visibility
		public enum string ALWAYS_HIDE = "always";
		public enum string HIDE_OTHER_TEAMS = "hideOtherTeams";
		public enum string HIDE_OWN_TEAM = "hideOwnTeam";
		public enum string NEVER_HIDE = "never";

		// collision rule
		public enum string ALWAYS_PUSH = "always";
		public enum string PUSH_OTHER_TEAMS = "pushOtherTeams";
		public enum string PUSH_OWN_TEAM = "pushOwnTeam";
		public enum string NEVER_PUSH = "never";

		public enum string[] FIELDS = ["displayName", "prefix", "suffix", "friendlyFlags", "nametagVisibility", "collisionRule", "color"];

		public string displayName;
		public string prefix;
		public string suffix;
		public ubyte friendlyFlags;
		public string nametagVisibility;
		public string collisionRule;
		public ubyte color;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string displayName, string prefix=string.init, string suffix=string.init, ubyte friendlyFlags=ubyte.init, string nametagVisibility=string.init, string collisionRule=string.init, ubyte color=ubyte.init) {
			this.displayName = displayName;
			this.prefix = prefix;
			this.suffix = suffix;
			this.friendlyFlags = friendlyFlags;
			this.nametagVisibility = nametagVisibility;
			this.collisionRule = collisionRule;
			this.color = color;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			mode = 2;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)displayName.length)); writeString(displayName);
			writeBytes(varuint.encode(cast(uint)prefix.length)); writeString(prefix);
			writeBytes(varuint.encode(cast(uint)suffix.length)); writeString(suffix);
			writeBigEndianUbyte(friendlyFlags);
			writeBytes(varuint.encode(cast(uint)nametagVisibility.length)); writeString(nametagVisibility);
			writeBytes(varuint.encode(cast(uint)collisionRule.length)); writeString(collisionRule);
			writeBigEndianUbyte(color);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint zlcxe5bu=varuint.decode(_buffer, &_index); displayName=readString(zlcxe5bu);
			uint cjzl=varuint.decode(_buffer, &_index); prefix=readString(cjzl);
			uint cvzl=varuint.decode(_buffer, &_index); suffix=readString(cvzl);
			friendlyFlags=readBigEndianUbyte();
			uint bfzrzzcl=varuint.decode(_buffer, &_index); nametagVisibility=readString(bfzrzzcl);
			uint y9bla9uv=varuint.decode(_buffer, &_index); collisionRule=readString(y9bla9uv);
			color=readBigEndianUbyte();
		}

		public override string toString() {
			return "Teams.UpdateTeamInfo(displayName: " ~ std.conv.to!string(this.displayName) ~ ", prefix: " ~ std.conv.to!string(this.prefix) ~ ", suffix: " ~ std.conv.to!string(this.suffix) ~ ", friendlyFlags: " ~ std.conv.to!string(this.friendlyFlags) ~ ", nametagVisibility: " ~ std.conv.to!string(this.nametagVisibility) ~ ", collisionRule: " ~ std.conv.to!string(this.collisionRule) ~ ", color: " ~ std.conv.to!string(this.color) ~ ")";
		}

	}

	public class AddPlayers {

		public enum typeof(mode) MODE = 3;

		public enum string[] FIELDS = ["players"];

		public string[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			mode = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ writeBytes(varuint.encode(cast(uint)cxevc.length)); writeString(cxevc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ uint yhdm=varuint.decode(_buffer, &_index); cxevc=readString(yhdm); }
		}

		public override string toString() {
			return "Teams.AddPlayers(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class RemovePlayers {

		public enum typeof(mode) MODE = 4;

		public enum string[] FIELDS = ["players"];

		public string[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			mode = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ writeBytes(varuint.encode(cast(uint)cxevc.length)); writeString(cxevc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ uint yhdm=varuint.decode(_buffer, &_index); cxevc=readString(yhdm); }
		}

		public override string toString() {
			return "Teams.RemovePlayers(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

}

class UpdateScore : Buffer {

	public enum uint ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte UPDATE = 0;
	public enum ubyte REMOVE = 1;

	public enum string[] FIELDS = ["scoreName", "action", "objectiveName", "value"];

	public string scoreName;
	public ubyte action;
	public string objectiveName;
	public uint value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string scoreName, ubyte action=ubyte.init, string objectiveName=string.init, uint value=uint.init) {
		this.scoreName = scoreName;
		this.action = action;
		this.objectiveName = objectiveName;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)scoreName.length)); writeString(scoreName);
		writeBigEndianUbyte(action);
		writeBytes(varuint.encode(cast(uint)objectiveName.length)); writeString(objectiveName);
		if(action==0){ writeBytes(varuint.encode(value)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint cncvy1=varuint.decode(_buffer, &_index); scoreName=readString(cncvy1);
		action=readBigEndianUbyte();
		uint bjznaztf=varuint.decode(_buffer, &_index); objectiveName=readString(bjznaztf);
		if(action==0){ value=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe UpdateScore fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateScore ret = new UpdateScore();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateScore(scoreName: " ~ std.conv.to!string(this.scoreName) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", objectiveName: " ~ std.conv.to!string(this.objectiveName) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class SpawnPosition : Buffer {

	public enum uint ID = 67;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public ulong position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
	}

	public static pure nothrow @safe SpawnPosition fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnPosition ret = new SpawnPosition();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnPosition(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class TimeUpdate : Buffer {

	public enum uint ID = 68;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["worldAge", "time"];

	public ulong worldAge;
	public long time;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong worldAge, long time=long.init) {
		this.worldAge = worldAge;
		this.time = time;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(worldAge);
		writeBigEndianLong(time);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		worldAge=readBigEndianUlong();
		time=readBigEndianLong();
	}

	public static pure nothrow @safe TimeUpdate fromBuffer(bool readId=true)(ubyte[] buffer) {
		TimeUpdate ret = new TimeUpdate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TimeUpdate(worldAge: " ~ std.conv.to!string(this.worldAge) ~ ", time: " ~ std.conv.to!string(this.time) ~ ")";
	}

}

class Title : Buffer {

	public enum uint ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public uint action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(action));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Title fromBuffer(bool readId=true)(ubyte[] buffer) {
		Title ret = new Title();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Title(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(SetTitle, SetSubtitle, SetTimings, Hide, Reset);

	public class SetTitle {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["text"];

		public string text;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string text) {
			this.text = text;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)text.length)); writeString(text);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dvd=varuint.decode(_buffer, &_index); text=readString(dvd);
		}

		public override string toString() {
			return "Title.SetTitle(text: " ~ std.conv.to!string(this.text) ~ ")";
		}

	}

	public class SetSubtitle {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["text"];

		public string text;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string text) {
			this.text = text;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)text.length)); writeString(text);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dvd=varuint.decode(_buffer, &_index); text=readString(dvd);
		}

		public override string toString() {
			return "Title.SetSubtitle(text: " ~ std.conv.to!string(this.text) ~ ")";
		}

	}

	public class SetTimings {

		public enum typeof(action) ACTION = 2;

		public enum string[] FIELDS = ["fadeIn", "stay", "fadeOut"];

		public uint fadeIn;
		public uint stay;
		public uint fadeOut;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint fadeIn, uint stay=uint.init, uint fadeOut=uint.init) {
			this.fadeIn = fadeIn;
			this.stay = stay;
			this.fadeOut = fadeOut;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 2;
			_encode!writeId();
			writeBigEndianUint(fadeIn);
			writeBigEndianUint(stay);
			writeBigEndianUint(fadeOut);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			fadeIn=readBigEndianUint();
			stay=readBigEndianUint();
			fadeOut=readBigEndianUint();
		}

		public override string toString() {
			return "Title.SetTimings(fadeIn: " ~ std.conv.to!string(this.fadeIn) ~ ", stay: " ~ std.conv.to!string(this.stay) ~ ", fadeOut: " ~ std.conv.to!string(this.fadeOut) ~ ")";
		}

	}

	public class Hide {

		public enum typeof(action) ACTION = 3;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 3;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "Title.Hide()";
		}

	}

	public class Reset {

		public enum typeof(action) ACTION = 4;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 4;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "Title.Reset()";
		}

	}

}

class UpdateSign : Buffer {

	public enum uint ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "lines"];

	public ulong position;
	public string[4] lines;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ulong position, string[4] lines=(string[4]).init) {
		this.position = position;
		this.lines = lines;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUlong(position);
		foreach(blzm;lines){ writeBytes(varuint.encode(cast(uint)blzm.length)); writeString(blzm); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position=readBigEndianUlong();
		foreach(ref blzm;lines){ uint yxb=varuint.decode(_buffer, &_index); blzm=readString(yxb); }
	}

	public static pure nothrow @safe UpdateSign fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateSign ret = new UpdateSign();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateSign(position: " ~ std.conv.to!string(this.position) ~ ", lines: " ~ std.conv.to!string(this.lines) ~ ")";
	}

}

class SoundEffect : Buffer {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["soundId", "category", "position", "volume", "pitch"];

	public uint soundId;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public ubyte pitch;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint soundId, uint category=uint.init, Tuple!(int, "x", int, "y", int, "z") position=Tuple!(int, "x", int, "y", int, "z").init, float volume=float.init, ubyte pitch=ubyte.init) {
		this.soundId = soundId;
		this.category = category;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(soundId));
		writeBytes(varuint.encode(category));
		writeBigEndianInt(position.x); writeBigEndianInt(position.y); writeBigEndianInt(position.z);
		writeBigEndianFloat(volume);
		writeBigEndianUbyte(pitch);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		soundId=varuint.decode(_buffer, &_index);
		category=varuint.decode(_buffer, &_index);
		position.x=readBigEndianInt(); position.y=readBigEndianInt(); position.z=readBigEndianInt();
		volume=readBigEndianFloat();
		pitch=readBigEndianUbyte();
	}

	public static pure nothrow @safe SoundEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		SoundEffect ret = new SoundEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SoundEffect(soundId: " ~ std.conv.to!string(this.soundId) ~ ", category: " ~ std.conv.to!string(this.category) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ")";
	}

}

class PlayerListHeaderAndFooter : Buffer {

	public enum uint ID = 72;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["header", "footer"];

	public string header;
	public string footer;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string header, string footer=string.init) {
		this.header = header;
		this.footer = footer;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)header.length)); writeString(header);
		writeBytes(varuint.encode(cast(uint)footer.length)); writeString(footer);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint avzv=varuint.decode(_buffer, &_index); header=readString(avzv);
		uint z9dv=varuint.decode(_buffer, &_index); footer=readString(z9dv);
	}

	public static pure nothrow @safe PlayerListHeaderAndFooter fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerListHeaderAndFooter ret = new PlayerListHeaderAndFooter();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerListHeaderAndFooter(header: " ~ std.conv.to!string(this.header) ~ ", footer: " ~ std.conv.to!string(this.footer) ~ ")";
	}

}

class CollectItem : Buffer {

	public enum uint ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["collected", "collector"];

	public uint collected;
	public uint collector;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint collected, uint collector=uint.init) {
		this.collected = collected;
		this.collector = collector;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(collected));
		writeBytes(varuint.encode(collector));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		collected=varuint.decode(_buffer, &_index);
		collector=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe CollectItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		CollectItem ret = new CollectItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CollectItem(collected: " ~ std.conv.to!string(this.collected) ~ ", collector: " ~ std.conv.to!string(this.collector) ~ ")";
	}

}

class EntityTeleport : Buffer {

	public enum uint ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "yaw", "pitch", "onGround"];

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, Tuple!(double, "x", double, "y", double, "z") position=Tuple!(double, "x", double, "y", double, "z").init, ubyte yaw=ubyte.init, ubyte pitch=ubyte.init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianDouble(position.x); writeBigEndianDouble(position.y); writeBigEndianDouble(position.z);
		writeBigEndianUbyte(yaw);
		writeBigEndianUbyte(pitch);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		position.x=readBigEndianDouble(); position.y=readBigEndianDouble(); position.z=readBigEndianDouble();
		yaw=readBigEndianUbyte();
		pitch=readBigEndianUbyte();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe EntityTeleport fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityTeleport ret = new EntityTeleport();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityTeleport(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class EntityProperties : Buffer {

	public enum uint ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "attributes"];

	public uint entityId;
	public sul.protocol.minecraft109.types.Attribute[] attributes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, sul.protocol.minecraft109.types.Attribute[] attributes=(sul.protocol.minecraft109.types.Attribute[]).init) {
		this.entityId = entityId;
		this.attributes = attributes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUint(cast(uint)attributes.length); foreach(yrcldrc;attributes){ yrcldrc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		attributes.length=readBigEndianUint(); foreach(ref yrcldrc;attributes){ yrcldrc.decode(bufferInstance); }
	}

	public static pure nothrow @safe EntityProperties fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityProperties ret = new EntityProperties();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityProperties(entityId: " ~ std.conv.to!string(this.entityId) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ")";
	}

}

class EntityEffect : Buffer {

	public enum uint ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "effectId", "amplifier", "duration", "showParticles"];

	public uint entityId;
	public ubyte effectId;
	public ubyte amplifier;
	public uint duration;
	public bool showParticles;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint entityId, ubyte effectId=ubyte.init, ubyte amplifier=ubyte.init, uint duration=uint.init, bool showParticles=bool.init) {
		this.entityId = entityId;
		this.effectId = effectId;
		this.amplifier = amplifier;
		this.duration = duration;
		this.showParticles = showParticles;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(entityId));
		writeBigEndianUbyte(effectId);
		writeBigEndianUbyte(amplifier);
		writeBytes(varuint.encode(duration));
		writeBigEndianBool(showParticles);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varuint.decode(_buffer, &_index);
		effectId=readBigEndianUbyte();
		amplifier=readBigEndianUbyte();
		duration=varuint.decode(_buffer, &_index);
		showParticles=readBigEndianBool();
	}

	public static pure nothrow @safe EntityEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityEffect ret = new EntityEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", effectId: " ~ std.conv.to!string(this.effectId) ~ ", amplifier: " ~ std.conv.to!string(this.amplifier) ~ ", duration: " ~ std.conv.to!string(this.duration) ~ ", showParticles: " ~ std.conv.to!string(this.showParticles) ~ ")";
	}

}
