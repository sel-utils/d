/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/bedrock160.xml
 */
module sul.protocol.bedrock160.play;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.bedrock160.types;

static if(__traits(compiles, { import sul.metadata.bedrock160; })) import sul.metadata.bedrock160;

alias Packets = TypeTuple!(Login, PlayStatus, ServerToClientHandshake, ClientToServerHandshake, Disconnect, ResourcePacksInfo, ResourcePacksStackPacket, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, InventoryTransaction, MobEquipment, MobArmorEquipment, Interact, BlockPickRequest, EntityPickRequest, PlayerAction, EntityFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, ContainerOpen, ContainerClose, PlayerHotbar, InventoryContent, InventorySlot, ContainerSetData, CraftingData, CraftingEvent, GuiDataPickItem, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCommandsEnabled, SetDifficulty, ChangeDimension, SetPlayerGameType, PlayerList, SimpleEvent, TelemetryEvent, SpawnExperienceOrb, ClientboundMapItemData, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, GameRulesChanged, Camera, BossEvent, ShowCredits, AvailableCommands, CommandRequest, CommandBlockUpdate, UpdateTrade, UpdateEquip, ResourcePackDataInfo, ResourcePackChunkData, ResourcePackChunkRequest, Transfer, PlaySound, StopSound, SetTitle, AddBehaviorTree, StructureBlockUpdate, ShowStoreOffer, PurchaseReceipt, PlayerSkin, SubClientLogin, InitiateWebSocketConnection, SetLastHurtBy, BookEdit, NpcRequest, PhotoTransfer, ModalFormRequest, ModalFormResponse, ServerSettingsRequest, ServerSettingsResponse, ShowProfile, SetDefaultGameType);

class Login : Buffer {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["protocol", "body_"];

	public uint protocol = 160;
	public sul.protocol.bedrock160.types.LoginBody body_;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint protocol, sul.protocol.bedrock160.types.LoginBody body_=sul.protocol.bedrock160.types.LoginBody.init) {
		this.protocol = protocol;
		this.body_ = body_;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(protocol);
		body_.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		protocol=readBigEndianUint();
		body_.decode(bufferInstance);
	}

	public static pure nothrow @safe Login fromBuffer(bool readId=true)(ubyte[] buffer) {
		Login ret = new Login();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Login(protocol: " ~ std.conv.to!string(this.protocol) ~ ", body_: " ~ std.conv.to!string(this.body_) ~ ")";
	}

}

class PlayStatus : Buffer {

	public enum uint ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum uint OK = 0;
	public enum uint OUTDATED_CLIENT = 1;
	public enum uint OUTDATED_SERVER = 2;
	public enum uint SPAWNED = 3;
	public enum uint INVALID_TENANT = 4;
	public enum uint EDITION_MISMATCH_EDU_TO_VANILLA = 5;
	public enum uint EDITION_MISMATCH_VANILLA_TO_EDU = 6;

	public enum string[] FIELDS = ["status"];

	public uint status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint status) {
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBigEndianUint(status);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		status=readBigEndianUint();
	}

	public static pure nothrow @safe PlayStatus fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayStatus ret = new PlayStatus();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayStatus(status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

class ServerToClientHandshake : Buffer {

	public enum uint ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["serverPublicKey", "token"];

	public string serverPublicKey;
	public ubyte[] token;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string serverPublicKey, ubyte[] token=(ubyte[]).init) {
		this.serverPublicKey = serverPublicKey;
		this.token = token;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)serverPublicKey.length)); writeString(serverPublicKey);
		writeBytes(varuint.encode(cast(uint)token.length)); writeBytes(token);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint cvdvuvbl=varuint.decode(_buffer, &_index); serverPublicKey=readString(cvdvuvbl);
		token.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+token.length){ token=_buffer[_index.._index+token.length].dup; _index+=token.length; }
	}

	public static pure nothrow @safe ServerToClientHandshake fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerToClientHandshake ret = new ServerToClientHandshake();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerToClientHandshake(serverPublicKey: " ~ std.conv.to!string(this.serverPublicKey) ~ ", token: " ~ std.conv.to!string(this.token) ~ ")";
	}

}

class ClientToServerHandshake : Buffer {

	public enum uint ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe ClientToServerHandshake fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientToServerHandshake ret = new ClientToServerHandshake();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientToServerHandshake()";
	}

}

class Disconnect : Buffer {

	public enum uint ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hideDisconnectionScreen", "message"];

	public bool hideDisconnectionScreen;
	public string message;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool hideDisconnectionScreen, string message=string.init) {
		this.hideDisconnectionScreen = hideDisconnectionScreen;
		this.message = message;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianBool(hideDisconnectionScreen);
		if(hideDisconnectionScreen==false){ writeBytes(varuint.encode(cast(uint)message.length)); writeString(message); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		hideDisconnectionScreen=readLittleEndianBool();
		if(hideDisconnectionScreen==false){ uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz); }
	}

	public static pure nothrow @safe Disconnect fromBuffer(bool readId=true)(ubyte[] buffer) {
		Disconnect ret = new Disconnect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Disconnect(hideDisconnectionScreen: " ~ std.conv.to!string(this.hideDisconnectionScreen) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
	}

}

class ResourcePacksInfo : Buffer {

	public enum uint ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mustAccept", "behaviourPacks", "resourcePacks"];

	public bool mustAccept;
	public sul.protocol.bedrock160.types.PackWithSize[] behaviourPacks;
	public sul.protocol.bedrock160.types.PackWithSize[] resourcePacks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool mustAccept, sul.protocol.bedrock160.types.PackWithSize[] behaviourPacks=(sul.protocol.bedrock160.types.PackWithSize[]).init, sul.protocol.bedrock160.types.PackWithSize[] resourcePacks=(sul.protocol.bedrock160.types.PackWithSize[]).init) {
		this.mustAccept = mustAccept;
		this.behaviourPacks = behaviourPacks;
		this.resourcePacks = resourcePacks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianBool(mustAccept);
		writeBigEndianUshort(cast(ushort)behaviourPacks.length); foreach(yvyzbvuf;behaviourPacks){ yvyzbvuf.encode(bufferInstance); }
		writeBigEndianUshort(cast(ushort)resourcePacks.length); foreach(cvbvyvyn;resourcePacks){ cvbvyvyn.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		mustAccept=readLittleEndianBool();
		behaviourPacks.length=readBigEndianUshort(); foreach(ref yvyzbvuf;behaviourPacks){ yvyzbvuf.decode(bufferInstance); }
		resourcePacks.length=readBigEndianUshort(); foreach(ref cvbvyvyn;resourcePacks){ cvbvyvyn.decode(bufferInstance); }
	}

	public static pure nothrow @safe ResourcePacksInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePacksInfo ret = new ResourcePacksInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePacksInfo(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
	}

}

class ResourcePacksStackPacket : Buffer {

	public enum uint ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mustAccept", "behaviourPacks", "resourcePacks"];

	public bool mustAccept;
	public sul.protocol.bedrock160.types.Pack[] behaviourPacks;
	public sul.protocol.bedrock160.types.Pack[] resourcePacks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool mustAccept, sul.protocol.bedrock160.types.Pack[] behaviourPacks=(sul.protocol.bedrock160.types.Pack[]).init, sul.protocol.bedrock160.types.Pack[] resourcePacks=(sul.protocol.bedrock160.types.Pack[]).init) {
		this.mustAccept = mustAccept;
		this.behaviourPacks = behaviourPacks;
		this.resourcePacks = resourcePacks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianBool(mustAccept);
		writeBytes(varuint.encode(cast(uint)behaviourPacks.length)); foreach(yvyzbvuf;behaviourPacks){ yvyzbvuf.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)resourcePacks.length)); foreach(cvbvyvyn;resourcePacks){ cvbvyvyn.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		mustAccept=readLittleEndianBool();
		behaviourPacks.length=varuint.decode(_buffer, &_index); foreach(ref yvyzbvuf;behaviourPacks){ yvyzbvuf.decode(bufferInstance); }
		resourcePacks.length=varuint.decode(_buffer, &_index); foreach(ref cvbvyvyn;resourcePacks){ cvbvyvyn.decode(bufferInstance); }
	}

	public static pure nothrow @safe ResourcePacksStackPacket fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePacksStackPacket ret = new ResourcePacksStackPacket();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePacksStackPacket(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
	}

}

class ResourcePackClientResponse : Buffer {

	public enum uint ID = 8;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// status
	public enum ubyte REFUSED = 1;
	public enum ubyte SEND_PACKS = 2;
	public enum ubyte HAVE_ALL_PACKS = 3;
	public enum ubyte COMPLETED = 4;

	public enum string[] FIELDS = ["status", "packIds"];

	public ubyte status;
	public string[] packIds;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte status, string[] packIds=(string[]).init) {
		this.status = status;
		this.packIds = packIds;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(status);
		writeLittleEndianUshort(cast(ushort)packIds.length); foreach(cfalc;packIds){ writeBytes(varuint.encode(cast(uint)cfalc.length)); writeString(cfalc); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		status=readLittleEndianUbyte();
		packIds.length=readLittleEndianUshort(); foreach(ref cfalc;packIds){ uint yzbm=varuint.decode(_buffer, &_index); cfalc=readString(yzbm); }
	}

	public static pure nothrow @safe ResourcePackClientResponse fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackClientResponse ret = new ResourcePackClientResponse();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackClientResponse(status: " ~ std.conv.to!string(this.status) ~ ", packIds: " ~ std.conv.to!string(this.packIds) ~ ")";
	}

}

class Text : Buffer {

	public enum uint ID = 9;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["type", "unknown1"];

	public ubyte type;
	public bool unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte type, bool unknown1=bool.init) {
		this.type = type;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(type);
		writeLittleEndianBool(unknown1);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		type=readLittleEndianUbyte();
		unknown1=readLittleEndianBool();
	}

	public static pure nothrow @safe Text fromBuffer(bool readId=true)(ubyte[] buffer) {
		Text ret = new Text();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Text(type: " ~ std.conv.to!string(this.type) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "type";

	alias Variants = TypeTuple!(Raw, Chat, Translation, Popup, JukeboxPopup, Tip, System, Whisper, Announcement);

	public class Raw {

		public enum typeof(type) TYPE = 0;

		public enum string[] FIELDS = ["message", "xuid"];

		public string message;
		public string xuid;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message, string xuid=string.init) {
			this.message = message;
			this.xuid = xuid;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)xuid.length)); writeString(xuid);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
			uint evz=varuint.decode(_buffer, &_index); xuid=readString(evz);
		}

		public override string toString() {
			return "Text.Raw(message: " ~ std.conv.to!string(this.message) ~ ", xuid: " ~ std.conv.to!string(this.xuid) ~ ")";
		}

	}

	public class Chat {

		public enum typeof(type) TYPE = 1;

		public enum string[] FIELDS = ["sender", "message", "xuid"];

		public string sender;
		public string message;
		public string xuid;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init, string xuid=string.init) {
			this.sender = sender;
			this.message = message;
			this.xuid = xuid;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)xuid.length)); writeString(xuid);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint cvzv=varuint.decode(_buffer, &_index); sender=readString(cvzv);
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
			uint evz=varuint.decode(_buffer, &_index); xuid=readString(evz);
		}

		public override string toString() {
			return "Text.Chat(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ", xuid: " ~ std.conv.to!string(this.xuid) ~ ")";
		}

	}

	public class Translation {

		public enum typeof(type) TYPE = 2;

		public enum string[] FIELDS = ["message", "parameters"];

		public string message;
		public string[] parameters;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message, string[] parameters=(string[]).init) {
			this.message = message;
			this.parameters = parameters;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 2;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)parameters.length)); foreach(cfy1dvc;parameters){ writeBytes(varuint.encode(cast(uint)cfy1dvc.length)); writeString(cfy1dvc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
			parameters.length=varuint.decode(_buffer, &_index); foreach(ref cfy1dvc;parameters){ uint yzmry=varuint.decode(_buffer, &_index); cfy1dvc=readString(yzmry); }
		}

		public override string toString() {
			return "Text.Translation(message: " ~ std.conv.to!string(this.message) ~ ", parameters: " ~ std.conv.to!string(this.parameters) ~ ")";
		}

	}

	public class Popup {

		public enum typeof(type) TYPE = 3;

		public enum string[] FIELDS = ["title", "subtitle"];

		public string title;
		public string subtitle;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title, string subtitle=string.init) {
			this.title = title;
			this.subtitle = subtitle;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			writeBytes(varuint.encode(cast(uint)subtitle.length)); writeString(subtitle);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
			uint cvdlbu=varuint.decode(_buffer, &_index); subtitle=readString(cvdlbu);
		}

		public override string toString() {
			return "Text.Popup(title: " ~ std.conv.to!string(this.title) ~ ", subtitle: " ~ std.conv.to!string(this.subtitle) ~ ")";
		}

	}

	public class JukeboxPopup {

		public enum typeof(type) TYPE = 4;

		public enum string[] FIELDS = ["message", "parameters"];

		public string message;
		public string[] parameters;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message, string[] parameters=(string[]).init) {
			this.message = message;
			this.parameters = parameters;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)parameters.length)); foreach(cfy1dvc;parameters){ writeBytes(varuint.encode(cast(uint)cfy1dvc.length)); writeString(cfy1dvc); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
			parameters.length=varuint.decode(_buffer, &_index); foreach(ref cfy1dvc;parameters){ uint yzmry=varuint.decode(_buffer, &_index); cfy1dvc=readString(yzmry); }
		}

		public override string toString() {
			return "Text.JukeboxPopup(message: " ~ std.conv.to!string(this.message) ~ ", parameters: " ~ std.conv.to!string(this.parameters) ~ ")";
		}

	}

	public class Tip {

		public enum typeof(type) TYPE = 5;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 5;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Tip(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class System {

		public enum typeof(type) TYPE = 6;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 6;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.System(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class Whisper {

		public enum typeof(type) TYPE = 7;

		public enum string[] FIELDS = ["sender", "message"];

		public string sender;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init) {
			this.sender = sender;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 7;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint cvzv=varuint.decode(_buffer, &_index); sender=readString(cvzv);
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Whisper(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class Announcement {

		public enum typeof(type) TYPE = 8;

		public enum string[] FIELDS = ["announcer", "message"];

		public string announcer;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string announcer, string message=string.init) {
			this.announcer = announcer;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 8;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)announcer.length)); writeString(announcer);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint y5bvyv=varuint.decode(_buffer, &_index); announcer=readString(y5bvyv);
			uint bvcfz=varuint.decode(_buffer, &_index); message=readString(bvcfz);
		}

		public override string toString() {
			return "Text.Announcement(announcer: " ~ std.conv.to!string(this.announcer) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

}

class SetTime : Buffer {

	public enum uint ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["time"];

	public int time;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int time) {
		this.time = time;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(time));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		time=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetTime fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetTime ret = new SetTime();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetTime(time: " ~ std.conv.to!string(this.time) ~ ")";
	}

}

class StartGame : Buffer {

	public enum uint ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;
	public enum int ADVENTURE = 2;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	// generator
	public enum int OLD = 0;
	public enum int INFINITE = 1;
	public enum int FLAT = 2;

	// difficulty
	public enum int PEACEFUL = 0;
	public enum int EASY = 1;
	public enum int NORMAL = 2;
	public enum int HARD = 3;

	// version
	public enum ubyte VANILLA = 0;
	public enum ubyte EDUCATION = 1;

	public enum string[] FIELDS = ["entityId", "runtimeId", "gamemode", "position", "yaw", "pitch", "seed", "dimension", "generator", "worldGamemode", "difficulty", "spawnPosition", "loadedInCreative", "time", "vers", "rainLevel", "lightningLevel", "multiplayerGame", "broadcastToLan", "broadcastToXbl", "commandsEnabled", "textureRequired", "gameRules", "bonusChestEnabled", "startWithMapEnabled", "trustPlayersEnabled", "permissionLevel", "unknown27", "levelId", "worldName", "premiumWorldTemplate", "unknown31", "worldTicks", "unknown33"];

	public long entityId;
	public ulong runtimeId;
	public int gamemode;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float yaw;
	public float pitch;
	public int seed;
	public int dimension = 0;
	public int generator = 1;
	public int worldGamemode;
	public int difficulty;
	public Tuple!(int, "x", int, "y", int, "z") spawnPosition;
	public bool loadedInCreative;
	public int time;
	public ubyte vers;
	public float rainLevel;
	public float lightningLevel;
	public bool multiplayerGame = true;
	public bool broadcastToLan;
	public bool broadcastToXbl;
	public bool commandsEnabled;
	public bool textureRequired;
	public sul.protocol.bedrock160.types.Rule[] gameRules;
	public bool bonusChestEnabled;
	public bool startWithMapEnabled;
	public bool trustPlayersEnabled;
	public int permissionLevel;
	public int unknown27;
	public string levelId;
	public string worldName;
	public string premiumWorldTemplate;
	public bool unknown31;
	public ulong worldTicks;
	public int unknown33;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ulong runtimeId=ulong.init, int gamemode=int.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float yaw=float.init, float pitch=float.init, int seed=int.init, int dimension=0, int generator=1, int worldGamemode=int.init, int difficulty=int.init, Tuple!(int, "x", int, "y", int, "z") spawnPosition=Tuple!(int, "x", int, "y", int, "z").init, bool loadedInCreative=bool.init, int time=int.init, ubyte vers=ubyte.init, float rainLevel=float.init, float lightningLevel=float.init, bool multiplayerGame=true, bool broadcastToLan=bool.init, bool broadcastToXbl=bool.init, bool commandsEnabled=bool.init, bool textureRequired=bool.init, sul.protocol.bedrock160.types.Rule[] gameRules=(sul.protocol.bedrock160.types.Rule[]).init, bool bonusChestEnabled=bool.init, bool startWithMapEnabled=bool.init, bool trustPlayersEnabled=bool.init, int permissionLevel=int.init, int unknown27=int.init, string levelId=string.init, string worldName=string.init, string premiumWorldTemplate=string.init, bool unknown31=bool.init, ulong worldTicks=ulong.init, int unknown33=int.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.gamemode = gamemode;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.seed = seed;
		this.dimension = dimension;
		this.generator = generator;
		this.worldGamemode = worldGamemode;
		this.difficulty = difficulty;
		this.spawnPosition = spawnPosition;
		this.loadedInCreative = loadedInCreative;
		this.time = time;
		this.vers = vers;
		this.rainLevel = rainLevel;
		this.lightningLevel = lightningLevel;
		this.multiplayerGame = multiplayerGame;
		this.broadcastToLan = broadcastToLan;
		this.broadcastToXbl = broadcastToXbl;
		this.commandsEnabled = commandsEnabled;
		this.textureRequired = textureRequired;
		this.gameRules = gameRules;
		this.bonusChestEnabled = bonusChestEnabled;
		this.startWithMapEnabled = startWithMapEnabled;
		this.trustPlayersEnabled = trustPlayersEnabled;
		this.permissionLevel = permissionLevel;
		this.unknown27 = unknown27;
		this.levelId = levelId;
		this.worldName = worldName;
		this.premiumWorldTemplate = premiumWorldTemplate;
		this.unknown31 = unknown31;
		this.worldTicks = worldTicks;
		this.unknown33 = unknown33;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		writeBytes(varint.encode(gamemode));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(yaw);
		writeLittleEndianFloat(pitch);
		writeBytes(varint.encode(seed));
		writeBytes(varint.encode(dimension));
		writeBytes(varint.encode(generator));
		writeBytes(varint.encode(worldGamemode));
		writeBytes(varint.encode(difficulty));
		writeBytes(varint.encode(spawnPosition.x)); writeBytes(varint.encode(spawnPosition.y)); writeBytes(varint.encode(spawnPosition.z));
		writeLittleEndianBool(loadedInCreative);
		writeBytes(varint.encode(time));
		writeLittleEndianUbyte(vers);
		writeLittleEndianFloat(rainLevel);
		writeLittleEndianFloat(lightningLevel);
		writeLittleEndianBool(multiplayerGame);
		writeLittleEndianBool(broadcastToLan);
		writeLittleEndianBool(broadcastToXbl);
		writeLittleEndianBool(commandsEnabled);
		writeLittleEndianBool(textureRequired);
		writeBytes(varuint.encode(cast(uint)gameRules.length)); foreach(zfzjbv;gameRules){ zfzjbv.encode(bufferInstance); }
		writeLittleEndianBool(bonusChestEnabled);
		writeLittleEndianBool(startWithMapEnabled);
		writeLittleEndianBool(trustPlayersEnabled);
		writeBytes(varint.encode(permissionLevel));
		writeBytes(varint.encode(unknown27));
		writeBytes(varuint.encode(cast(uint)levelId.length)); writeString(levelId);
		writeBytes(varuint.encode(cast(uint)worldName.length)); writeString(worldName);
		writeBytes(varuint.encode(cast(uint)premiumWorldTemplate.length)); writeString(premiumWorldTemplate);
		writeLittleEndianBool(unknown31);
		writeLittleEndianUlong(worldTicks);
		writeBytes(varint.encode(unknown33));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		gamemode=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		seed=varint.decode(_buffer, &_index);
		dimension=varint.decode(_buffer, &_index);
		generator=varint.decode(_buffer, &_index);
		worldGamemode=varint.decode(_buffer, &_index);
		difficulty=varint.decode(_buffer, &_index);
		spawnPosition.x=varint.decode(_buffer, &_index); spawnPosition.y=varint.decode(_buffer, &_index); spawnPosition.z=varint.decode(_buffer, &_index);
		loadedInCreative=readLittleEndianBool();
		time=varint.decode(_buffer, &_index);
		vers=readLittleEndianUbyte();
		rainLevel=readLittleEndianFloat();
		lightningLevel=readLittleEndianFloat();
		multiplayerGame=readLittleEndianBool();
		broadcastToLan=readLittleEndianBool();
		broadcastToXbl=readLittleEndianBool();
		commandsEnabled=readLittleEndianBool();
		textureRequired=readLittleEndianBool();
		gameRules.length=varuint.decode(_buffer, &_index); foreach(ref zfzjbv;gameRules){ zfzjbv.decode(bufferInstance); }
		bonusChestEnabled=readLittleEndianBool();
		startWithMapEnabled=readLittleEndianBool();
		trustPlayersEnabled=readLittleEndianBool();
		permissionLevel=varint.decode(_buffer, &_index);
		unknown27=varint.decode(_buffer, &_index);
		uint bvzxz=varuint.decode(_buffer, &_index); levelId=readString(bvzxz);
		uint d9bry1=varuint.decode(_buffer, &_index); worldName=readString(d9bry1);
		uint cjblbdcx=varuint.decode(_buffer, &_index); premiumWorldTemplate=readString(cjblbdcx);
		unknown31=readLittleEndianBool();
		worldTicks=readLittleEndianUlong();
		unknown33=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe StartGame fromBuffer(bool readId=true)(ubyte[] buffer) {
		StartGame ret = new StartGame();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "StartGame(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", gamemode: " ~ std.conv.to!string(this.gamemode) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", seed: " ~ std.conv.to!string(this.seed) ~ ", dimension: " ~ std.conv.to!string(this.dimension) ~ ", generator: " ~ std.conv.to!string(this.generator) ~ ", worldGamemode: " ~ std.conv.to!string(this.worldGamemode) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", spawnPosition: " ~ std.conv.to!string(this.spawnPosition) ~ ", loadedInCreative: " ~ std.conv.to!string(this.loadedInCreative) ~ ", time: " ~ std.conv.to!string(this.time) ~ ", vers: " ~ std.conv.to!string(this.vers) ~ ", rainLevel: " ~ std.conv.to!string(this.rainLevel) ~ ", lightningLevel: " ~ std.conv.to!string(this.lightningLevel) ~ ", multiplayerGame: " ~ std.conv.to!string(this.multiplayerGame) ~ ", broadcastToLan: " ~ std.conv.to!string(this.broadcastToLan) ~ ", broadcastToXbl: " ~ std.conv.to!string(this.broadcastToXbl) ~ ", commandsEnabled: " ~ std.conv.to!string(this.commandsEnabled) ~ ", textureRequired: " ~ std.conv.to!string(this.textureRequired) ~ ", gameRules: " ~ std.conv.to!string(this.gameRules) ~ ", bonusChestEnabled: " ~ std.conv.to!string(this.bonusChestEnabled) ~ ", startWithMapEnabled: " ~ std.conv.to!string(this.startWithMapEnabled) ~ ", trustPlayersEnabled: " ~ std.conv.to!string(this.trustPlayersEnabled) ~ ", permissionLevel: " ~ std.conv.to!string(this.permissionLevel) ~ ", unknown27: " ~ std.conv.to!string(this.unknown27) ~ ", levelId: " ~ std.conv.to!string(this.levelId) ~ ", worldName: " ~ std.conv.to!string(this.worldName) ~ ", premiumWorldTemplate: " ~ std.conv.to!string(this.premiumWorldTemplate) ~ ", unknown31: " ~ std.conv.to!string(this.unknown31) ~ ", worldTicks: " ~ std.conv.to!string(this.worldTicks) ~ ", unknown33: " ~ std.conv.to!string(this.unknown33) ~ ")";
	}

}

class AddPlayer : Buffer {

	public enum uint ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["uuid", "username", "entityId", "runtimeId", "position", "motion", "pitch", "headYaw", "yaw", "heldItem", "metadata", "unknown11", "unknown12", "unknown13", "unknown14", "unknown15", "unknown16", "links"];

	public sul.protocol.bedrock160.types.McpeUuid uuid;
	public string username;
	public long entityId;
	public ulong runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float headYaw;
	public float yaw;
	public sul.protocol.bedrock160.types.Slot heldItem;
	public Metadata metadata;
	public uint unknown11;
	public uint unknown12;
	public uint unknown13;
	public uint unknown14;
	public uint unknown15;
	public long unknown16;
	public sul.protocol.bedrock160.types.Link[] links;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.McpeUuid uuid, string username=string.init, long entityId=long.init, ulong runtimeId=ulong.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, sul.protocol.bedrock160.types.Slot heldItem=sul.protocol.bedrock160.types.Slot.init, Metadata metadata=Metadata.init, uint unknown11=uint.init, uint unknown12=uint.init, uint unknown13=uint.init, uint unknown14=uint.init, uint unknown15=uint.init, long unknown16=long.init, sul.protocol.bedrock160.types.Link[] links=(sul.protocol.bedrock160.types.Link[]).init) {
		this.uuid = uuid;
		this.username = username;
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.heldItem = heldItem;
		this.metadata = metadata;
		this.unknown11 = unknown11;
		this.unknown12 = unknown12;
		this.unknown13 = unknown13;
		this.unknown14 = unknown14;
		this.unknown15 = unknown15;
		this.unknown16 = unknown16;
		this.links = links;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		uuid.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)username.length)); writeString(username);
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		heldItem.encode(bufferInstance);
		metadata.encode(bufferInstance);
		writeBytes(varuint.encode(unknown11));
		writeBytes(varuint.encode(unknown12));
		writeBytes(varuint.encode(unknown13));
		writeBytes(varuint.encode(unknown14));
		writeBytes(varuint.encode(unknown15));
		writeLittleEndianLong(unknown16);
		writeBytes(varuint.encode(cast(uint)links.length)); foreach(blam;links){ blam.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uuid.decode(bufferInstance);
		uint dnc5bu=varuint.decode(_buffer, &_index); username=readString(dnc5bu);
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		heldItem.decode(bufferInstance);
		metadata=Metadata.decode(bufferInstance);
		unknown11=varuint.decode(_buffer, &_index);
		unknown12=varuint.decode(_buffer, &_index);
		unknown13=varuint.decode(_buffer, &_index);
		unknown14=varuint.decode(_buffer, &_index);
		unknown15=varuint.decode(_buffer, &_index);
		unknown16=readLittleEndianLong();
		links.length=varuint.decode(_buffer, &_index); foreach(ref blam;links){ blam.decode(bufferInstance); }
	}

	public static pure nothrow @safe AddPlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPlayer ret = new AddPlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPlayer(uuid: " ~ std.conv.to!string(this.uuid) ~ ", username: " ~ std.conv.to!string(this.username) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", heldItem: " ~ std.conv.to!string(this.heldItem) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ", unknown11: " ~ std.conv.to!string(this.unknown11) ~ ", unknown12: " ~ std.conv.to!string(this.unknown12) ~ ", unknown13: " ~ std.conv.to!string(this.unknown13) ~ ", unknown14: " ~ std.conv.to!string(this.unknown14) ~ ", unknown15: " ~ std.conv.to!string(this.unknown15) ~ ", unknown16: " ~ std.conv.to!string(this.unknown16) ~ ", links: " ~ std.conv.to!string(this.links) ~ ")";
	}

}

class AddEntity : Buffer {

	public enum uint ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "type", "position", "motion", "pitch", "yaw", "attributes", "metadata", "links"];

	public long entityId;
	public ulong runtimeId;
	public uint type;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float yaw;
	public sul.protocol.bedrock160.types.Attribute[] attributes;
	public Metadata metadata;
	public sul.protocol.bedrock160.types.Link[] links;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ulong runtimeId=ulong.init, uint type=uint.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float yaw=float.init, sul.protocol.bedrock160.types.Attribute[] attributes=(sul.protocol.bedrock160.types.Attribute[]).init, Metadata metadata=Metadata.init, sul.protocol.bedrock160.types.Link[] links=(sul.protocol.bedrock160.types.Link[]).init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.type = type;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.yaw = yaw;
		this.attributes = attributes;
		this.metadata = metadata;
		this.links = links;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		writeBytes(varuint.encode(type));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(yaw);
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yrcldrc;attributes){ yrcldrc.encode(bufferInstance); }
		metadata.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)links.length)); foreach(blam;links){ blam.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		type=varuint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yrcldrc;attributes){ yrcldrc.decode(bufferInstance); }
		metadata=Metadata.decode(bufferInstance);
		links.length=varuint.decode(_buffer, &_index); foreach(ref blam;links){ blam.decode(bufferInstance); }
	}

	public static pure nothrow @safe AddEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddEntity ret = new AddEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ", links: " ~ std.conv.to!string(this.links) ~ ")";
	}

}

class RemoveEntity : Buffer {

	public enum uint ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId"];

	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId) {
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RemoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveEntity ret = new RemoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class AddItemEntity : Buffer {

	public enum uint ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "item", "position", "motion", "metadata"];

	public long entityId;
	public ulong runtimeId;
	public sul.protocol.bedrock160.types.Slot item;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ulong runtimeId=ulong.init, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.item = item;
		this.position = position;
		this.motion = motion;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		item.encode(bufferInstance);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe AddItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddItemEntity ret = new AddItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddItemEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class AddHangingEntity : Buffer {

	public enum uint ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "unknown3"];

	public long entityId;
	public ulong runtimeId;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public int unknown3;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ulong runtimeId=ulong.init, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, int unknown3=int.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.unknown3 = unknown3;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(unknown3));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		unknown3=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe AddHangingEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddHangingEntity ret = new AddHangingEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddHangingEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ")";
	}

}

class TakeItemEntity : Buffer {

	public enum uint ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["collected", "collector"];

	public long collected;
	public long collector;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long collected, long collector=long.init) {
		this.collected = collected;
		this.collector = collector;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(collected));
		writeBytes(varlong.encode(collector));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		collected=varlong.decode(_buffer, &_index);
		collector=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TakeItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		TakeItemEntity ret = new TakeItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TakeItemEntity(collected: " ~ std.conv.to!string(this.collected) ~ ", collector: " ~ std.conv.to!string(this.collector) ~ ")";
	}

}

class MoveEntity : Buffer {

	public enum uint ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw", "onGround", "teleported"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public ubyte pitch;
	public ubyte headYaw;
	public ubyte yaw;
	public bool onGround;
	public bool teleported;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, ubyte pitch=ubyte.init, ubyte headYaw=ubyte.init, ubyte yaw=ubyte.init, bool onGround=bool.init, bool teleported=bool.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.onGround = onGround;
		this.teleported = teleported;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianUbyte(pitch);
		writeLittleEndianUbyte(headYaw);
		writeLittleEndianUbyte(yaw);
		writeLittleEndianBool(onGround);
		writeLittleEndianBool(teleported);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readLittleEndianUbyte();
		headYaw=readLittleEndianUbyte();
		yaw=readLittleEndianUbyte();
		onGround=readLittleEndianBool();
		teleported=readLittleEndianBool();
	}

	public static pure nothrow @safe MoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		MoveEntity ret = new MoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ", teleported: " ~ std.conv.to!string(this.teleported) ~ ")";
	}

}

class MovePlayer : Buffer {

	public enum uint ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// animation
	public enum ubyte FULL = 0;
	public enum ubyte NONE = 1;
	public enum ubyte TELEPORT = 2;
	public enum ubyte PITCH = 3;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw", "animation", "onGround", "unknown7", "unknown8", "unknown9"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;
	public ubyte animation;
	public bool onGround;
	public long unknown7;
	public int unknown8;
	public int unknown9;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, ubyte animation=ubyte.init, bool onGround=bool.init, long unknown7=long.init, int unknown8=int.init, int unknown9=int.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.animation = animation;
		this.onGround = onGround;
		this.unknown7 = unknown7;
		this.unknown8 = unknown8;
		this.unknown9 = unknown9;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		writeLittleEndianUbyte(animation);
		writeLittleEndianBool(onGround);
		writeBytes(varlong.encode(unknown7));
		if(animation==3){ writeLittleEndianInt(unknown8); }
		if(animation==3){ writeLittleEndianInt(unknown9); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		animation=readLittleEndianUbyte();
		onGround=readLittleEndianBool();
		unknown7=varlong.decode(_buffer, &_index);
		if(animation==3){ unknown8=readLittleEndianInt(); }
		if(animation==3){ unknown9=readLittleEndianInt(); }
	}

	public static pure nothrow @safe MovePlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		MovePlayer ret = new MovePlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MovePlayer(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", animation: " ~ std.conv.to!string(this.animation) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ", unknown7: " ~ std.conv.to!string(this.unknown7) ~ ", unknown8: " ~ std.conv.to!string(this.unknown8) ~ ", unknown9: " ~ std.conv.to!string(this.unknown9) ~ ")";
	}

}

class RiderJump : Buffer {

	public enum uint ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["rider"];

	public long rider;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long rider) {
		this.rider = rider;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(rider));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		rider=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RiderJump fromBuffer(bool readId=true)(ubyte[] buffer) {
		RiderJump ret = new RiderJump();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RiderJump(rider: " ~ std.conv.to!string(this.rider) ~ ")";
	}

}

class UpdateBlock : Buffer {

	public enum uint ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags and meta
	public enum uint NEIGHBORS = 1;
	public enum uint NETWORK = 2;
	public enum uint NO_GRAPHIC = 4;
	public enum uint PRIORITY = 8;

	public enum string[] FIELDS = ["position", "block", "flagsAndMeta"];

	public sul.protocol.bedrock160.types.BlockPosition position;
	public uint block;
	public uint flagsAndMeta;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.BlockPosition position, uint block=uint.init, uint flagsAndMeta=uint.init) {
		this.position = position;
		this.block = block;
		this.flagsAndMeta = flagsAndMeta;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		position.encode(bufferInstance);
		writeBytes(varuint.encode(block));
		writeBytes(varuint.encode(flagsAndMeta));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.decode(bufferInstance);
		block=varuint.decode(_buffer, &_index);
		flagsAndMeta=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe UpdateBlock fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateBlock ret = new UpdateBlock();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateBlock(position: " ~ std.conv.to!string(this.position) ~ ", block: " ~ std.conv.to!string(this.block) ~ ", flagsAndMeta: " ~ std.conv.to!string(this.flagsAndMeta) ~ ")";
	}

}

class AddPainting : Buffer {

	public enum uint ID = 22;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "direction", "title"];

	public long entityId;
	public ulong runtimeId;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public int direction;
	public string title;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ulong runtimeId=ulong.init, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, int direction=int.init, string title=string.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.direction = direction;
		this.title = title;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varulong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(direction));
		writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varulong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		direction=varint.decode(_buffer, &_index);
		uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
	}

	public static pure nothrow @safe AddPainting fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPainting ret = new AddPainting();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPainting(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ", title: " ~ std.conv.to!string(this.title) ~ ")";
	}

}

class Explode : Buffer {

	public enum uint ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "radius", "destroyedBlocks"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public sul.protocol.bedrock160.types.BlockPosition[] destroyedBlocks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, float radius=float.init, sul.protocol.bedrock160.types.BlockPosition[] destroyedBlocks=(sul.protocol.bedrock160.types.BlockPosition[]).init) {
		this.position = position;
		this.radius = radius;
		this.destroyedBlocks = destroyedBlocks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(radius);
		writeBytes(varuint.encode(cast(uint)destroyedBlocks.length)); foreach(zvdjevqx;destroyedBlocks){ zvdjevqx.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		radius=readLittleEndianFloat();
		destroyedBlocks.length=varuint.decode(_buffer, &_index); foreach(ref zvdjevqx;destroyedBlocks){ zvdjevqx.decode(bufferInstance); }
	}

	public static pure nothrow @safe Explode fromBuffer(bool readId=true)(ubyte[] buffer) {
		Explode ret = new Explode();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Explode(position: " ~ std.conv.to!string(this.position) ~ ", radius: " ~ std.conv.to!string(this.radius) ~ ", destroyedBlocks: " ~ std.conv.to!string(this.destroyedBlocks) ~ ")";
	}

}

class LevelSoundEvent : Buffer {

	public enum uint ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// sound
	public enum ubyte ITEM_USE_ON = 0;
	public enum ubyte HIT = 1;
	public enum ubyte STEP = 2;
	public enum ubyte FLY = 3;
	public enum ubyte JUMP = 4;
	public enum ubyte BREAK = 5;
	public enum ubyte PLACE = 6;
	public enum ubyte HEAVY_STEP = 7;
	public enum ubyte GALLOP = 8;
	public enum ubyte FALL = 9;
	public enum ubyte AMBIENT = 10;
	public enum ubyte AMBIENT_BABY = 11;
	public enum ubyte AMBIENT_IN_WATER = 12;
	public enum ubyte BREATHE = 13;
	public enum ubyte DEATH = 14;
	public enum ubyte DEATH_IN_WATER = 15;
	public enum ubyte DEATH_TO_ZOMBIE = 16;
	public enum ubyte HURT = 17;
	public enum ubyte HURT_IN_WATER = 18;
	public enum ubyte MAD = 19;
	public enum ubyte BOOST = 20;
	public enum ubyte BOW = 21;
	public enum ubyte SQUISH_BIG = 22;
	public enum ubyte SQUISH_SMALL = 23;
	public enum ubyte FALL_BIG = 24;
	public enum ubyte FALL_SMALL = 25;
	public enum ubyte SPLASH = 26;
	public enum ubyte FIZZ = 27;
	public enum ubyte FLAP = 28;
	public enum ubyte SWIM = 29;
	public enum ubyte DRINK = 30;
	public enum ubyte EAT = 31;
	public enum ubyte TAKEOFF = 32;
	public enum ubyte SHAKE = 33;
	public enum ubyte PLOP = 34;
	public enum ubyte LAND = 35;
	public enum ubyte SADDLE = 36;
	public enum ubyte ARMOR = 37;
	public enum ubyte ADD_CHEST = 38;
	public enum ubyte THROW = 39;
	public enum ubyte ATTACK = 40;
	public enum ubyte ATTACK_NODAMAGE = 41;
	public enum ubyte ATTACK_STRONG = 42;
	public enum ubyte WARN = 43;
	public enum ubyte SHEAR = 44;
	public enum ubyte MILK = 45;
	public enum ubyte THUNDER = 46;
	public enum ubyte EXPLODE = 47;
	public enum ubyte FIRE = 48;
	public enum ubyte IGNITE = 49;
	public enum ubyte FUSE = 50;
	public enum ubyte STARE = 51;
	public enum ubyte SPAWN = 52;
	public enum ubyte SHOOT = 53;
	public enum ubyte BREAK_BLOCK = 54;
	public enum ubyte LAUNCH = 55;
	public enum ubyte BLAST = 56;
	public enum ubyte LARGE_BLAST = 57;
	public enum ubyte TWINKLE = 58;
	public enum ubyte REMEDY = 59;
	public enum ubyte UNFECT = 60;
	public enum ubyte LEVELUP = 61;
	public enum ubyte BOW_HIT = 62;
	public enum ubyte BULLET_HIT = 63;
	public enum ubyte EXTINGUISH_FIRE = 64;
	public enum ubyte ITEM_FIZZ = 65;
	public enum ubyte CHEST_OPEN = 66;
	public enum ubyte CHEST_CLOSED = 67;
	public enum ubyte SHULKER_BOX_OPEN = 68;
	public enum ubyte SHULKER_BOX_CLOSE = 69;
	public enum ubyte POWER_ON = 70;
	public enum ubyte POWER_OFF = 71;
	public enum ubyte ATTACH = 72;
	public enum ubyte DETACH = 73;
	public enum ubyte DENY = 74;
	public enum ubyte TRIPOD = 75;
	public enum ubyte POP = 76;
	public enum ubyte DROP_SLOT = 77;
	public enum ubyte NOTE = 78;
	public enum ubyte THORNS = 79;
	public enum ubyte PISTON_IN = 80;
	public enum ubyte PISTON_OUT = 81;
	public enum ubyte PORTAL = 82;
	public enum ubyte WATER = 83;
	public enum ubyte LAVA_POP = 84;
	public enum ubyte LAVA = 85;
	public enum ubyte BURP = 86;
	public enum ubyte BUCKET_FILL_WATER = 87;
	public enum ubyte BUCKET_FILL_LAVA = 88;
	public enum ubyte BUCKET_EMPTY_WATER = 89;
	public enum ubyte BUCKET_EMPTY_LAVA = 90;
	public enum ubyte RECORD_13 = 91;
	public enum ubyte RECORD_CAT = 92;
	public enum ubyte RECORD_BLOCKS = 93;
	public enum ubyte RECORD_CHIRP = 94;
	public enum ubyte RECORD_FAR = 95;
	public enum ubyte RECORD_MALL = 96;
	public enum ubyte RECORD_MELLOHI = 97;
	public enum ubyte RECORD_STAL = 98;
	public enum ubyte RECORD_STRAD = 99;
	public enum ubyte RECORD_WARD = 100;
	public enum ubyte RECORD_11 = 101;
	public enum ubyte RECORD_WAIT = 102;
	public enum ubyte GUARDIAN_FLOP = 104;
	public enum ubyte ELDERGUARDIAN_CURSE = 105;
	public enum ubyte MOB_WARNING = 106;
	public enum ubyte MOB_WARNING_BABY = 107;
	public enum ubyte TELEPORT = 108;
	public enum ubyte SHULKER_OPEN = 109;
	public enum ubyte SHULKER_CLOSE = 110;
	public enum ubyte HAGGLE = 111;
	public enum ubyte HAGGLE_YES = 112;
	public enum ubyte HAGGLE_NO = 113;
	public enum ubyte HAGGLE_IDLE = 114;
	public enum ubyte CHORUS_GROW = 115;
	public enum ubyte CHORUS_DEATH = 116;
	public enum ubyte GLASS = 117;
	public enum ubyte CAST_SPELL = 118;
	public enum ubyte PREPARE_ATTACK = 119;
	public enum ubyte PREPARE_SUMMON = 120;
	public enum ubyte PREPARE_WOLOLO = 121;
	public enum ubyte FANG = 122;
	public enum ubyte CHARGE = 123;
	public enum ubyte CAMERA_TAKE_PICTURE = 124;
	public enum ubyte LEASHKNOT_PLACE = 125;
	public enum ubyte LEASHKNOT_BREAK = 126;
	public enum ubyte GROWL = 127;
	public enum ubyte WHINE = 128;
	public enum ubyte PANT = 129;
	public enum ubyte PURR = 130;
	public enum ubyte PURREOW = 131;
	public enum ubyte DEATH_MIN_VOLUME = 132;
	public enum ubyte DEATH_MID_VOLUME = 133;
	public enum ubyte INITIATE_BLAZE = 134;
	public enum ubyte INITIATE_CAVE_SPIDER = 135;
	public enum ubyte INITIATE_CREEPER = 136;
	public enum ubyte INITIATE_ELDER_GUARDIAN = 137;
	public enum ubyte INITIATE_ENDER_DRAGON = 138;
	public enum ubyte INITIATE_ENDERMAN = 139;
	public enum ubyte INITIATE_EVOCATION_ILLAGER = 141;
	public enum ubyte INITIATE_GHAST = 142;
	public enum ubyte INITIATE_HUSK = 143;
	public enum ubyte INITIATE_ILLUSION_ILLAGER = 144;
	public enum ubyte INITIATE_MAGMA_CUBE = 145;
	public enum ubyte INITIATE_POLAR_BEAR = 146;
	public enum ubyte INITIATE_SHULKER = 147;
	public enum ubyte INITIATE_SILVERFISH = 148;
	public enum ubyte INITIATE_SKELETON = 149;
	public enum ubyte INITIATE_SLIME = 150;
	public enum ubyte INITIATE_SPIDER = 151;
	public enum ubyte INITIATE_STRAY = 152;
	public enum ubyte INITIATE_VEX = 153;
	public enum ubyte INITIATE_VINDICATION_ILLAGER = 154;
	public enum ubyte INITIATE_WITCH = 155;
	public enum ubyte INITIATE_WITHER = 156;
	public enum ubyte INITIATE_WITHER_SKELETON = 157;
	public enum ubyte INITIATE_WOLF = 158;
	public enum ubyte INITIATE_ZOMBIE = 159;
	public enum ubyte INITIATE_ZOMBIE_PIGMAN = 160;
	public enum ubyte INITIATE_ZOMBIE_VILLAGER = 161;
	public enum ubyte BLOCK_END_PORTAL_FRAME_FILL = 162;
	public enum ubyte BLOCK_END_PORTAL_SPAWN = 163;
	public enum ubyte RANDOM_ANVIL_USE = 164;
	public enum ubyte BOTTLE_DRAGONBREATH = 165;
	public enum ubyte DEFAULT = 166;
	public enum ubyte UNDEFINED = 167;

	public enum string[] FIELDS = ["sound", "position", "volume", "pitch", "unknown4", "disableRelativeVolume"];

	public ubyte sound;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public uint volume;
	public int pitch;
	public bool unknown4;
	public bool disableRelativeVolume;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte sound, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, uint volume=uint.init, int pitch=int.init, bool unknown4=bool.init, bool disableRelativeVolume=bool.init) {
		this.sound = sound;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
		this.unknown4 = unknown4;
		this.disableRelativeVolume = disableRelativeVolume;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(sound);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varuint.encode(volume));
		writeBytes(varint.encode(pitch));
		writeLittleEndianBool(unknown4);
		writeLittleEndianBool(disableRelativeVolume);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		sound=readLittleEndianUbyte();
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		volume=varuint.decode(_buffer, &_index);
		pitch=varint.decode(_buffer, &_index);
		unknown4=readLittleEndianBool();
		disableRelativeVolume=readLittleEndianBool();
	}

	public static pure nothrow @safe LevelSoundEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelSoundEvent ret = new LevelSoundEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelSoundEvent(sound: " ~ std.conv.to!string(this.sound) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ", disableRelativeVolume: " ~ std.conv.to!string(this.disableRelativeVolume) ~ ")";
	}

}

class LevelEvent : Buffer {

	public enum uint ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum int START_RAIN = 3001;
	public enum int START_THUNDER = 3002;
	public enum int STOP_RAIN = 3003;
	public enum int STOP_THUNDER = 3004;
	public enum int START_BLOCK_BREAK = 3600;
	public enum int STOP_BLOCK_BREAK = 3601;
	public enum int SET_DATA = 4000;
	public enum int PLAYERS_SLEEPING = 9800;
	public enum int PARTICLE_BUBBLE = 16385;
	public enum int PARTICLE_CRITICAL = 16386;
	public enum int PARTICLE_BLOCK_FORCE_FIELD = 16387;
	public enum int PARTICLE_SMOKE = 16388;
	public enum int PARTICLE_EXPLODE = 16389;
	public enum int PARTICLE_EVAPORATION = 16390;
	public enum int PARTICLE_FLAME = 16391;
	public enum int PARTICLE_LAVA = 16392;
	public enum int PARTICLE_LARGE_SMOKE = 16393;
	public enum int PARTICLE_REDSTONE = 16394;
	public enum int PARTICLE_RISING_RED_DUST = 16395;
	public enum int PARTICLE_ITEM_BREAK = 16396;
	public enum int PARTICLE_SNOWBALL_POOF = 16397;
	public enum int PARTICLE_HUGE_EXPLODE = 16398;
	public enum int PARTICLE_HUGE_EXPLODE_SEED = 16399;
	public enum int PARTICLE_MOB_FLAME = 16400;
	public enum int PARTICLE_HEART = 16401;
	public enum int PARTICLE_TERRAIN = 16402;
	public enum int PARTICLE_TOWN_AURA = 16403;
	public enum int PARTICLE_PORTAL = 16404;
	public enum int PARTICLE_WATER_SPLASH = 16405;
	public enum int PARTICLE_WATER_WAKE = 16406;
	public enum int PARTICLE_DRIP_WATER = 16407;
	public enum int PARTICLE_DRIP_LAVA = 16408;
	public enum int PARTICLE_FALLING_DUST = 16409;
	public enum int PARTICLE_MOB_SPELL = 16410;
	public enum int PARTICLE_MOB_SPELL_AMBIENT = 16411;
	public enum int PARTICLE_MOB_SPELL_INSTANTANEOUS = 16412;
	public enum int PARTICLE_INK = 16413;
	public enum int PARTICLE_SLIME = 16414;
	public enum int PARTICLE_RAIN_SPLASH = 16415;
	public enum int PARTICLE_VILLAGER_ANGRY = 16416;
	public enum int PARTICLE_VILLAGER_HAPPY = 16417;
	public enum int PARTICLE_ENCHANTMENT_TABLE = 16418;
	public enum int PARTICLE_TRACKING_EMITTER = 16419;
	public enum int PARTICLE_NOTE = 16420;
	public enum int PARTICLE_WITCH_SPELL = 16421;
	public enum int PARTICLE_CARROT = 16422;
	public enum int PARTICLE_END_ROD = 16424;
	public enum int PARTICLE_DRAGON_BREATH = 16425;
	public enum int PARTICLE_SHOOT = 2000;
	public enum int PARTICLE_DESTROY = 2001;
	public enum int PARTICLE_SPLASH = 2002;
	public enum int PARTICLE_EYE_DESPAWN = 2003;
	public enum int PARTICLE_SPAWN = 2004;

	public enum string[] FIELDS = ["eventId", "position", "data"];

	public int eventId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int eventId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, int data=int.init) {
		this.eventId = eventId;
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(eventId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(data));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		eventId=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		data=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe LevelEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelEvent ret = new LevelEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelEvent(eventId: " ~ std.conv.to!string(this.eventId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class BlockEvent : Buffer {

	public enum uint ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data"];

	public sul.protocol.bedrock160.types.BlockPosition position;
	public int[2] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.BlockPosition position, int[2] data=(int[2]).init) {
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		position.encode(bufferInstance);
		foreach(zfy;data){ writeBytes(varint.encode(zfy)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.decode(bufferInstance);
		foreach(ref zfy;data){ zfy=varint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe BlockEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEvent ret = new BlockEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEvent(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class EntityEvent : Buffer {

	public enum uint ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// event id
	public enum ubyte HURT_ANIMATION = 2;
	public enum ubyte DEATH_ANIMATION = 3;
	public enum ubyte ARM_SWING = 4;
	public enum ubyte TAME_FAIL = 6;
	public enum ubyte TAME_SUCCESS = 7;
	public enum ubyte SHAKE_WET = 8;
	public enum ubyte USE_ITEM = 9;
	public enum ubyte EAT_GRASS_ANIMATION = 10;
	public enum ubyte FISH_HOOK_BUBBLES = 11;
	public enum ubyte FISH_HOOK_POSITION = 12;
	public enum ubyte FISH_HOOK_HOOK = 13;
	public enum ubyte FISH_HOOK_TEASE = 14;
	public enum ubyte SQUID_INK_CLOUD = 15;
	public enum ubyte ZOMBIE_VILLAGER_CURE = 16;
	public enum ubyte RESPAWN = 18;
	public enum ubyte IRON_GOLEM_OFFER_FLOWER = 19;
	public enum ubyte IRON_GOLEM_WITHDRAW_FLOWER = 20;
	public enum ubyte LOVE_PARTICLES = 21;
	public enum ubyte WITCH_SPELL_ANIMATION = 24;
	public enum ubyte FIREWORK_PARTICLES = 25;
	public enum ubyte SILVERFISH_SPAWN_ANIMATION = 27;
	public enum ubyte WITCH_DRINK_POTION = 29;
	public enum ubyte WITCH_THROWN_POTION = 30;
	public enum ubyte MINECART_TNT_PRIME_FUSE = 31;
	public enum ubyte PLAYER_ADD_XP_LEVELS = 34;
	public enum ubyte ELDER_GUARDIAN_CURSE = 35;
	public enum ubyte AGENT_ARM_SWING = 36;
	public enum ubyte ENDER_DRAGON_DEATH = 37;
	public enum ubyte DUST_PARTICLES = 38;
	public enum ubyte EATING_ITEM = 57;
	public enum ubyte BABY_ANIMAL_FEED = 60;
	public enum ubyte DEATH_SMOKE_CLOUD = 61;
	public enum ubyte COMPLETE_TRADE = 62;
	public enum ubyte REMOVE_LEASH = 63;
	public enum ubyte CONSUME_TOTEM = 65;
	public enum ubyte ENTITY_SPAWN = 67;
	public enum ubyte DRAGON_PUKE = 68;
	public enum ubyte ITEM_ENTITY_MERGE = 69;

	public enum string[] FIELDS = ["entityId", "eventId", "data"];

	public long entityId;
	public ubyte eventId;
	public int data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int data=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianUbyte(eventId);
		writeBytes(varint.encode(data));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readLittleEndianUbyte();
		data=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe EntityEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityEvent ret = new EntityEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class MobEffect : Buffer {

	public enum uint ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum ubyte ADD = 1;
	public enum ubyte MODIFY = 2;
	public enum ubyte REMOVE = 3;

	public enum string[] FIELDS = ["entityId", "eventId", "effect", "amplifier", "particles", "duration"];

	public long entityId;
	public ubyte eventId;
	public int effect;
	public int amplifier;
	public bool particles;
	public int duration;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int effect=int.init, int amplifier=int.init, bool particles=bool.init, int duration=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.effect = effect;
		this.amplifier = amplifier;
		this.particles = particles;
		this.duration = duration;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianUbyte(eventId);
		writeBytes(varint.encode(effect));
		writeBytes(varint.encode(amplifier));
		writeLittleEndianBool(particles);
		writeBytes(varint.encode(duration));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readLittleEndianUbyte();
		effect=varint.decode(_buffer, &_index);
		amplifier=varint.decode(_buffer, &_index);
		particles=readLittleEndianBool();
		duration=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MobEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEffect ret = new MobEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", effect: " ~ std.conv.to!string(this.effect) ~ ", amplifier: " ~ std.conv.to!string(this.amplifier) ~ ", particles: " ~ std.conv.to!string(this.particles) ~ ", duration: " ~ std.conv.to!string(this.duration) ~ ")";
	}

}

class UpdateAttributes : Buffer {

	public enum uint ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "attributes"];

	public long entityId;
	public sul.protocol.bedrock160.types.Attribute[] attributes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.bedrock160.types.Attribute[] attributes=(sul.protocol.bedrock160.types.Attribute[]).init) {
		this.entityId = entityId;
		this.attributes = attributes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yrcldrc;attributes){ yrcldrc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yrcldrc;attributes){ yrcldrc.decode(bufferInstance); }
	}

	public static pure nothrow @safe UpdateAttributes fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateAttributes ret = new UpdateAttributes();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateAttributes(entityId: " ~ std.conv.to!string(this.entityId) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ")";
	}

}

class InventoryTransaction : Buffer {

	public enum uint ID = 30;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["type", "actions"];

	public uint type;
	public sul.protocol.bedrock160.types.InventoryAction[] actions;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint type, sul.protocol.bedrock160.types.InventoryAction[] actions=(sul.protocol.bedrock160.types.InventoryAction[]).init) {
		this.type = type;
		this.actions = actions;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(type));
		writeBytes(varuint.encode(cast(uint)actions.length)); foreach(yna9c;actions){ yna9c.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		type=varuint.decode(_buffer, &_index);
		actions.length=varuint.decode(_buffer, &_index); foreach(ref yna9c;actions){ yna9c.decode(bufferInstance); }
	}

	public static pure nothrow @safe InventoryTransaction fromBuffer(bool readId=true)(ubyte[] buffer) {
		InventoryTransaction ret = new InventoryTransaction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InventoryTransaction(type: " ~ std.conv.to!string(this.type) ~ ", actions: " ~ std.conv.to!string(this.actions) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "type";

	alias Variants = TypeTuple!(Normal0, Normal1, UseItem, UseItemOnEntity, ReleaseItem);

	public class Normal0 {

		public enum typeof(type) TYPE = 0;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 0;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "InventoryTransaction.Normal0()";
		}

	}

	public class Normal1 {

		public enum typeof(type) TYPE = 1;

		public enum string[] FIELDS = [];

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 1;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

		public override string toString() {
			return "InventoryTransaction.Normal1()";
		}

	}

	public class UseItem {

		public enum typeof(type) TYPE = 2;

		// action type
		public enum uint CLICK_BLOCK = 0;
		public enum uint CLICK_AIR = 1;
		public enum uint BREAK_BLOCK = 2;

		public enum string[] FIELDS = ["actionType", "blockPosition", "face", "hotbarSlot", "item", "playerPosition", "clickPosition"];

		public uint actionType;
		public sul.protocol.bedrock160.types.BlockPosition blockPosition;
		public int face;
		public int hotbarSlot;
		public sul.protocol.bedrock160.types.Slot item;
		public Tuple!(float, "x", float, "y", float, "z") playerPosition;
		public Tuple!(float, "x", float, "y", float, "z") clickPosition;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint actionType, sul.protocol.bedrock160.types.BlockPosition blockPosition=sul.protocol.bedrock160.types.BlockPosition.init, int face=int.init, int hotbarSlot=int.init, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") playerPosition=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") clickPosition=Tuple!(float, "x", float, "y", float, "z").init) {
			this.actionType = actionType;
			this.blockPosition = blockPosition;
			this.face = face;
			this.hotbarSlot = hotbarSlot;
			this.item = item;
			this.playerPosition = playerPosition;
			this.clickPosition = clickPosition;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 2;
			_encode!writeId();
			writeBytes(varuint.encode(actionType));
			blockPosition.encode(bufferInstance);
			writeBytes(varint.encode(face));
			writeBytes(varint.encode(hotbarSlot));
			item.encode(bufferInstance);
			writeLittleEndianFloat(playerPosition.x); writeLittleEndianFloat(playerPosition.y); writeLittleEndianFloat(playerPosition.z);
			writeLittleEndianFloat(clickPosition.x); writeLittleEndianFloat(clickPosition.y); writeLittleEndianFloat(clickPosition.z);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			actionType=varuint.decode(_buffer, &_index);
			blockPosition.decode(bufferInstance);
			face=varint.decode(_buffer, &_index);
			hotbarSlot=varint.decode(_buffer, &_index);
			item.decode(bufferInstance);
			playerPosition.x=readLittleEndianFloat(); playerPosition.y=readLittleEndianFloat(); playerPosition.z=readLittleEndianFloat();
			clickPosition.x=readLittleEndianFloat(); clickPosition.y=readLittleEndianFloat(); clickPosition.z=readLittleEndianFloat();
		}

		public override string toString() {
			return "InventoryTransaction.UseItem(actionType: " ~ std.conv.to!string(this.actionType) ~ ", blockPosition: " ~ std.conv.to!string(this.blockPosition) ~ ", face: " ~ std.conv.to!string(this.face) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", playerPosition: " ~ std.conv.to!string(this.playerPosition) ~ ", clickPosition: " ~ std.conv.to!string(this.clickPosition) ~ ")";
		}

	}

	public class UseItemOnEntity {

		public enum typeof(type) TYPE = 3;

		// action type
		public enum uint INTERACT = 0;
		public enum uint ATTACK = 1;

		public enum string[] FIELDS = ["entityId", "actionType", "hotbarSlot", "item", "unknown4", "unknown5"];

		public long entityId;
		public uint actionType;
		public int hotbarSlot;
		public sul.protocol.bedrock160.types.Slot item;
		public Tuple!(float, "x", float, "y", float, "z") unknown4;
		public Tuple!(float, "x", float, "y", float, "z") unknown5;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(long entityId, uint actionType=uint.init, int hotbarSlot=int.init, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") unknown4=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") unknown5=Tuple!(float, "x", float, "y", float, "z").init) {
			this.entityId = entityId;
			this.actionType = actionType;
			this.hotbarSlot = hotbarSlot;
			this.item = item;
			this.unknown4 = unknown4;
			this.unknown5 = unknown5;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 3;
			_encode!writeId();
			writeBytes(varlong.encode(entityId));
			writeBytes(varuint.encode(actionType));
			writeBytes(varint.encode(hotbarSlot));
			item.encode(bufferInstance);
			writeLittleEndianFloat(unknown4.x); writeLittleEndianFloat(unknown4.y); writeLittleEndianFloat(unknown4.z);
			writeLittleEndianFloat(unknown5.x); writeLittleEndianFloat(unknown5.y); writeLittleEndianFloat(unknown5.z);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			entityId=varlong.decode(_buffer, &_index);
			actionType=varuint.decode(_buffer, &_index);
			hotbarSlot=varint.decode(_buffer, &_index);
			item.decode(bufferInstance);
			unknown4.x=readLittleEndianFloat(); unknown4.y=readLittleEndianFloat(); unknown4.z=readLittleEndianFloat();
			unknown5.x=readLittleEndianFloat(); unknown5.y=readLittleEndianFloat(); unknown5.z=readLittleEndianFloat();
		}

		public override string toString() {
			return "InventoryTransaction.UseItemOnEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", actionType: " ~ std.conv.to!string(this.actionType) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ", unknown5: " ~ std.conv.to!string(this.unknown5) ~ ")";
		}

	}

	public class ReleaseItem {

		public enum typeof(type) TYPE = 4;

		// action type
		public enum uint SHOOT_BOW = 0;
		public enum uint CONSUME = 1;

		public enum string[] FIELDS = ["actionType", "hotbarSlot", "item", "headPosition"];

		public uint actionType;
		public int hotbarSlot;
		public sul.protocol.bedrock160.types.Slot item;
		public Tuple!(float, "x", float, "y", float, "z") headPosition;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(uint actionType, int hotbarSlot=int.init, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") headPosition=Tuple!(float, "x", float, "y", float, "z").init) {
			this.actionType = actionType;
			this.hotbarSlot = hotbarSlot;
			this.item = item;
			this.headPosition = headPosition;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 4;
			_encode!writeId();
			writeBytes(varuint.encode(actionType));
			writeBytes(varint.encode(hotbarSlot));
			item.encode(bufferInstance);
			writeLittleEndianFloat(headPosition.x); writeLittleEndianFloat(headPosition.y); writeLittleEndianFloat(headPosition.z);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			actionType=varuint.decode(_buffer, &_index);
			hotbarSlot=varint.decode(_buffer, &_index);
			item.decode(bufferInstance);
			headPosition.x=readLittleEndianFloat(); headPosition.y=readLittleEndianFloat(); headPosition.z=readLittleEndianFloat();
		}

		public override string toString() {
			return "InventoryTransaction.ReleaseItem(actionType: " ~ std.conv.to!string(this.actionType) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", headPosition: " ~ std.conv.to!string(this.headPosition) ~ ")";
		}

	}

}

class MobEquipment : Buffer {

	public enum uint ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "item", "inventorySlot", "hotbarSlot", "unknown4"];

	public long entityId;
	public sul.protocol.bedrock160.types.Slot item;
	public ubyte inventorySlot;
	public ubyte hotbarSlot;
	public ubyte unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init, ubyte inventorySlot=ubyte.init, ubyte hotbarSlot=ubyte.init, ubyte unknown4=ubyte.init) {
		this.entityId = entityId;
		this.item = item;
		this.inventorySlot = inventorySlot;
		this.hotbarSlot = hotbarSlot;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		item.encode(bufferInstance);
		writeLittleEndianUbyte(inventorySlot);
		writeLittleEndianUbyte(hotbarSlot);
		writeLittleEndianUbyte(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		inventorySlot=readLittleEndianUbyte();
		hotbarSlot=readLittleEndianUbyte();
		unknown4=readLittleEndianUbyte();
	}

	public static pure nothrow @safe MobEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEquipment ret = new MobEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", inventorySlot: " ~ std.conv.to!string(this.inventorySlot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class MobArmorEquipment : Buffer {

	public enum uint ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "armor"];

	public long entityId;
	public sul.protocol.bedrock160.types.Slot[4] armor;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.bedrock160.types.Slot[4] armor=(sul.protocol.bedrock160.types.Slot[4]).init) {
		this.entityId = entityId;
		this.armor = armor;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		foreach(yjbi;armor){ yjbi.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		foreach(ref yjbi;armor){ yjbi.decode(bufferInstance); }
	}

	public static pure nothrow @safe MobArmorEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobArmorEquipment ret = new MobArmorEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobArmorEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", armor: " ~ std.conv.to!string(this.armor) ~ ")";
	}

}

class Interact : Buffer {

	public enum uint ID = 33;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte LEAVE_VEHICLE = 3;
	public enum ubyte HOVER = 4;
	public enum ubyte OPEN_INVENTORY = 6;

	public enum string[] FIELDS = ["action", "target", "targetPosition"];

	public ubyte action;
	public long target;
	public Tuple!(float, "x", float, "y", float, "z") targetPosition;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, long target=long.init, Tuple!(float, "x", float, "y", float, "z") targetPosition=Tuple!(float, "x", float, "y", float, "z").init) {
		this.action = action;
		this.target = target;
		this.targetPosition = targetPosition;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(action);
		writeBytes(varlong.encode(target));
		if(action==4){ writeLittleEndianFloat(targetPosition.x); writeLittleEndianFloat(targetPosition.y); writeLittleEndianFloat(targetPosition.z); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=readLittleEndianUbyte();
		target=varlong.decode(_buffer, &_index);
		if(action==4){ targetPosition.x=readLittleEndianFloat(); targetPosition.y=readLittleEndianFloat(); targetPosition.z=readLittleEndianFloat(); }
	}

	public static pure nothrow @safe Interact fromBuffer(bool readId=true)(ubyte[] buffer) {
		Interact ret = new Interact();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Interact(action: " ~ std.conv.to!string(this.action) ~ ", target: " ~ std.conv.to!string(this.target) ~ ", targetPosition: " ~ std.conv.to!string(this.targetPosition) ~ ")";
	}

}

class BlockPickRequest : Buffer {

	public enum uint ID = 34;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["position", "unknown1", "slot"];

	public Tuple!(int, "x", int, "y", int, "z") position;
	public bool unknown1;
	public ubyte slot;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "y", int, "z") position, bool unknown1=bool.init, ubyte slot=ubyte.init) {
		this.position = position;
		this.unknown1 = unknown1;
		this.slot = slot;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(position.x)); writeBytes(varint.encode(position.y)); writeBytes(varint.encode(position.z));
		writeLittleEndianBool(unknown1);
		writeLittleEndianUbyte(slot);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=varint.decode(_buffer, &_index); position.y=varint.decode(_buffer, &_index); position.z=varint.decode(_buffer, &_index);
		unknown1=readLittleEndianBool();
		slot=readLittleEndianUbyte();
	}

	public static pure nothrow @safe BlockPickRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockPickRequest ret = new BlockPickRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockPickRequest(position: " ~ std.conv.to!string(this.position) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ")";
	}

}

class EntityPickRequest : Buffer {

	public enum uint ID = 35;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityType", "slot"];

	public long entityType;
	public ubyte slot;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityType, ubyte slot=ubyte.init) {
		this.entityType = entityType;
		this.slot = slot;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianLong(entityType);
		writeLittleEndianUbyte(slot);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityType=readLittleEndianLong();
		slot=readLittleEndianUbyte();
	}

	public static pure nothrow @safe EntityPickRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityPickRequest ret = new EntityPickRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityPickRequest(entityType: " ~ std.conv.to!string(this.entityType) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ")";
	}

}

class PlayerAction : Buffer {

	public enum uint ID = 36;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum int START_BREAK = 0;
	public enum int ABORT_BREAK = 1;
	public enum int STOP_BREAK = 2;
	public enum int GET_UPDATED_BLOCK = 3;
	public enum int DROP_ITEM = 4;
	public enum int START_SLEEPING = 5;
	public enum int STOP_SLEEPING = 6;
	public enum int RESPAWN = 7;
	public enum int JUMP = 8;
	public enum int START_SPRINT = 9;
	public enum int STOP_SPRINT = 10;
	public enum int START_SNEAK = 11;
	public enum int STOP_SNEAK = 12;
	public enum int START_GLIDING = 15;
	public enum int STOP_GLIDING = 16;
	public enum int BUILD_DENIED = 17;
	public enum int CONTINUE_BREAK = 18;
	public enum int CHANGE_SKIN = 19;

	public enum string[] FIELDS = ["entityId", "action", "position", "face"];

	public long entityId;
	public int action;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public int face;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int action=int.init, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, int face=int.init) {
		this.entityId = entityId;
		this.action = action;
		this.position = position;
		this.face = face;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(action));
		position.encode(bufferInstance);
		writeBytes(varint.encode(face));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		action=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		face=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe PlayerAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerAction ret = new PlayerAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerAction(entityId: " ~ std.conv.to!string(this.entityId) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", face: " ~ std.conv.to!string(this.face) ~ ")";
	}

}

class EntityFall : Buffer {

	public enum uint ID = 37;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "distance", "unknown2"];

	public long entityId;
	public float distance;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, float distance=float.init, bool unknown2=bool.init) {
		this.entityId = entityId;
		this.distance = distance;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(distance);
		writeLittleEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		distance=readLittleEndianFloat();
		unknown2=readLittleEndianBool();
	}

	public static pure nothrow @safe EntityFall fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityFall ret = new EntityFall();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityFall(entityId: " ~ std.conv.to!string(this.entityId) ~ ", distance: " ~ std.conv.to!string(this.distance) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class HurtArmor : Buffer {

	public enum uint ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0"];

	public int unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(unknown0));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		unknown0=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe HurtArmor fromBuffer(bool readId=true)(ubyte[] buffer) {
		HurtArmor ret = new HurtArmor();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "HurtArmor(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

class SetEntityData : Buffer {

	public enum uint ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "metadata"];

	public long entityId;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe SetEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityData ret = new SetEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityData(entityId: " ~ std.conv.to!string(this.entityId) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class SetEntityMotion : Buffer {

	public enum uint ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "motion"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.entityId = entityId;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe SetEntityMotion fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityMotion ret = new SetEntityMotion();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityMotion(entityId: " ~ std.conv.to!string(this.entityId) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class SetEntityLink : Buffer {

	public enum uint ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte REMOVE = 0;
	public enum ubyte ADD = 1;

	public enum string[] FIELDS = ["vehicle", "passenger", "action"];

	public long vehicle;
	public long passenger;
	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long vehicle, long passenger=long.init, ubyte action=ubyte.init) {
		this.vehicle = vehicle;
		this.passenger = passenger;
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(vehicle));
		writeBytes(varlong.encode(passenger));
		writeLittleEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		vehicle=varlong.decode(_buffer, &_index);
		passenger=varlong.decode(_buffer, &_index);
		action=readLittleEndianUbyte();
	}

	public static pure nothrow @safe SetEntityLink fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityLink ret = new SetEntityLink();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityLink(vehicle: " ~ std.conv.to!string(this.vehicle) ~ ", passenger: " ~ std.conv.to!string(this.passenger) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
	}

}

class SetHealth : Buffer {

	public enum uint ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["health"];

	public int health;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int health) {
		this.health = health;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(health));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		health=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetHealth fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetHealth ret = new SetHealth();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetHealth(health: " ~ std.conv.to!string(this.health) ~ ")";
	}

}

class SetSpawnPosition : Buffer {

	public enum uint ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// type
	public enum int PLAYER_SPAWN = 0;
	public enum int WORLD_SPAWN = 1;

	public enum string[] FIELDS = ["type", "position", "forced"];

	public int type;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public bool forced;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int type, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, bool forced=bool.init) {
		this.type = type;
		this.position = position;
		this.forced = forced;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(type));
		position.encode(bufferInstance);
		writeLittleEndianBool(forced);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		type=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		forced=readLittleEndianBool();
	}

	public static pure nothrow @safe SetSpawnPosition fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetSpawnPosition ret = new SetSpawnPosition();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetSpawnPosition(type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", forced: " ~ std.conv.to!string(this.forced) ~ ")";
	}

}

class Animate : Buffer {

	public enum uint ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// action
	public enum int BREAKING = 1;
	public enum int WAKE_UP = 3;

	public enum string[] FIELDS = ["action", "entityId", "unknown2"];

	public int action;
	public long entityId;
	public float unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, long entityId=long.init, float unknown2=float.init) {
		this.action = action;
		this.entityId = entityId;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(action));
		writeBytes(varlong.encode(entityId));
		if(action>128){ writeLittleEndianFloat(unknown2); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=varint.decode(_buffer, &_index);
		entityId=varlong.decode(_buffer, &_index);
		if(action>128){ unknown2=readLittleEndianFloat(); }
	}

	public static pure nothrow @safe Animate fromBuffer(bool readId=true)(ubyte[] buffer) {
		Animate ret = new Animate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Animate(action: " ~ std.conv.to!string(this.action) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class Respawn : Buffer {

	public enum uint ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public Tuple!(float, "x", float, "y", float, "z") position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe Respawn fromBuffer(bool readId=true)(ubyte[] buffer) {
		Respawn ret = new Respawn();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Respawn(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class ContainerOpen : Buffer {

	public enum uint ID = 46;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "type", "position", "entityId"];

	public ubyte window;
	public ubyte type;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ubyte type=ubyte.init, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, long entityId=long.init) {
		this.window = window;
		this.type = type;
		this.position = position;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(window);
		writeLittleEndianUbyte(type);
		position.encode(bufferInstance);
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readLittleEndianUbyte();
		type=readLittleEndianUbyte();
		position.decode(bufferInstance);
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerOpen fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerOpen ret = new ContainerOpen();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerOpen(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class ContainerClose : Buffer {

	public enum uint ID = 47;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window"];

	public ubyte window;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window) {
		this.window = window;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(window);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readLittleEndianUbyte();
	}

	public static pure nothrow @safe ContainerClose fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerClose ret = new ContainerClose();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerClose(window: " ~ std.conv.to!string(this.window) ~ ")";
	}

}

class PlayerHotbar : Buffer {

	public enum uint ID = 48;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe PlayerHotbar fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerHotbar ret = new PlayerHotbar();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerHotbar()";
	}

}

class InventoryContent : Buffer {

	public enum uint ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "slots"];

	public uint window;
	public sul.protocol.bedrock160.types.Slot[] slots;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint window, sul.protocol.bedrock160.types.Slot[] slots=(sul.protocol.bedrock160.types.Slot[]).init) {
		this.window = window;
		this.slots = slots;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(window));
		writeBytes(varuint.encode(cast(uint)slots.length)); foreach(cxdm;slots){ cxdm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=varuint.decode(_buffer, &_index);
		slots.length=varuint.decode(_buffer, &_index); foreach(ref cxdm;slots){ cxdm.decode(bufferInstance); }
	}

	public static pure nothrow @safe InventoryContent fromBuffer(bool readId=true)(ubyte[] buffer) {
		InventoryContent ret = new InventoryContent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InventoryContent(window: " ~ std.conv.to!string(this.window) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ")";
	}

}

class InventorySlot : Buffer {

	public enum uint ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe InventorySlot fromBuffer(bool readId=true)(ubyte[] buffer) {
		InventorySlot ret = new InventorySlot();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InventorySlot()";
	}

}

class ContainerSetData : Buffer {

	public enum uint ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "property", "value"];

	public ubyte window;
	public int property;
	public int value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int property=int.init, int value=int.init) {
		this.window = window;
		this.property = property;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(window);
		writeBytes(varint.encode(property));
		writeBytes(varint.encode(value));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readLittleEndianUbyte();
		property=varint.decode(_buffer, &_index);
		value=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerSetData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetData ret = new ContainerSetData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetData(window: " ~ std.conv.to!string(this.window) ~ ", property: " ~ std.conv.to!string(this.property) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class CraftingData : Buffer {

	public enum uint ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["recipes"];

	public sul.protocol.bedrock160.types.Recipe[] recipes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.Recipe[] recipes) {
		this.recipes = recipes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)recipes.length)); foreach(cvabc;recipes){ cvabc.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		recipes.length=varuint.decode(_buffer, &_index); foreach(ref cvabc;recipes){ cvabc.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingData fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingData ret = new CraftingData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingData(recipes: " ~ std.conv.to!string(this.recipes) ~ ")";
	}

}

class CraftingEvent : Buffer {

	public enum uint ID = 53;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window", "type", "uuid", "input", "output"];

	public ubyte window;
	public int type;
	public sul.protocol.bedrock160.types.McpeUuid uuid;
	public sul.protocol.bedrock160.types.Slot[] input;
	public sul.protocol.bedrock160.types.Slot[] output;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int type=int.init, sul.protocol.bedrock160.types.McpeUuid uuid=sul.protocol.bedrock160.types.McpeUuid.init, sul.protocol.bedrock160.types.Slot[] input=(sul.protocol.bedrock160.types.Slot[]).init, sul.protocol.bedrock160.types.Slot[] output=(sul.protocol.bedrock160.types.Slot[]).init) {
		this.window = window;
		this.type = type;
		this.uuid = uuid;
		this.input = input;
		this.output = output;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(window);
		writeBytes(varint.encode(type));
		uuid.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)input.length)); foreach(a5dq;input){ a5dq.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)output.length)); foreach(bvcv;output){ bvcv.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readLittleEndianUbyte();
		type=varint.decode(_buffer, &_index);
		uuid.decode(bufferInstance);
		input.length=varuint.decode(_buffer, &_index); foreach(ref a5dq;input){ a5dq.decode(bufferInstance); }
		output.length=varuint.decode(_buffer, &_index); foreach(ref bvcv;output){ bvcv.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingEvent ret = new CraftingEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingEvent(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
	}

}

class GuiDataPickItem : Buffer {

	public enum uint ID = 54;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["slot"];

	public uint slot;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint slot) {
		this.slot = slot;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUint(slot);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		slot=readLittleEndianUint();
	}

	public static pure nothrow @safe GuiDataPickItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		GuiDataPickItem ret = new GuiDataPickItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "GuiDataPickItem(slot: " ~ std.conv.to!string(this.slot) ~ ")";
	}

}

class AdventureSettings : Buffer {

	public enum uint ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// flags
	public enum uint IMMUTABLE_WORLD = 1;
	public enum uint PVP_DISABLED = 2;
	public enum uint PVM_DISABLED = 4;
	public enum uint MVP_DISBALED = 8;
	public enum uint EVP_DISABLED = 16;
	public enum uint AUTO_JUMP = 32;
	public enum uint ALLOW_FLIGHT = 64;
	public enum uint NO_CLIP = 128;
	public enum uint FLYING = 512;
	public enum uint MUTED = 1024;

	// permission level
	public enum uint LEVEL_USER = 0;
	public enum uint LEVEL_OPERATOR = 1;
	public enum uint LEVEL_HOST = 2;
	public enum uint LEVEL_AUTOMATION = 3;
	public enum uint LEVEL_ADMIN = 4;

	// abilities
	public enum uint BUILD_AND_MINE = 1;
	public enum uint DOORS_AND_SWITCHES = 2;
	public enum uint OPEN_CONTAINERS = 4;
	public enum uint ATTACK_PLAYERS = 8;
	public enum uint ATTACK_MOBS = 16;
	public enum uint OP = 32;
	public enum uint TELEPORT = 64;

	// player rank
	public enum uint VISITOR = 0;
	public enum uint MEMBER = 1;
	public enum uint OPERATOR = 2;
	public enum uint CUSTOM = 3;

	public enum string[] FIELDS = ["flags", "permissionLevel", "abilities", "playerRank", "customPermissions", "entityId"];

	public uint flags;
	public uint permissionLevel;
	public uint abilities;
	public uint playerRank;
	public uint customPermissions;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint flags, uint permissionLevel=uint.init, uint abilities=uint.init, uint playerRank=uint.init, uint customPermissions=uint.init, long entityId=long.init) {
		this.flags = flags;
		this.permissionLevel = permissionLevel;
		this.abilities = abilities;
		this.playerRank = playerRank;
		this.customPermissions = customPermissions;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(flags));
		writeBytes(varuint.encode(permissionLevel));
		writeBytes(varuint.encode(abilities));
		writeBytes(varuint.encode(playerRank));
		writeBytes(varuint.encode(customPermissions));
		writeLittleEndianLong(entityId);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		flags=varuint.decode(_buffer, &_index);
		permissionLevel=varuint.decode(_buffer, &_index);
		abilities=varuint.decode(_buffer, &_index);
		playerRank=varuint.decode(_buffer, &_index);
		customPermissions=varuint.decode(_buffer, &_index);
		entityId=readLittleEndianLong();
	}

	public static pure nothrow @safe AdventureSettings fromBuffer(bool readId=true)(ubyte[] buffer) {
		AdventureSettings ret = new AdventureSettings();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AdventureSettings(flags: " ~ std.conv.to!string(this.flags) ~ ", permissionLevel: " ~ std.conv.to!string(this.permissionLevel) ~ ", abilities: " ~ std.conv.to!string(this.abilities) ~ ", playerRank: " ~ std.conv.to!string(this.playerRank) ~ ", customPermissions: " ~ std.conv.to!string(this.customPermissions) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class BlockEntityData : Buffer {

	public enum uint ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["position", "nbt"];

	public sul.protocol.bedrock160.types.BlockPosition position;
	public ubyte[] nbt;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.BlockPosition position, ubyte[] nbt=(ubyte[]).init) {
		this.position = position;
		this.nbt = nbt;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		position.encode(bufferInstance);
		writeBytes(nbt);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.decode(bufferInstance);
		nbt=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe BlockEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEntityData ret = new BlockEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEntityData(position: " ~ std.conv.to!string(this.position) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
	}

}

class PlayerInput : Buffer {

	public enum uint ID = 57;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["sideways", "forward", "unknown2", "unknown3"];

	public float sideways;
	public float forward;
	public bool unknown2;
	public bool unknown3;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float sideways, float forward=float.init, bool unknown2=bool.init, bool unknown3=bool.init) {
		this.sideways = sideways;
		this.forward = forward;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianFloat(sideways);
		writeLittleEndianFloat(forward);
		writeLittleEndianBool(unknown2);
		writeLittleEndianBool(unknown3);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		sideways=readLittleEndianFloat();
		forward=readLittleEndianFloat();
		unknown2=readLittleEndianBool();
		unknown3=readLittleEndianBool();
	}

	public static pure nothrow @safe PlayerInput fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerInput ret = new PlayerInput();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerInput(sideways: " ~ std.conv.to!string(this.sideways) ~ ", forward: " ~ std.conv.to!string(this.forward) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ")";
	}

}

class FullChunkData : Buffer {

	public enum uint ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data"];

	public Tuple!(int, "x", int, "z") position;
	public sul.protocol.bedrock160.types.ChunkData data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") position, sul.protocol.bedrock160.types.ChunkData data=sul.protocol.bedrock160.types.ChunkData.init) {
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(position.x)); writeBytes(varint.encode(position.z));
		data.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=varint.decode(_buffer, &_index); position.z=varint.decode(_buffer, &_index);
		data.decode(bufferInstance);
	}

	public static pure nothrow @safe FullChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		FullChunkData ret = new FullChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "FullChunkData(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class SetCommandsEnabled : Buffer {

	public enum uint ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["enabled"];

	public bool enabled;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool enabled) {
		this.enabled = enabled;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianBool(enabled);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		enabled=readLittleEndianBool();
	}

	public static pure nothrow @safe SetCommandsEnabled fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetCommandsEnabled ret = new SetCommandsEnabled();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetCommandsEnabled(enabled: " ~ std.conv.to!string(this.enabled) ~ ")";
	}

}

class SetDifficulty : Buffer {

	public enum uint ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum uint PEACEFUL = 0;
	public enum uint EASY = 1;
	public enum uint NORMAL = 2;
	public enum uint HARD = 3;

	public enum string[] FIELDS = ["difficulty"];

	public uint difficulty;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint difficulty) {
		this.difficulty = difficulty;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(difficulty));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		difficulty=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetDifficulty fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetDifficulty ret = new SetDifficulty();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetDifficulty(difficulty: " ~ std.conv.to!string(this.difficulty) ~ ")";
	}

}

class ChangeDimension : Buffer {

	public enum uint ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	public enum string[] FIELDS = ["dimension", "position", "unknown2"];

	public int dimension;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int dimension, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, bool unknown2=bool.init) {
		this.dimension = dimension;
		this.position = position;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(dimension));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		dimension=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		unknown2=readLittleEndianBool();
	}

	public static pure nothrow @safe ChangeDimension fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChangeDimension ret = new ChangeDimension();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChangeDimension(dimension: " ~ std.conv.to!string(this.dimension) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class SetPlayerGameType : Buffer {

	public enum uint ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;
	public enum int ADVENTURE = 2;

	public enum string[] FIELDS = ["gamemode"];

	public int gamemode;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int gamemode) {
		this.gamemode = gamemode;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(gamemode));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		gamemode=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetPlayerGameType fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetPlayerGameType ret = new SetPlayerGameType();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetPlayerGameType(gamemode: " ~ std.conv.to!string(this.gamemode) ~ ")";
	}

}

class PlayerList : Buffer {

	public enum uint ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=readLittleEndianUbyte();
	}

	public static pure nothrow @safe PlayerList fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerList ret = new PlayerList();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerList(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(Add, Remove);

	public class Add {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.bedrock160.types.PlayerList[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.PlayerList[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerList.Add(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class Remove {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.bedrock160.types.McpeUuid[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.McpeUuid[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cxevc;players){ cxevc.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cxevc;players){ cxevc.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerList.Remove(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

}

class SimpleEvent : Buffer {

	public enum uint ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe SimpleEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		SimpleEvent ret = new SimpleEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SimpleEvent()";
	}

}

class TelemetryEvent : Buffer {

	public enum uint ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public int eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int eventId=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TelemetryEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		TelemetryEvent ret = new TelemetryEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TelemetryEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class SpawnExperienceOrb : Buffer {

	public enum uint ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "count"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public int count;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, int count=int.init) {
		this.position = position;
		this.count = count;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(count));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		count=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SpawnExperienceOrb fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnExperienceOrb ret = new SpawnExperienceOrb();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnExperienceOrb(position: " ~ std.conv.to!string(this.position) ~ ", count: " ~ std.conv.to!string(this.count) ~ ")";
	}

}

class ClientboundMapItemData : Buffer {

	public enum uint ID = 67;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// update
	public enum uint TEXTURE = 2;
	public enum uint DECORATIONS = 4;
	public enum uint ENTITIES = 8;

	public enum string[] FIELDS = ["mapId", "update", "scale", "size", "offset", "data", "decorations"];

	public long mapId;
	public uint update;
	public ubyte scale;
	public Tuple!(int, "x", int, "z") size;
	public Tuple!(int, "x", int, "z") offset;
	public ubyte[] data;
	public sul.protocol.bedrock160.types.Decoration[] decorations;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId, uint update=uint.init, ubyte scale=ubyte.init, Tuple!(int, "x", int, "z") size=Tuple!(int, "x", int, "z").init, Tuple!(int, "x", int, "z") offset=Tuple!(int, "x", int, "z").init, ubyte[] data=(ubyte[]).init, sul.protocol.bedrock160.types.Decoration[] decorations=(sul.protocol.bedrock160.types.Decoration[]).init) {
		this.mapId = mapId;
		this.update = update;
		this.scale = scale;
		this.size = size;
		this.offset = offset;
		this.data = data;
		this.decorations = decorations;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(mapId));
		writeBytes(varuint.encode(update));
		if(update==2||update==4){ writeLittleEndianUbyte(scale); }
		if(update==2){ writeBytes(varint.encode(size.x)); writeBytes(varint.encode(size.z)); }
		if(update==2){ writeBytes(varint.encode(offset.x)); writeBytes(varint.encode(offset.z)); }
		if(update==2){ writeBytes(data); }
		if(update==4){ writeBytes(varuint.encode(cast(uint)decorations.length)); foreach(zvbjdlbm;decorations){ zvbjdlbm.encode(bufferInstance); } }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		mapId=varlong.decode(_buffer, &_index);
		update=varuint.decode(_buffer, &_index);
		if(update==2||update==4){ scale=readLittleEndianUbyte(); }
		if(update==2){ size.x=varint.decode(_buffer, &_index); size.z=varint.decode(_buffer, &_index); }
		if(update==2){ offset.x=varint.decode(_buffer, &_index); offset.z=varint.decode(_buffer, &_index); }
		if(update==2){ data=_buffer[_index..$].dup; _index=_buffer.length; }
		if(update==4){ decorations.length=varuint.decode(_buffer, &_index); foreach(ref zvbjdlbm;decorations){ zvbjdlbm.decode(bufferInstance); } }
	}

	public static pure nothrow @safe ClientboundMapItemData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientboundMapItemData ret = new ClientboundMapItemData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientboundMapItemData(mapId: " ~ std.conv.to!string(this.mapId) ~ ", update: " ~ std.conv.to!string(this.update) ~ ", scale: " ~ std.conv.to!string(this.scale) ~ ", size: " ~ std.conv.to!string(this.size) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", decorations: " ~ std.conv.to!string(this.decorations) ~ ")";
	}

}

class MapInfoRequest : Buffer {

	public enum uint ID = 68;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["mapId"];

	public long mapId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId) {
		this.mapId = mapId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(mapId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		mapId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MapInfoRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		MapInfoRequest ret = new MapInfoRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MapInfoRequest(mapId: " ~ std.conv.to!string(this.mapId) ~ ")";
	}

}

class RequestChunkRadius : Buffer {

	public enum uint ID = 69;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["radius"];

	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RequestChunkRadius fromBuffer(bool readId=true)(ubyte[] buffer) {
		RequestChunkRadius ret = new RequestChunkRadius();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RequestChunkRadius(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

class ChunkRadiusUpdated : Buffer {

	public enum uint ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["radius"];

	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ChunkRadiusUpdated fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChunkRadiusUpdated ret = new ChunkRadiusUpdated();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChunkRadiusUpdated(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

class ItemFrameDropItem : Buffer {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "item"];

	public sul.protocol.bedrock160.types.BlockPosition position;
	public sul.protocol.bedrock160.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.BlockPosition position, sul.protocol.bedrock160.types.Slot item=sul.protocol.bedrock160.types.Slot.init) {
		this.position = position;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		position.encode(bufferInstance);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		position.decode(bufferInstance);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe ItemFrameDropItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		ItemFrameDropItem ret = new ItemFrameDropItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ItemFrameDropItem(position: " ~ std.conv.to!string(this.position) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class GameRulesChanged : Buffer {

	public enum uint ID = 72;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["rules"];

	public sul.protocol.bedrock160.types.Rule[] rules;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.Rule[] rules) {
		this.rules = rules;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)rules.length)); foreach(cvzm;rules){ cvzm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		rules.length=varuint.decode(_buffer, &_index); foreach(ref cvzm;rules){ cvzm.decode(bufferInstance); }
	}

	public static pure nothrow @safe GameRulesChanged fromBuffer(bool readId=true)(ubyte[] buffer) {
		GameRulesChanged ret = new GameRulesChanged();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "GameRulesChanged(rules: " ~ std.conv.to!string(this.rules) ~ ")";
	}

}

class Camera : Buffer {

	public enum uint ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "unknown1"];

	public long unknown0;
	public long unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long unknown0, long unknown1=long.init) {
		this.unknown0 = unknown0;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(unknown0));
		writeBytes(varlong.encode(unknown1));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		unknown0=varlong.decode(_buffer, &_index);
		unknown1=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Camera fromBuffer(bool readId=true)(ubyte[] buffer) {
		Camera ret = new Camera();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Camera(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

}

class BossEvent : Buffer {

	public enum uint ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum uint ADD = 0;
	public enum uint UPDATE = 1;
	public enum uint REMOVE = 2;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public uint eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, uint eventId=uint.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BossEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BossEvent ret = new BossEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BossEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class ShowCredits : Buffer {

	public enum uint ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// status
	public enum int START = 0;
	public enum int END = 1;

	public enum string[] FIELDS = ["entityId", "status"];

	public long entityId;
	public int status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int status=int.init) {
		this.entityId = entityId;
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(status));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		status=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ShowCredits fromBuffer(bool readId=true)(ubyte[] buffer) {
		ShowCredits ret = new ShowCredits();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ShowCredits(entityId: " ~ std.conv.to!string(this.entityId) ~ ", status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

class AvailableCommands : Buffer {

	public enum uint ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["enumValues", "unknown1", "enums", "commands"];

	public string[] enumValues;
	public string[] unknown1;
	public sul.protocol.bedrock160.types.Enum[] enums;
	public sul.protocol.bedrock160.types.Command[] commands;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string[] enumValues, string[] unknown1=(string[]).init, sul.protocol.bedrock160.types.Enum[] enums=(sul.protocol.bedrock160.types.Enum[]).init, sul.protocol.bedrock160.types.Command[] commands=(sul.protocol.bedrock160.types.Command[]).init) {
		this.enumValues = enumValues;
		this.unknown1 = unknown1;
		this.enums = enums;
		this.commands = commands;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)enumValues.length)); foreach(z5bzbvc;enumValues){ writeBytes(varuint.encode(cast(uint)z5bzbvc.length)); writeString(z5bzbvc); }
		writeBytes(varuint.encode(cast(uint)unknown1.length)); foreach(d5b9be;unknown1){ writeBytes(varuint.encode(cast(uint)d5b9be.length)); writeString(d5b9be); }
		writeBytes(varuint.encode(cast(uint)enums.length)); foreach(z5bm;enums){ z5bm.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)commands.length)); foreach(y9bfzm;commands){ y9bfzm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		enumValues.length=varuint.decode(_buffer, &_index); foreach(ref z5bzbvc;enumValues){ uint evejy=varuint.decode(_buffer, &_index); z5bzbvc=readString(evejy); }
		unknown1.length=varuint.decode(_buffer, &_index); foreach(ref d5b9be;unknown1){ uint zvoj=varuint.decode(_buffer, &_index); d5b9be=readString(zvoj); }
		enums.length=varuint.decode(_buffer, &_index); foreach(ref z5bm;enums){ z5bm.decode(bufferInstance); }
		commands.length=varuint.decode(_buffer, &_index); foreach(ref y9bfzm;commands){ y9bfzm.decode(bufferInstance); }
	}

	public static pure nothrow @safe AvailableCommands fromBuffer(bool readId=true)(ubyte[] buffer) {
		AvailableCommands ret = new AvailableCommands();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AvailableCommands(enumValues: " ~ std.conv.to!string(this.enumValues) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", enums: " ~ std.conv.to!string(this.enums) ~ ", commands: " ~ std.conv.to!string(this.commands) ~ ")";
	}

}

class CommandRequest : Buffer {

	public enum uint ID = 77;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// type
	public enum uint PLAYER = 0;
	public enum uint COMMAND_BLOCK = 1;
	public enum uint MINECART_COMMAND_BLOCK = 2;
	public enum uint DEV_CONSOLE = 3;

	public enum string[] FIELDS = ["command", "type", "uuid", "requestId", "playerId", "internal"];

	public string command;
	public uint type;
	public sul.protocol.bedrock160.types.McpeUuid uuid;
	public string requestId;
	public int playerId;
	public bool internal;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string command, uint type=uint.init, sul.protocol.bedrock160.types.McpeUuid uuid=sul.protocol.bedrock160.types.McpeUuid.init, string requestId=string.init, int playerId=int.init, bool internal=bool.init) {
		this.command = command;
		this.type = type;
		this.uuid = uuid;
		this.requestId = requestId;
		this.playerId = playerId;
		this.internal = internal;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)command.length)); writeString(command);
		writeBytes(varuint.encode(type));
		uuid.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)requestId.length)); writeString(requestId);
		if(type==3){ writeBytes(varint.encode(playerId)); }
		writeLittleEndianBool(internal);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint y9bfz=varuint.decode(_buffer, &_index); command=readString(y9bfz);
		type=varuint.decode(_buffer, &_index);
		uuid.decode(bufferInstance);
		uint cvdvdl=varuint.decode(_buffer, &_index); requestId=readString(cvdvdl);
		if(type==3){ playerId=varint.decode(_buffer, &_index); }
		internal=readLittleEndianBool();
	}

	public static pure nothrow @safe CommandRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		CommandRequest ret = new CommandRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CommandRequest(command: " ~ std.conv.to!string(this.command) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", requestId: " ~ std.conv.to!string(this.requestId) ~ ", playerId: " ~ std.conv.to!string(this.playerId) ~ ", internal: " ~ std.conv.to!string(this.internal) ~ ")";
	}

}

class CommandBlockUpdate : Buffer {

	public enum uint ID = 78;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["updateBlock", "position", "mode", "redstoneMode", "conditional", "minecart", "command", "lastOutput", "hover", "trackOutput"];

	public bool updateBlock;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public uint mode;
	public bool redstoneMode;
	public bool conditional;
	public long minecart;
	public string command;
	public string lastOutput;
	public string hover;
	public bool trackOutput;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool updateBlock, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, uint mode=uint.init, bool redstoneMode=bool.init, bool conditional=bool.init, long minecart=long.init, string command=string.init, string lastOutput=string.init, string hover=string.init, bool trackOutput=bool.init) {
		this.updateBlock = updateBlock;
		this.position = position;
		this.mode = mode;
		this.redstoneMode = redstoneMode;
		this.conditional = conditional;
		this.minecart = minecart;
		this.command = command;
		this.lastOutput = lastOutput;
		this.hover = hover;
		this.trackOutput = trackOutput;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianBool(updateBlock);
		if(updateBlock==true){ position.encode(bufferInstance); }
		if(updateBlock==true){ writeBytes(varuint.encode(mode)); }
		if(updateBlock==true){ writeLittleEndianBool(redstoneMode); }
		if(updateBlock==true){ writeLittleEndianBool(conditional); }
		if(updateBlock==false){ writeBytes(varlong.encode(minecart)); }
		writeBytes(varuint.encode(cast(uint)command.length)); writeString(command);
		writeBytes(varuint.encode(cast(uint)lastOutput.length)); writeString(lastOutput);
		writeBytes(varuint.encode(cast(uint)hover.length)); writeString(hover);
		writeLittleEndianBool(trackOutput);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		updateBlock=readLittleEndianBool();
		if(updateBlock==true){ position.decode(bufferInstance); }
		if(updateBlock==true){ mode=varuint.decode(_buffer, &_index); }
		if(updateBlock==true){ redstoneMode=readLittleEndianBool(); }
		if(updateBlock==true){ conditional=readLittleEndianBool(); }
		if(updateBlock==false){ minecart=varlong.decode(_buffer, &_index); }
		uint y9bfz=varuint.decode(_buffer, &_index); command=readString(y9bfz);
		uint bfd9dbd=varuint.decode(_buffer, &_index); lastOutput=readString(bfd9dbd);
		uint a9zi=varuint.decode(_buffer, &_index); hover=readString(a9zi);
		trackOutput=readLittleEndianBool();
	}

	public static pure nothrow @safe CommandBlockUpdate fromBuffer(bool readId=true)(ubyte[] buffer) {
		CommandBlockUpdate ret = new CommandBlockUpdate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CommandBlockUpdate(updateBlock: " ~ std.conv.to!string(this.updateBlock) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", mode: " ~ std.conv.to!string(this.mode) ~ ", redstoneMode: " ~ std.conv.to!string(this.redstoneMode) ~ ", conditional: " ~ std.conv.to!string(this.conditional) ~ ", minecart: " ~ std.conv.to!string(this.minecart) ~ ", command: " ~ std.conv.to!string(this.command) ~ ", lastOutput: " ~ std.conv.to!string(this.lastOutput) ~ ", hover: " ~ std.conv.to!string(this.hover) ~ ", trackOutput: " ~ std.conv.to!string(this.trackOutput) ~ ")";
	}

}

class UpdateTrade : Buffer {

	public enum uint ID = 80;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "windowType", "unknown2", "unknown3", "willing", "trader", "player", "displayName", "offers"];

	public ubyte window;
	public ubyte windowType = 15;
	public int unknown2;
	public int unknown3;
	public bool willing;
	public long trader;
	public long player;
	public string displayName;
	public ubyte[] offers;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ubyte windowType=15, int unknown2=int.init, int unknown3=int.init, bool willing=bool.init, long trader=long.init, long player=long.init, string displayName=string.init, ubyte[] offers=(ubyte[]).init) {
		this.window = window;
		this.windowType = windowType;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
		this.willing = willing;
		this.trader = trader;
		this.player = player;
		this.displayName = displayName;
		this.offers = offers;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(window);
		writeLittleEndianUbyte(windowType);
		writeBytes(varint.encode(unknown2));
		writeBytes(varint.encode(unknown3));
		writeLittleEndianBool(willing);
		writeBytes(varlong.encode(trader));
		writeBytes(varlong.encode(player));
		writeBytes(varuint.encode(cast(uint)displayName.length)); writeString(displayName);
		writeBytes(offers);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		window=readLittleEndianUbyte();
		windowType=readLittleEndianUbyte();
		unknown2=varint.decode(_buffer, &_index);
		unknown3=varint.decode(_buffer, &_index);
		willing=readLittleEndianBool();
		trader=varlong.decode(_buffer, &_index);
		player=varlong.decode(_buffer, &_index);
		uint zlcxe5bu=varuint.decode(_buffer, &_index); displayName=readString(zlcxe5bu);
		offers=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe UpdateTrade fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateTrade ret = new UpdateTrade();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateTrade(window: " ~ std.conv.to!string(this.window) ~ ", windowType: " ~ std.conv.to!string(this.windowType) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", willing: " ~ std.conv.to!string(this.willing) ~ ", trader: " ~ std.conv.to!string(this.trader) ~ ", player: " ~ std.conv.to!string(this.player) ~ ", displayName: " ~ std.conv.to!string(this.displayName) ~ ", offers: " ~ std.conv.to!string(this.offers) ~ ")";
	}

}

class UpdateEquip : Buffer {

	public enum uint ID = 81;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe UpdateEquip fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateEquip ret = new UpdateEquip();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateEquip()";
	}

}

class ResourcePackDataInfo : Buffer {

	public enum uint ID = 82;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "maxChunkSize", "chunkCount", "compressedPackSize", "sha256"];

	public string id;
	public uint maxChunkSize;
	public uint chunkCount;
	public ulong compressedPackSize;
	public string sha256;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint maxChunkSize=uint.init, uint chunkCount=uint.init, ulong compressedPackSize=ulong.init, string sha256=string.init) {
		this.id = id;
		this.maxChunkSize = maxChunkSize;
		this.chunkCount = chunkCount;
		this.compressedPackSize = compressedPackSize;
		this.sha256 = sha256;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(maxChunkSize);
		writeLittleEndianUint(chunkCount);
		writeLittleEndianUlong(compressedPackSize);
		writeBytes(varuint.encode(cast(uint)sha256.length)); writeString(sha256);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		maxChunkSize=readLittleEndianUint();
		chunkCount=readLittleEndianUint();
		compressedPackSize=readLittleEndianUlong();
		uint chmu=varuint.decode(_buffer, &_index); sha256=readString(chmu);
	}

	public static pure nothrow @safe ResourcePackDataInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackDataInfo ret = new ResourcePackDataInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackDataInfo(id: " ~ std.conv.to!string(this.id) ~ ", maxChunkSize: " ~ std.conv.to!string(this.maxChunkSize) ~ ", chunkCount: " ~ std.conv.to!string(this.chunkCount) ~ ", compressedPackSize: " ~ std.conv.to!string(this.compressedPackSize) ~ ", sha256: " ~ std.conv.to!string(this.sha256) ~ ")";
	}

}

class ResourcePackChunkData : Buffer {

	public enum uint ID = 83;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "chunkIndex", "progress", "data"];

	public string id;
	public uint chunkIndex;
	public ulong progress;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint chunkIndex=uint.init, ulong progress=ulong.init, ubyte[] data=(ubyte[]).init) {
		this.id = id;
		this.chunkIndex = chunkIndex;
		this.progress = progress;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(chunkIndex);
		writeLittleEndianUlong(progress);
		writeLittleEndianUint(cast(uint)data.length); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		chunkIndex=readLittleEndianUint();
		progress=readLittleEndianUlong();
		data.length=readLittleEndianUint(); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe ResourcePackChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkData ret = new ResourcePackChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkData(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ", progress: " ~ std.conv.to!string(this.progress) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ResourcePackChunkRequest : Buffer {

	public enum uint ID = 84;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["id", "chunkIndex"];

	public string id;
	public uint chunkIndex;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint chunkIndex=uint.init) {
		this.id = id;
		this.chunkIndex = chunkIndex;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeLittleEndianUint(chunkIndex);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint aq=varuint.decode(_buffer, &_index); id=readString(aq);
		chunkIndex=readLittleEndianUint();
	}

	public static pure nothrow @safe ResourcePackChunkRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkRequest ret = new ResourcePackChunkRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkRequest(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ")";
	}

}

class Transfer : Buffer {

	public enum uint ID = 85;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["ip", "port"];

	public string ip;
	public ushort port = 19132;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string ip, ushort port=19132) {
		this.ip = ip;
		this.port = port;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)ip.length)); writeString(ip);
		writeLittleEndianUshort(port);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint aa=varuint.decode(_buffer, &_index); ip=readString(aa);
		port=readLittleEndianUshort();
	}

	public static pure nothrow @safe Transfer fromBuffer(bool readId=true)(ubyte[] buffer) {
		Transfer ret = new Transfer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Transfer(ip: " ~ std.conv.to!string(this.ip) ~ ", port: " ~ std.conv.to!string(this.port) ~ ")";
	}

}

class PlaySound : Buffer {

	public enum uint ID = 86;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["name", "position", "volume", "pitch"];

	public string name;
	public sul.protocol.bedrock160.types.BlockPosition position;
	public float volume;
	public float pitch;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string name, sul.protocol.bedrock160.types.BlockPosition position=sul.protocol.bedrock160.types.BlockPosition.init, float volume=float.init, float pitch=float.init) {
		this.name = name;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		position.encode(bufferInstance);
		writeLittleEndianFloat(volume);
		writeLittleEndianFloat(pitch);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bfz=varuint.decode(_buffer, &_index); name=readString(bfz);
		position.decode(bufferInstance);
		volume=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
	}

	public static pure nothrow @safe PlaySound fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlaySound ret = new PlaySound();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlaySound(name: " ~ std.conv.to!string(this.name) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ")";
	}

}

class StopSound : Buffer {

	public enum uint ID = 87;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["name", "stopAll"];

	public string name;
	public bool stopAll;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string name, bool stopAll=bool.init) {
		this.name = name;
		this.stopAll = stopAll;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		writeLittleEndianBool(stopAll);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint bfz=varuint.decode(_buffer, &_index); name=readString(bfz);
		stopAll=readLittleEndianBool();
	}

	public static pure nothrow @safe StopSound fromBuffer(bool readId=true)(ubyte[] buffer) {
		StopSound ret = new StopSound();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "StopSound(name: " ~ std.conv.to!string(this.name) ~ ", stopAll: " ~ std.conv.to!string(this.stopAll) ~ ")";
	}

}

class SetTitle : Buffer {

	public enum uint ID = 88;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum int HIDE = 0;
	public enum int RESET = 1;
	public enum int SET_TITLE = 2;
	public enum int SET_SUBTITLE = 3;
	public enum int SET_ACTION_BAR = 4;
	public enum int SET_TIMINGS = 5;

	public enum string[] FIELDS = ["action", "text", "fadeIn", "stay", "fadeOut"];

	public int action;
	public string text;
	public int fadeIn;
	public int stay;
	public int fadeOut;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, string text=string.init, int fadeIn=int.init, int stay=int.init, int fadeOut=int.init) {
		this.action = action;
		this.text = text;
		this.fadeIn = fadeIn;
		this.stay = stay;
		this.fadeOut = fadeOut;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(action));
		writeBytes(varuint.encode(cast(uint)text.length)); writeString(text);
		writeBytes(varint.encode(fadeIn));
		writeBytes(varint.encode(stay));
		writeBytes(varint.encode(fadeOut));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		action=varint.decode(_buffer, &_index);
		uint dvd=varuint.decode(_buffer, &_index); text=readString(dvd);
		fadeIn=varint.decode(_buffer, &_index);
		stay=varint.decode(_buffer, &_index);
		fadeOut=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetTitle fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetTitle ret = new SetTitle();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetTitle(action: " ~ std.conv.to!string(this.action) ~ ", text: " ~ std.conv.to!string(this.text) ~ ", fadeIn: " ~ std.conv.to!string(this.fadeIn) ~ ", stay: " ~ std.conv.to!string(this.stay) ~ ", fadeOut: " ~ std.conv.to!string(this.fadeOut) ~ ")";
	}

}

class AddBehaviorTree : Buffer {

	public enum uint ID = 89;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0"];

	public string unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)unknown0.length)); writeString(unknown0);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint d5b9ba=varuint.decode(_buffer, &_index); unknown0=readString(d5b9ba);
	}

	public static pure nothrow @safe AddBehaviorTree fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddBehaviorTree ret = new AddBehaviorTree();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddBehaviorTree(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

class StructureBlockUpdate : Buffer {

	public enum uint ID = 90;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe StructureBlockUpdate fromBuffer(bool readId=true)(ubyte[] buffer) {
		StructureBlockUpdate ret = new StructureBlockUpdate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "StructureBlockUpdate()";
	}

}

class ShowStoreOffer : Buffer {

	public enum uint ID = 91;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "unknown1", "unknown2"];

	public string unknown0;
	public bool unknown1;
	public string unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string unknown0, bool unknown1=bool.init, string unknown2=string.init) {
		this.unknown0 = unknown0;
		this.unknown1 = unknown1;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)unknown0.length)); writeString(unknown0);
		writeLittleEndianBool(unknown1);
		writeBytes(varuint.encode(cast(uint)unknown2.length)); writeString(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint d5b9ba=varuint.decode(_buffer, &_index); unknown0=readString(d5b9ba);
		unknown1=readLittleEndianBool();
		uint d5b9bi=varuint.decode(_buffer, &_index); unknown2=readString(d5b9bi);
	}

	public static pure nothrow @safe ShowStoreOffer fromBuffer(bool readId=true)(ubyte[] buffer) {
		ShowStoreOffer ret = new ShowStoreOffer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ShowStoreOffer(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class PurchaseReceipt : Buffer {

	public enum uint ID = 92;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["unknown0"];

	public string[] unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string[] unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)unknown0.length)); foreach(d5b9ba;unknown0){ writeBytes(varuint.encode(cast(uint)d5b9ba.length)); writeString(d5b9ba); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		unknown0.length=varuint.decode(_buffer, &_index); foreach(ref d5b9ba;unknown0){ uint zvoj=varuint.decode(_buffer, &_index); d5b9ba=readString(zvoj); }
	}

	public static pure nothrow @safe PurchaseReceipt fromBuffer(bool readId=true)(ubyte[] buffer) {
		PurchaseReceipt ret = new PurchaseReceipt();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PurchaseReceipt(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

class PlayerSkin : Buffer {

	public enum uint ID = 93;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["uuid", "skinId", "skinName", "unknown3", "skinData", "capeData", "geometryModel", "geometryData"];

	public sul.protocol.bedrock160.types.McpeUuid uuid;
	public string skinId;
	public string skinName;
	public string unknown3;
	public ubyte[] skinData;
	public ubyte[] capeData;
	public string geometryModel;
	public ubyte[] geometryData;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.bedrock160.types.McpeUuid uuid, string skinId=string.init, string skinName=string.init, string unknown3=string.init, ubyte[] skinData=(ubyte[]).init, ubyte[] capeData=(ubyte[]).init, string geometryModel=string.init, ubyte[] geometryData=(ubyte[]).init) {
		this.uuid = uuid;
		this.skinId = skinId;
		this.skinName = skinName;
		this.unknown3 = unknown3;
		this.skinData = skinData;
		this.capeData = capeData;
		this.geometryModel = geometryModel;
		this.geometryData = geometryData;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		uuid.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)skinId.length)); writeString(skinId);
		writeBytes(varuint.encode(cast(uint)skinName.length)); writeString(skinName);
		writeBytes(varuint.encode(cast(uint)unknown3.length)); writeString(unknown3);
		writeBytes(varuint.encode(cast(uint)skinData.length)); writeBytes(skinData);
		writeBytes(varuint.encode(cast(uint)capeData.length)); writeBytes(capeData);
		writeBytes(varuint.encode(cast(uint)geometryModel.length)); writeString(geometryModel);
		writeBytes(varuint.encode(cast(uint)geometryData.length)); writeBytes(geometryData);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uuid.decode(bufferInstance);
		uint ctbl=varuint.decode(_buffer, &_index); skinId=readString(ctbl);
		uint ctb5bu=varuint.decode(_buffer, &_index); skinName=readString(ctb5bu);
		uint d5b9bm=varuint.decode(_buffer, &_index); unknown3=readString(d5b9bm);
		skinData.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+skinData.length){ skinData=_buffer[_index.._index+skinData.length].dup; _index+=skinData.length; }
		capeData.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+capeData.length){ capeData=_buffer[_index.._index+capeData.length].dup; _index+=capeData.length; }
		uint zvbvclbr=varuint.decode(_buffer, &_index); geometryModel=readString(zvbvclbr);
		geometryData.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+geometryData.length){ geometryData=_buffer[_index.._index+geometryData.length].dup; _index+=geometryData.length; }
	}

	public static pure nothrow @safe PlayerSkin fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerSkin ret = new PlayerSkin();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerSkin(uuid: " ~ std.conv.to!string(this.uuid) ~ ", skinId: " ~ std.conv.to!string(this.skinId) ~ ", skinName: " ~ std.conv.to!string(this.skinName) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", skinData: " ~ std.conv.to!string(this.skinData) ~ ", capeData: " ~ std.conv.to!string(this.capeData) ~ ", geometryModel: " ~ std.conv.to!string(this.geometryModel) ~ ", geometryData: " ~ std.conv.to!string(this.geometryData) ~ ")";
	}

}

class SubClientLogin : Buffer {

	public enum uint ID = 94;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe SubClientLogin fromBuffer(bool readId=true)(ubyte[] buffer) {
		SubClientLogin ret = new SubClientLogin();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SubClientLogin()";
	}

}

class InitiateWebSocketConnection : Buffer {

	public enum uint ID = 95;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0"];

	public string unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)unknown0.length)); writeString(unknown0);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint d5b9ba=varuint.decode(_buffer, &_index); unknown0=readString(d5b9ba);
	}

	public static pure nothrow @safe InitiateWebSocketConnection fromBuffer(bool readId=true)(ubyte[] buffer) {
		InitiateWebSocketConnection ret = new InitiateWebSocketConnection();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InitiateWebSocketConnection(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

class SetLastHurtBy : Buffer {

	public enum uint ID = 96;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0"];

	public int unknown0;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int unknown0) {
		this.unknown0 = unknown0;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varint.encode(unknown0));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		unknown0=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetLastHurtBy fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetLastHurtBy ret = new SetLastHurtBy();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetLastHurtBy(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
	}

}

class BookEdit : Buffer {

	public enum uint ID = 97;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["type", "slot"];

	public ubyte type;
	public ubyte slot;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte type, ubyte slot=ubyte.init) {
		this.type = type;
		this.slot = slot;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeLittleEndianUbyte(type);
		writeLittleEndianUbyte(slot);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		type=readLittleEndianUbyte();
		slot=readLittleEndianUbyte();
	}

	public static pure nothrow @safe BookEdit fromBuffer(bool readId=true)(ubyte[] buffer) {
		BookEdit ret = new BookEdit();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BookEdit(type: " ~ std.conv.to!string(this.type) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "type";

	alias Variants = TypeTuple!(ReplacePage, AddPage, DeletePage, SwapPages, Sign);

	public class ReplacePage {

		public enum typeof(type) TYPE = 0;

		public enum string[] FIELDS = ["pageNumber", "unknown1", "unknown2"];

		public ubyte pageNumber;
		public string unknown1;
		public string unknown2;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(ubyte pageNumber, string unknown1=string.init, string unknown2=string.init) {
			this.pageNumber = pageNumber;
			this.unknown1 = unknown1;
			this.unknown2 = unknown2;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 0;
			_encode!writeId();
			writeLittleEndianUbyte(pageNumber);
			writeBytes(varuint.encode(cast(uint)unknown1.length)); writeString(unknown1);
			writeBytes(varuint.encode(cast(uint)unknown2.length)); writeString(unknown2);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			pageNumber=readLittleEndianUbyte();
			uint d5b9be=varuint.decode(_buffer, &_index); unknown1=readString(d5b9be);
			uint d5b9bi=varuint.decode(_buffer, &_index); unknown2=readString(d5b9bi);
		}

		public override string toString() {
			return "BookEdit.ReplacePage(pageNumber: " ~ std.conv.to!string(this.pageNumber) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
		}

	}

	public class AddPage {

		public enum typeof(type) TYPE = 1;

		public enum string[] FIELDS = ["pageNumber", "unknown1", "unknown2"];

		public ubyte pageNumber;
		public string unknown1;
		public string unknown2;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(ubyte pageNumber, string unknown1=string.init, string unknown2=string.init) {
			this.pageNumber = pageNumber;
			this.unknown1 = unknown1;
			this.unknown2 = unknown2;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 1;
			_encode!writeId();
			writeLittleEndianUbyte(pageNumber);
			writeBytes(varuint.encode(cast(uint)unknown1.length)); writeString(unknown1);
			writeBytes(varuint.encode(cast(uint)unknown2.length)); writeString(unknown2);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			pageNumber=readLittleEndianUbyte();
			uint d5b9be=varuint.decode(_buffer, &_index); unknown1=readString(d5b9be);
			uint d5b9bi=varuint.decode(_buffer, &_index); unknown2=readString(d5b9bi);
		}

		public override string toString() {
			return "BookEdit.AddPage(pageNumber: " ~ std.conv.to!string(this.pageNumber) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
		}

	}

	public class DeletePage {

		public enum typeof(type) TYPE = 2;

		public enum string[] FIELDS = ["pageNumber"];

		public ubyte pageNumber;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(ubyte pageNumber) {
			this.pageNumber = pageNumber;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 2;
			_encode!writeId();
			writeLittleEndianUbyte(pageNumber);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			pageNumber=readLittleEndianUbyte();
		}

		public override string toString() {
			return "BookEdit.DeletePage(pageNumber: " ~ std.conv.to!string(this.pageNumber) ~ ")";
		}

	}

	public class SwapPages {

		public enum typeof(type) TYPE = 3;

		public enum string[] FIELDS = ["page1", "page2"];

		public ubyte page1;
		public ubyte page2;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(ubyte page1, ubyte page2=ubyte.init) {
			this.page1 = page1;
			this.page2 = page2;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 3;
			_encode!writeId();
			writeLittleEndianUbyte(page1);
			writeLittleEndianUbyte(page2);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			page1=readLittleEndianUbyte();
			page2=readLittleEndianUbyte();
		}

		public override string toString() {
			return "BookEdit.SwapPages(page1: " ~ std.conv.to!string(this.page1) ~ ", page2: " ~ std.conv.to!string(this.page2) ~ ")";
		}

	}

	public class Sign {

		public enum typeof(type) TYPE = 4;

		public enum string[] FIELDS = ["title", "author"];

		public string title;
		public string author;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title, string author=string.init) {
			this.title = title;
			this.author = author;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			writeBytes(varuint.encode(cast(uint)author.length)); writeString(author);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dlbu=varuint.decode(_buffer, &_index); title=readString(dlbu);
			uint yva9=varuint.decode(_buffer, &_index); author=readString(yva9);
		}

		public override string toString() {
			return "BookEdit.Sign(title: " ~ std.conv.to!string(this.title) ~ ", author: " ~ std.conv.to!string(this.author) ~ ")";
		}

	}

}

class NpcRequest : Buffer {

	public enum uint ID = 98;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "requestType", "command", "actionType"];

	public long entityId;
	public ubyte requestType;
	public string command;
	public ubyte actionType;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte requestType=ubyte.init, string command=string.init, ubyte actionType=ubyte.init) {
		this.entityId = entityId;
		this.requestType = requestType;
		this.command = command;
		this.actionType = actionType;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianUbyte(requestType);
		writeBytes(varuint.encode(cast(uint)command.length)); writeString(command);
		writeLittleEndianUbyte(actionType);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		entityId=varlong.decode(_buffer, &_index);
		requestType=readLittleEndianUbyte();
		uint y9bfz=varuint.decode(_buffer, &_index); command=readString(y9bfz);
		actionType=readLittleEndianUbyte();
	}

	public static pure nothrow @safe NpcRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		NpcRequest ret = new NpcRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "NpcRequest(entityId: " ~ std.conv.to!string(this.entityId) ~ ", requestType: " ~ std.conv.to!string(this.requestType) ~ ", command: " ~ std.conv.to!string(this.command) ~ ", actionType: " ~ std.conv.to!string(this.actionType) ~ ")";
	}

}

class PhotoTransfer : Buffer {

	public enum uint ID = 99;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["unknown0", "unknown1", "unknown2"];

	public string unknown0;
	public string unknown1;
	public string unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string unknown0, string unknown1=string.init, string unknown2=string.init) {
		this.unknown0 = unknown0;
		this.unknown1 = unknown1;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(cast(uint)unknown0.length)); writeString(unknown0);
		writeBytes(varuint.encode(cast(uint)unknown1.length)); writeString(unknown1);
		writeBytes(varuint.encode(cast(uint)unknown2.length)); writeString(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		uint d5b9ba=varuint.decode(_buffer, &_index); unknown0=readString(d5b9ba);
		uint d5b9be=varuint.decode(_buffer, &_index); unknown1=readString(d5b9be);
		uint d5b9bi=varuint.decode(_buffer, &_index); unknown2=readString(d5b9bi);
	}

	public static pure nothrow @safe PhotoTransfer fromBuffer(bool readId=true)(ubyte[] buffer) {
		PhotoTransfer ret = new PhotoTransfer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PhotoTransfer(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class ModalFormRequest : Buffer {

	public enum uint ID = 100;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["formId", "data"];

	public uint formId;
	public string data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint formId, string data=string.init) {
		this.formId = formId;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(formId));
		writeBytes(varuint.encode(cast(uint)data.length)); writeString(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		formId=varuint.decode(_buffer, &_index);
		uint zfy=varuint.decode(_buffer, &_index); data=readString(zfy);
	}

	public static pure nothrow @safe ModalFormRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		ModalFormRequest ret = new ModalFormRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ModalFormRequest(formId: " ~ std.conv.to!string(this.formId) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ModalFormResponse : Buffer {

	public enum uint ID = 101;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["formId", "data"];

	public uint formId;
	public string data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint formId, string data=string.init) {
		this.formId = formId;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(formId));
		writeBytes(varuint.encode(cast(uint)data.length)); writeString(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		formId=varuint.decode(_buffer, &_index);
		uint zfy=varuint.decode(_buffer, &_index); data=readString(zfy);
	}

	public static pure nothrow @safe ModalFormResponse fromBuffer(bool readId=true)(ubyte[] buffer) {
		ModalFormResponse ret = new ModalFormResponse();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ModalFormResponse(formId: " ~ std.conv.to!string(this.formId) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ServerSettingsRequest : Buffer {

	public enum uint ID = 102;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe ServerSettingsRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerSettingsRequest ret = new ServerSettingsRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerSettingsRequest()";
	}

}

class ServerSettingsResponse : Buffer {

	public enum uint ID = 103;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["formId", "data"];

	public uint formId;
	public string data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint formId, string data=string.init) {
		this.formId = formId;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(formId));
		writeBytes(varuint.encode(cast(uint)data.length)); writeString(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		formId=varuint.decode(_buffer, &_index);
		uint zfy=varuint.decode(_buffer, &_index); data=readString(zfy);
	}

	public static pure nothrow @safe ServerSettingsResponse fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerSettingsResponse ret = new ServerSettingsResponse();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerSettingsResponse(formId: " ~ std.conv.to!string(this.formId) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ShowProfile : Buffer {

	public enum uint ID = 104;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe ShowProfile fromBuffer(bool readId=true)(ubyte[] buffer) {
		ShowProfile ret = new ShowProfile();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ShowProfile()";
	}

}

class SetDefaultGameType : Buffer {

	public enum uint ID = 105;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// game type
	public enum uint SURVIVAL = 0;
	public enum uint CREATIVE = 1;
	public enum uint ADVENTURE = 2;

	public enum string[] FIELDS = ["gameType"];

	public uint gameType;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint gameType) {
		this.gameType = gameType;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBytes(varuint.encode(ID)); }
		writeBytes(varuint.encode(gameType));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ uint _id; _id=varuint.decode(_buffer, &_index); }
		gameType=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetDefaultGameType fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetDefaultGameType ret = new SetDefaultGameType();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetDefaultGameType(gameType: " ~ std.conv.to!string(this.gameType) ~ ")";
	}

}

